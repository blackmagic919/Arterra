// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Assets/Resources/Utility/RotationTables.hlsl"
#include "Assets/Resources/Utility/GetIndex.hlsl"


const static int numThreads = 8;
const static uint POINT_STRIDE_4BYTES = 3 + 1 + 2;

struct structureInfo{
    float3 structurePos;
    uint structureIndex;
    uint2 rotation;
};

struct settings{
    int minimumLOD;

    uint randThetaRot;
    uint randPhiRot;
    int sizeX;
    int sizeY;
    int sizeZ;
};

StructuredBuffer<uint> _MemoryBuffer;
StructuredBuffer<uint> _AddressDict;
uint addressIndex;

structureInfo ReadStructure(uint structureAddress){
    structureInfo structure = (structureInfo)0;

    structure.structurePos.x = asfloat(_MemoryBuffer[structureAddress]);
    structure.structurePos.y = asfloat(_MemoryBuffer[structureAddress + 1]);
    structure.structurePos.z = asfloat(_MemoryBuffer[structureAddress + 2]);

    structure.structureIndex = asuint(_MemoryBuffer[structureAddress + 3]);

    structure.rotation.x = asuint(_MemoryBuffer[structureAddress + 4]);
    structure.rotation.y = asuint(_MemoryBuffer[structureAddress + 5]);

    return structure;
}

StructuredBuffer<settings> _StructureSettings; //settings for structure
StructuredBuffer<uint2> _StructureIndexes;
StructuredBuffer<float> _StructureDensities;
StructuredBuffer<int> _StructureMaterials;

RWStructuredBuffer<float> density;
RWStructuredBuffer<int> material;

StructuredBuffer<uint> numPoints;

uint chunkSize;
uint meshSkipInc;
float IsoLevel;

[numthreads(numThreads,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= numPoints[0])
        return;

    uint structureAddress = _AddressDict[addressIndex] + id.x * POINT_STRIDE_4BYTES;
    structureInfo structure = ReadStructure(structureAddress);
    //can't use implicit concatenation because -1.5 -> -1 while 1.5 -> 1, positive ints for current chunk, negative for adjacent ones
    int3 origin = int3(floor(structure.structurePos.x), floor(structure.structurePos.y), floor(structure.structurePos.z));
    uint2 rotation = structure.rotation;
    uint structureIndex = structure.structureIndex;

    settings structureSettings = _StructureSettings[structureIndex];
    uint3 sizes = uint3(structureSettings.sizeX, structureSettings.sizeY, structureSettings.sizeZ);

    //Where in the chunk to start generation
    uint3 chunkOrigin = uint3(max(0, origin.x), max(0, origin.y), max(0, origin.z));

    int3 xAxis = int3(mul(RotationLookupTable[rotation.x][rotation.y], float3(1, 0, 0)));
    int3 xDir = abs(xAxis);
    bool xFlipped = dot(xAxis, float3(1, 1, 1)) < 0;

    int3 yAxis = int3(mul(RotationLookupTable[rotation.x][rotation.y], float3(0, 1, 0)));
    int3 yDir = abs(yAxis);
    bool yFlipped = dot(yAxis, float3(1, 1, 1)) < 0;

    int3 zAxis = int3(mul(RotationLookupTable[rotation.x][rotation.y], float3(0, 0, 1)));
    int3 zDir = abs(zAxis);
    bool zFlipped = dot(zAxis, float3(1, 1, 1)) < 0;

    uint xLength = dot(sizes, xDir);
    uint yLength = dot(sizes, yDir);
    uint zLength = dot(sizes, zDir);

    int3 chunkEnd = int3((origin.x + xLength), (origin.y + yLength), (origin.z + zLength));
    uint numPointsPerAxis = chunkSize / meshSkipInc+1;

    uint indexOffset = _StructureIndexes[structureIndex].x;

    //Evaluate chunk coord with LoD
    uint3 chunkOriginLoD = uint3(ceil(chunkOrigin.x / (float)meshSkipInc), ceil(chunkOrigin.y / (float)meshSkipInc), ceil(chunkOrigin.z / (float)meshSkipInc));
    uint3 chunkEndLoD = uint3(min(numPointsPerAxis, chunkEnd.x / meshSkipInc), min(numPointsPerAxis, chunkEnd.y / meshSkipInc), min(numPointsPerAxis, chunkEnd.z / meshSkipInc));
    chunkOriginLoD = min(chunkOriginLoD, chunkEndLoD);

    uint3 originDist = chunkOriginLoD*meshSkipInc - origin;
    int3 structOrigin = int3(0, 0, 0);

    //if Flipped ? (Reverse Index: Get xSize, - distXOrigin, Use Regular Index) * xDirection
    structOrigin += (xFlipped ? (dot(sizes-1, xDir) - originDist.x) : originDist.x) * xDir;
    structOrigin += (yFlipped ? (dot(sizes-1, yDir) - originDist.y) : originDist.y) * yDir;
    structOrigin += (zFlipped ? (dot(sizes-1, zDir) - originDist.z) : originDist.z) * zDir;

    uint3 structLength = uint3(0, 0, 0);
    structLength.x = max(chunkEndLoD.x - chunkOriginLoD.x, 0);
    structLength.y = max(chunkEndLoD.y - chunkOriginLoD.y, 0);
    structLength.z = max(chunkEndLoD.z - chunkOriginLoD.z, 0);
    uint structLength0 = structLength.x * structLength.y * structLength.z;

    //I hope it doesn't complain about the triple loop *nervous laugh*
    //It crashed cause of the triple loop :(
    for(uint pos = 0; pos < structLength0; pos++){

        uint x = pos % structLength.x;
        uint y = (pos / structLength.x) % structLength.y;
        uint z = pos / (structLength.x * structLength.y);

        uint xReal = x * meshSkipInc;
        uint yReal = y * meshSkipInc;
        uint zReal = z * meshSkipInc;
        
        uint3 structCoord = structOrigin + xAxis * xReal + yAxis * yReal + zAxis * zReal;
        uint3 chunkCoord = chunkOriginLoD + uint3(x,y,z);

        //structCoord = min(structCoord, sizes - 1);
        uint chunkIndex = indexFromCoordManual(chunkCoord.x, chunkCoord.y, chunkCoord.z, chunkSize / meshSkipInc + 1);
        uint structIndex = indexFromCoordIrregular(structCoord.x, structCoord.y, structCoord.z, sizes.x, sizes.y) + indexOffset;

        //This section will have racing issues, but it's negligable
        //If < IsoLevel, don't override ground, but otherwise override
        if(_StructureDensities[structIndex] > min(density[chunkIndex], IsoLevel)){
            density[chunkIndex] = _StructureDensities[structIndex];
            material[chunkIndex] = max(_StructureMaterials[structIndex], 0);
        }
    }
}
