
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

const static int numLoDThreads = 8;
const static int numChunkThreads = 64;
const static float3 float3One = {1, 1, 1};

//You can't seperate these values into different append buffers
//because there is no way to gaurantee they're appended in same order
struct structurePoint{
    float3 position;
    uint LoD;
    //Padding to keep same stride as terrain checks
};

RWStructuredBuffer<structurePoint> structures;
uint bSTART;

RWStructuredBuffer<uint> counter;
uint bCOUNTER;

int maxLOD;
int3 originChunkCoord;
uint chunkSize;

//The average number of structures at minimum LoD(not collective LoD)
uint numPoints0;
float LoDFalloff;


float3 random(float3 seed)
{
    seed = float3(dot(seed, float3(127.1, 311.7, 531.5)),
                dot(seed, float3(269.5, 183.3, 246.1)),
                dot(seed, float3(419.2, 371.9, 619.8)));
    return frac(sin(seed) * 43758.5453123);
}

float random(int seed)
{
    seed = (seed ^ 12345) * 6789;
    return frac((seed & 0x7FFFFFFF) * (1.0 / 2147483648.0));
}

float3 random(int3 seed){
    return random(float3(random(seed.x), random(seed.y), random(seed.z)));
}

float random(float seed){
    float hash = frac(sin(seed) * 43758.5453);
    return frac(hash * seed);
}

//Rationale: Instead of every chunk managing multiple LoD's, we have a single LoD per chunk
//This allows us to map multiple threads to low LoDs, which is better 
//because low LoDs will generate more structures

//          chunk offset    LoD
[numthreads(numChunkThreads,numLoDThreads,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int LoD = id.y; //This means range from max->LoD 
    uint numChunkAxis = LoD + 2;
    uint numChunks = numChunkAxis * numChunkAxis * numChunkAxis;
    uint numChunksMax = (maxLOD+2) * (maxLOD+2) * (maxLOD+2); //This is the number of chunks in the max LoD

    if(LoD > maxLOD || id.x >= numChunksMax)
        return;
    
    int3 offsetCoord;
    offsetCoord.x = id.x % numChunkAxis;
    offsetCoord.y = (id.x / numChunkAxis) % numChunkAxis;
    offsetCoord.z = (id.x / (numChunkAxis * numChunkAxis)) % numChunkAxis;
    int overlapOffset = id.x / numChunks;
    int chunkOverlap = numChunksMax / numChunks + ((id.x % numChunks) < numChunksMax % numChunks ? 1 : 0); 
    //ie numChunkMax = 3*3*3 = 27, numChunks = 2*2*2 = 8, offset = 3, overlap = 27 / 8 + 1 = 4 <-- it will be mapped to 4 times

    //Obtain random seed
    int3 chunkCoord = originChunkCoord - offsetCoord;
    float3 seed3 = random(chunkCoord) + float3One * (random(LoD) + overlapOffset);
    uint numPoints = uint((numPoints0 * pow(abs(LoDFalloff), -LoD)) / chunkOverlap + random(dot(seed3, float3One))); //Random to process fractional points 

    for(uint i = 0; i < numPoints; i++){
        float3 position =  (random(seed3) * chunkSize) - offsetCoord * chunkSize;

        structurePoint newStructure;
        newStructure.position = position;
        newStructure.LoD = (uint)LoD;
        
        uint appendInd = 0;
        InterlockedAdd(counter[bCOUNTER], 1u, appendInd);
        structures[appendInd + bSTART] = newStructure;

        //Increment seed3 by one instead of random 
        //so it's value is independent of the number of threads running it
        seed3 += float3One * chunkOverlap; 
    }
}
