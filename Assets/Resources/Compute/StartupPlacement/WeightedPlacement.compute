#include "Assets/Resources/Compute/Utility/GetIndex.hlsl"
#include "Assets/Resources/Compute/Utility/Encodings.hlsl"
#include "Assets/Resources/Compute/MapData/CCoordHash.hlsl"
#pragma kernel WeightedPlace
#pragma kernel FindSmallest
const static uint numThreads = 8;

struct entityCheck{
    uint bounds;// upper_vis, low_vis, upper_dens, low_dens
    uint flags;
};

struct entityBound{
    uint3 boundSize;
    uint boundStart;
};

StructuredBuffer<uint> _MemoryBuffer;
StructuredBuffer<CInfo> _AddressDict;
StructuredBuffer<entityBound> _EntityInfo;
StructuredBuffer<entityCheck> _EntityProfile;

RWStructuredBuffer<int3> Result;
RWStructuredBuffer<uint> Lock;
uint bSTART;
uint bLOCK; //Lock to get the smallest coord

uint SearchRadius;
uint ProfileEntity;
int3 SearchCenter;

int mapChunkSize;




uint SampleMapData(int3 GCoord){
    int3 MCoord = ((GCoord % mapChunkSize) + mapChunkSize) % mapChunkSize;
    int3 CCoord = (GCoord - MCoord) / mapChunkSize;

    CInfo chunkHandle = _AddressDict[HashCoord(CCoord)];
    if(!Contains(chunkHandle, CCoord))
        return asuint(-1);
    else{
        uint address = chunkHandle.address + indexFromCoord(MCoord);
        return _MemoryBuffer[address];
    }
}

uint density(uint data) { return data & 0x000000FF; }
uint viscosity(uint data) { return (data & 0x0000FF00) >> 8; }
uint material(uint data) { return (data & 0x7FFF0000) >> 16; }
bool InBounds(uint data, uint bounds) { 
    uint density = data & 0xFF; uint viscosity = (data >> 8) & 0xFF;
    return density >= (bounds & 0xFF) && density <= ((bounds >> 8) & 0xFF) && viscosity >= ((bounds >> 16) & 0xFF) && viscosity <= ((bounds >> 24) & 0xFF); 
}

[numthreads(numThreads,numThreads,numThreads)]
void WeightedPlace (uint3 id : SV_DispatchThreadID)
{
    if(any(id >= SearchRadius * 2)) return;
    int3 Position = SearchCenter + (int3)id - (int)SearchRadius;
    entityBound bounds = _EntityInfo[ProfileEntity];
    uint entityLength = bounds.boundSize.x * bounds.boundSize.y * bounds.boundSize.z;

    bool allC = true; bool anyC = false; bool any0 = false;
    for(uint i = 0; i < entityLength; i++){
        int3 offsetCoord = uint3(i / (bounds.boundSize.y * bounds.boundSize.z), 
                                (i / bounds.boundSize.z) % bounds.boundSize.y, 
                                i % bounds.boundSize.z);
        entityCheck check = _EntityProfile[bounds.boundStart + i];

        bool valid = InBounds(SampleMapData(Position + offsetCoord), check.bounds);
        allC = allC && (valid || !(check.flags & 0x1));
        anyC = anyC || (valid && (check.flags & 0x2));
        any0 = any0 || (check.flags & 0x2);
    }  if(!allC || (any0 && !anyC)) return;

    int3 DCoord = ((int3)id) - (int)SearchRadius; //Delta Coord--The delta position from the center
    uint encoding = DistanceEncode(DCoord);
    InterlockedMin(Lock[bLOCK], encoding);
}

[numthreads(numThreads,numThreads,numThreads)]
void FindSmallest (uint3 id : SV_DispatchThreadID){
    if(any(id > SearchRadius * 2)) return;
    int3 DCoord = ((int3)id) - (int)SearchRadius;
    uint encoding = DistanceEncode(DCoord);
    if(Lock[bLOCK] != encoding) return;
    Result[bSTART] = DCoord;
}

