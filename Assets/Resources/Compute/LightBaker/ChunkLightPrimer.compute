#include "Assets/Resources/Compute/MapData/CCoordHash.hlsl"
#include "Assets/Resources/Compute/Utility/GetIndex.hlsl"
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CleanChunk
#pragma kernel CopyHash
const static int numThreads = 8;

RWStructuredBuffer<uint> _MemoryBuffer;
StructuredBuffer<uint2> _DirectAddress;
RWStructuredBuffer<uint2> DirtySubChunks;
uint chunkLHOffset;
uint chunkLMOffset;
uint nChunkAddress;
uint oChunkAddress;
int3 CCoord;


uint bSTART;
uint bCOUNT;
uint QueueSize;

uint subChunksAxis;
uint subChunkSize;
//Number of hash bits divided by 32
uint numLightUnits; 

[numthreads(numThreads,1,1)]
void CleanChunk (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= numLightUnits) return;
    
    uint rLight;
    if(oChunkAddress == -1) rLight = 0;
    else { 
        uint rAddress = _DirectAddress[oChunkAddress].y;
        rAddress += chunkLMOffset + id.x;
        rLight = _MemoryBuffer[rAddress];
    } 

    uint wAddress = _DirectAddress[nChunkAddress].y;
    wAddress += chunkLMOffset + id.x;
    _MemoryBuffer[wAddress] = rLight;
}

const static int numThreadsS = 32;
[numthreads(numThreadsS,1,1)]
void CopyHash (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= numLightUnits) return;

    uint bitMap = 0;
    if(oChunkAddress != 0){
        uint rAddress = _DirectAddress[oChunkAddress].y;
        rAddress += chunkLHOffset + id.x;
        bitMap = _MemoryBuffer[rAddress]; 
    } uint CIndex = HashCoord(CCoord);

    [unroll]for(int i = 0; i < 32; i++){
        uint bit = (bitMap >> i) & 0x1;
        if(bit == 0x1) continue;
        uint SIndex = id.x * 32 + i;
        uint ind;
        InterlockedAdd(DirtySubChunks[bCOUNT].y, 1, ind);
        ind = bSTART + ((ind + DirtySubChunks[bCOUNT].x) % QueueSize);
        DirtySubChunks[ind] = uint2(CIndex, SIndex);
    } 

    uint wAddress = nChunkAddress + chunkLHOffset + id.x;
    _MemoryBuffer[wAddress] = 0xFFFFFFFF; 
}

