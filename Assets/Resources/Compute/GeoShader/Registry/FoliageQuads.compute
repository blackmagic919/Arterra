// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#include "Assets/Resources/Compute/GeoShader/VertexPacker.hlsl"
#include "Assets/Resources/Compute/Utility/GetIndex.hlsl"
#include "Assets/Resources/Compute/Utility/Random.hlsl"

const static int numThreads = 256;

struct Level {
    float cullPrcnt;
    float sizeInflate;
};

struct Quad {
    float3 topLeft;
    float3 topRight;
    float3 bottomLeft;
    float3 bottomRight;
};

struct DrawTriangle{
    uint3 vertices[3];
    uint BaseSCInd;
};

struct Settings{
    float QuadSize;
    float InflationFactor;
    float4 LeafColor;
    int TexIndex;
    // 0 = Triple
    // 1 = Quads Along Normal
    // 2 = Quad facing normal
    int QuadType;
};

StructuredBuffer<Level> DetailSettings;
StructuredBuffer<Settings> VariantSettings;
StructuredBuffer<SourceVertex> SourceVertices;
StructuredBuffer<uint3> SourceTriangles;
StructuredBuffer<uint2> _AddressDict;
uint vertAddress;
uint triAddress;

RWStructuredBuffer<uint> Counters;
RWStructuredBuffer<DrawTriangle> DrawTriangles;
int bSTART_base;
int bCOUNT_base;
int bSTART_oGeo;
int bCOUNT_oGeo;


uint3 InitializeDrawVertex(float3 positionOS, float3 normalOS, uint2 uv, uint mat){
    uint3 data = PackVertices(positionOS, normalOS, mat);
    data.z |= uv.x << 24 | uv.y << 28;
    return data;
}


float3 GetTriangleCenter(float3 a, float3 b, float3 c) {
    return (a + b + c) / 3.0;
}

float3 random(float3 st)
{
    st = float3(dot(st, float3(127.1, 311.7, 531.5)),
                dot(st, float3(269.5, 183.3, 246.1)),
                dot(st, float3(419.2, 371.9, 619.8)));
    return -1.0 + 2.0 * frac(sin(st) * 43758.5453123);
}

Quad GetQuad(float3 center, float3 right, float3 up, uint mat, uint baseSC){    
    Settings s = VariantSettings[mat];
    float size = DetailSettings[GetDetailLevel(baseSC)].sizeInflate * s.QuadSize;

    Quad quad = (Quad)0;
    quad.topLeft = center - right * (size / 2.0) + up * (size / 2.0);
    quad.topRight = center + right * (size / 2.0) + up * (size / 2.0);
    quad.bottomLeft = center - right * (size / 2.0) - up * (size / 2.0);
    quad.bottomRight = center + right * (size / 2.0) - up * (size / 2.0);

    return quad;
}

void AppendTri(DrawTriangle tri){
    int appendInd = 0;
    InterlockedAdd(Counters[bCOUNT_oGeo], 1, appendInd);
    DrawTriangles[bSTART_oGeo + appendInd] = tri;
}

void AppendQuad(Quad quad, float3 normalOS, uint mat, uint baseSC, inout uint2 chance){
    Settings s = VariantSettings[mat];
    //Bottom triangle
    DrawTriangle lowerTri = (DrawTriangle)0;
    lowerTri.vertices[0] = InitializeDrawVertex(quad.topLeft + s.InflationFactor*normalOS, normalOS, uint2(0, 1), mat);
    lowerTri.vertices[2] = InitializeDrawVertex(quad.bottomLeft + s.InflationFactor*normalOS, normalOS, uint2(0, 0), mat);
    lowerTri.vertices[1] = InitializeDrawVertex(quad.bottomRight + s.InflationFactor*normalOS, normalOS, uint2(1, 0), mat); //Add this first because clockwise winding
    lowerTri.BaseSCInd = baseSC;
    if (RandomFloat(quad.bottomLeft) < float(chance.x) / float(chance.y)) {
        AppendTri(lowerTri);
        chance.x--;
    }
    
    //Top triangle
    DrawTriangle topTri = (DrawTriangle)0;
    topTri.vertices[0] = InitializeDrawVertex(quad.topLeft + s.InflationFactor*normalOS, normalOS, uint2(0, 1), mat);
    topTri.vertices[2] = InitializeDrawVertex(quad.bottomRight + s.InflationFactor*normalOS, normalOS, uint2(1, 0), mat);
    topTri.vertices[1] = InitializeDrawVertex(quad.topRight + s.InflationFactor*normalOS, normalOS, uint2(1, 1), mat);
    topTri.BaseSCInd = baseSC;
    if (RandomFloat(quad.bottomRight) < float(chance.x) / float(chance.y)) {
        AppendTri(topTri);
        chance.x--;
    } chance.y -= 2;
}

void CreateQuadIntersects(float3 center, float3 normalOS, uint mat, uint baseSC) {
    float3 forward = normalize(normalOS);
    float3 right = normalize(float3(-forward.y, forward.x, forward.z)); //90 deg rotation in 2 axis
    float3 up = cross(forward, right); right = cross(up, forward); //Recalculate right to ensure orthogonality
    Settings s = VariantSettings[mat];

    uint level = GetDetailLevel(baseSC); uint2 genChance; 
    genChance.y =  6 - ((s.QuadType & 0x1) * 2 + (s.QuadType & 0x2) * 4);
    float genPrcnt = (1 - DetailSettings[level].cullPrcnt) * genChance.y;
    genChance.x = floor(genPrcnt) + (RandomFloat(center) < frac(genPrcnt) ? 1 : 0);

    if(!(s.QuadType & 0x2)) AppendQuad(GetQuad(center, right, forward, mat, baseSC), normalOS, mat, baseSC, genChance);
    if(!(s.QuadType & 0x2)) AppendQuad(GetQuad(center, up, forward, mat, baseSC), normalOS, mat, baseSC, genChance);
    if(!(s.QuadType & 0x1)) AppendQuad(GetQuad(center, right, up, mat, baseSC), normalOS, mat, baseSC, genChance);
}

float getArea(float3 a, float3 b, float3 c) {return 0.5 * length(cross(b - a, c - a));}

[numthreads(numThreads,1,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    uint startIndex = Counters[bCOUNT_base];
    uint numSourceTriangles = Counters[bCOUNT_base+1] - startIndex;
    if(id.x >= numSourceTriangles)
        return;

    uint triIndex = Counters[bSTART_base + startIndex + id.x];
    uint3 sourceTri = SourceTriangles[_AddressDict[triAddress].y + triIndex];

    SourceVertex inputs[3];
    inputs[0] = SourceVertices[_AddressDict[vertAddress].y + sourceTri.x];
    inputs[1] = SourceVertices[_AddressDict[vertAddress].y + sourceTri.y];
    inputs[2] = SourceVertices[_AddressDict[vertAddress].y + sourceTri.z];
    uint baseSC = GetBaseSubChunk(inputs);
    uint material = GetShaderVariant(inputs);

    float3 center = GetTriangleCenter(inputs[0].positionOS, inputs[1].positionOS, inputs[2].positionOS);
    //Use hard normal rather than smooth normals
    float3 normal = normalize(cross(inputs[1].positionOS - inputs[0].positionOS,
                                inputs[2].positionOS - inputs[0].positionOS));
    CreateQuadIntersects(center, normal, material, baseSC);
  
}