// Each #kernel tells which function to compile; you can have many kernels
#include "Assets/Resources/Compute/GeoShader/VertexPacker.hlsl"
#pragma kernel FilterShader
#pragma kernel FilterSubChunks
const static int numThreads = 256;

struct pInfo{
    uint axis[3];
};

StructuredBuffer<SourceVertex> Vertices;
StructuredBuffer<pInfo> Triangles;
StructuredBuffer<uint2> _AddressDict;
uint vertAddress;
uint triAddress;

StructuredBuffer<uint> counter;
StructuredBuffer<uint> triangleIndexOffset;
StructuredBuffer<uint> shaderPrefix;
uint bSTART_scount;
uint bSTART_tri;
uint bCOUNT_base;
uint bCOUNT_offset;

RWStructuredBuffer<uint> filteredIndicies;
uint bSTART_sort;

[numthreads(numThreads,1,1)]
void FilterShader (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= counter[bCOUNT_base])
        return;

    uint shaderIndex = asuint(-1); 
    uint start = counter[bCOUNT_offset];
    pInfo vIndex = Triangles[_AddressDict[triAddress].y + start + id.x];
    [unroll] for(uint i = 0; i < 3; i++) {
        int material = Vertices[_AddressDict[vertAddress].y + vIndex.axis[i]].material.x; // Only consider solid material
        uint sInd = _MatTerrainData[material].geoShaderInd;
        if((sInd & 0x80000000) == 0) continue;
        shaderIndex = min(shaderIndex, (sInd >> 16) & 0x7FFF);
    }

    if(shaderIndex == asuint(-1)) return;
    uint shaderOffset = shaderPrefix[bSTART_scount + shaderIndex];
    uint triangleOffset = triangleIndexOffset[bSTART_tri + id.x];
    uint offset = shaderOffset + triangleOffset; 

    //Now it's all sorted!!
    filteredIndicies[bSTART_sort + offset] = start + id.x;
}

StructuredBuffer<uint> SubChunkPrefix;
RWStructuredBuffer<pInfo> filteredGeometry;
uint bSTART_sChunkP;

[numthreads(numThreads,1,1)]
void FilterSubChunks(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= counter[bCOUNT_base])
        return;

    pInfo sourceTri = Triangles[_AddressDict[triAddress].y + id.x];
    SourceVertex inputs[3];
    inputs[0] = Vertices[_AddressDict[vertAddress].y + sourceTri.axis[0]];
    inputs[1] = Vertices[_AddressDict[vertAddress].y + sourceTri.axis[1]];
    inputs[2] = Vertices[_AddressDict[vertAddress].y + sourceTri.axis[2]];
    int baseSC = GetBaseSubChunk(inputs);

    uint scOffset = SubChunkPrefix[bSTART_sChunkP + baseSC];
    uint triangleOffset = triangleIndexOffset[bSTART_tri + id.x];
    uint offset = scOffset + triangleOffset; 

    filteredGeometry[bSTART_sort + offset] = sourceTri;
}