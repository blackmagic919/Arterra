#include "Assets/Resources/Compute/MemoryStructures/Heap/HeapOperations.hlsl"
#pragma kernel CSMain
#pragma multi_compile _ DIRECT_DEALLOCATE
#pragma multi_compile _ TRACKING

#ifdef DIRECT_DEALLOCATE
StructuredBuffer<uint> _AddressDict;
uint countOffset;
#else
StructuredBuffer<uint2> _AddressDict;
uint addressIndex;
#endif

#ifdef TRACKING
RWStructuredBuffer<uint2> _Occupancy;
uint buffIndex;
#endif

//Time complexity O(3log n) -> O(log n) for release
[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
#ifdef DIRECT_DEALLOCATE
    uint blockAddress = _AddressDict[countOffset];
#else
    uint blockAddress = _AddressDict[addressIndex].x;
#endif
    if(blockAddress == 0) //Not allocated
        return;

    uint startIndex = blockAddress;
    uint endIndex = blockAddress + _SourceMemory[blockAddress-1];
#ifdef TRACKING
    _Occupancy[buffIndex].x -= (endIndex - startIndex) + InitBlockSize;
    _Occupancy[buffIndex].y--;
#endif

    //We merge blocks to keep memory from fragmenting
    //Because we merge all empty adjacent blocks upon deallocation
    //it is impossible for two empty blocks to be adjacent to each other
    uint pBlockAddress = PrevBlockIndex(blockAddress);
    uint nBlockAddress = NextBlockIndex(blockAddress);

    if(pBlockAddress != 0){
        startIndex = pBlockAddress;
        RemoveBlock(_SourceMemory[pBlockAddress-2], 0);
    } 

    if(nBlockAddress != 0){
        endIndex = nBlockAddress + _SourceMemory[nBlockAddress-1];
        RemoveBlock(_SourceMemory[nBlockAddress-2], 0);
    }

    uint HeapEndIndex = ++_Heap[0].x;
    uint newBlockSize = endIndex - startIndex;
    //Init Heap Block
    _Heap[HeapEndIndex] = uint2(startIndex, newBlockSize);
    //Init Memory LL-Block
    _SourceMemory[startIndex-2] = HeapEndIndex;
    _SourceMemory[startIndex-1] = newBlockSize;
    _SourceMemory[startIndex + newBlockSize] = newBlockSize;
    
    SwimBlock(HeapEndIndex, 0);
}
