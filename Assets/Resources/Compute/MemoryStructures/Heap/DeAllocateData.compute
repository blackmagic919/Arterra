// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma multi_compile _ DIRECT_DEALLOCATE
#include "Assets/Resources/Compute/MemoryStructures/Heap/LLRBOps.hlsl"

const static uint InitBlockSize = 3;


#ifdef DIRECT_DEALLOCATE
StructuredBuffer<uint> _Address;
uint countOffset;
#else
StructuredBuffer<uint2> _AddressDict;
uint addressIndex;
#endif


uint PrevBlockIndex(uint blockIndex){
    uint ret = 0;

    if(blockIndex > 2){ //Not Head of LinkedList

        uint pBlockEnd = blockIndex - InitBlockSize;
        uint pBlockSize = _SourceMemory[pBlockEnd];
        uint pBlockIndex = pBlockEnd - pBlockSize;

        uint pBlockHeapIndex = _SourceMemory[pBlockIndex - 2];

        if(pBlockHeapIndex != 0) //Is not allocated 
            ret = pBlockIndex;
    }
    return ret;
}

uint NextBlockIndex(uint blockIndex){
    uint ret = 0;

    //It's not possible for an allocated block to be the tail of the LL
    uint nBlockIndex = blockIndex + _SourceMemory[blockIndex-1] + InitBlockSize;
    uint nBlockHeapIndex = _SourceMemory[nBlockIndex - 2];

    if(nBlockHeapIndex != 0) //Is not allocated
        ret = nBlockIndex;

    return ret;
}

//Time complexity O(3log n) -> O(log n) for release
[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
#ifdef DIRECT_DEALLOCATE
    uint blockAddress = _Address[countOffset];
#else
    uint blockAddress = _AddressDict[addressIndex].x;
#endif
    if(blockAddress == 0) //Not allocated
        return;

    uint startIndex = blockAddress;
    uint endIndex = blockAddress + _SourceMemory[blockAddress-1];

    uint pBlockAddress = PrevBlockIndex(blockAddress);
    uint nBlockAddress = NextBlockIndex(blockAddress);

    if(pBlockAddress != 0) {
        startIndex = pBlockAddress;
        pBlockAddress = _SourceMemory[pBlockAddress - 2];
    } if(nBlockAddress != 0) endIndex = nBlockAddress + _SourceMemory[nBlockAddress-1];
 
    uint newBlockSize = endIndex - startIndex;
    //Init Memory LL-Block
    _SourceMemory[startIndex-2] = _Heap[0].x + 1;
    _SourceMemory[startIndex-1] = newBlockSize;
    _SourceMemory[startIndex + newBlockSize] = newBlockSize;
    
    AddBlock(startIndex);

    //We merge blocks to keep memory from fragmenting
    //Because we merge all empty adjacent blocks upon deallocation
    //it is impossible for two empty blocks to be adjacent to each other
    if(pBlockAddress != 0) RemoveBlock(pBlockAddress);
    //It is possible the next block's heap ptr has been changed by the previous remove
    if(nBlockAddress != 0) RemoveBlock(_SourceMemory[nBlockAddress - 2]);
}
