#pragma kernel CSMain
#pragma multi_compile _ DIRECT_ALLOCATE
#include "Assets/Resources/Compute/MemoryStructures/Heap/LLRBOps.hlsl"

const static uint InitBlockSize = 3;

RWStructuredBuffer<uint2> _AddressDict;
uint addressIndex;

//OUTPUT
#ifdef DIRECT_ALLOCATE
uint allocCount;
uint allocStride;

#else
StructuredBuffer<uint> allocCount;
uint allocStride;
uint countOffset;
#endif

//Time Complexity: O(log n)
[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint count; uint stride;
#ifdef DIRECT_ALLOCATE
    count = allocCount;
    stride = allocStride;
#else
    count = allocCount[countOffset];
    stride = allocStride;
#endif
    uint allocSize = (count + 1) * stride; //Add 1 to make space for padding

    //Don't allocate 0 size blocks
    uint rNode = FindSmallestBlock(allocSize + InitBlockSize);;
    if(count == 0 || rNode == 0){
        _AddressDict[addressIndex] = uint2(0, 0); //INDICATE NOT ALLOCATED
        return; 
    }

    uint rAddress = _Heap[rNode].x; uint rBlockSize = _SourceMemory[rAddress-1];
    uint padding = (stride - (rAddress % stride)) % stride; //we mod again so there is no padding if rAddress is a multiple of stride


    _AddressDict[addressIndex] = uint2(rAddress, (rAddress + padding)/stride);

    //Create new empty block
    uint address = rAddress + (allocSize + InitBlockSize);
    uint blockSize = rBlockSize - (allocSize + InitBlockSize);

    _SourceMemory[address-2] = _Heap[0].x+1;
    _SourceMemory[address-1] = blockSize;
    _SourceMemory[address + blockSize] = blockSize;

    //Always add before remove
    //The system cannot handle 0 blocks ever
    AddBlock(address);
    RemoveBlock(rNode);

    //Set Alloc Block's Info
    _SourceMemory[rAddress - 2] = 0; //0 bit pattern means ISALLOCATED
    _SourceMemory[rAddress - 1] = allocSize;
    _SourceMemory[rAddress + allocSize] = allocSize;
}
