#include "Assets/Resources/Compute/MemoryStructures/Heap/HeapOperations.hlsl"
#pragma kernel CSMain
#pragma multi_compile _ DIRECT_ALLOCATE
#pragma multi_compile _ TRACKING

RWStructuredBuffer<uint2> _AddressDict;
uint addressIndex;

//OUTPUT
#ifdef DIRECT_ALLOCATE
uint allocCount;
uint allocStride;

#else
StructuredBuffer<uint> allocCount;
uint allocStride;
uint countOffset;
#endif

#ifdef TRACKING
RWStructuredBuffer<uint2> _Occupancy;
uint buffIndex;
#endif


//Time Complexity: O(log n)
[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint count; uint stride;
#ifdef DIRECT_ALLOCATE
    count = allocCount;
    stride = allocStride;
#else
    count = allocCount[countOffset];
    stride = allocStride;
#endif
    uint allocSize = (count + 1) * stride; //Add 1 to make space for padding
    uint totalSize = allocSize + InitBlockSize;

    //Don't allocate 0 size blocks
    if(count == 0 || totalSize > _Heap[1].y){
        _AddressDict[addressIndex] = uint2(0, 0); //INDICATE NOT ALLOCATED
        return; 
    }
//
#ifdef TRACKING
    _Occupancy[buffIndex].x += totalSize;
    _Occupancy[buffIndex].y++;
#endif
    uint rNode = FindSmallestBlock(totalSize, 0);
    uint2 root = _Heap[rNode]; uint rAddress = root.x; uint rBlockSize = root.y;
    uint padding = (stride - (rAddress % stride)) % stride; //we mod again so there is no padding if rAddress is a multiple of stride


    _AddressDict[addressIndex] = uint2(rAddress, (rAddress + padding)/stride);

    //Set Alloc Block's Info
    _SourceMemory[rAddress - 2] = 0; //0 bit pattern means ISALLOCATED
    _SourceMemory[rAddress - 1] = allocSize;
    _SourceMemory[rAddress + allocSize] = allocSize;

    //Create new empty block
    uint address = rAddress + (totalSize);
    uint blockSize = rBlockSize - (totalSize);

    _Heap[rNode] = uint2(address, blockSize);
    _SourceMemory[address-2] = rNode;
    _SourceMemory[address-1] = blockSize;
    _SourceMemory[address + blockSize] = blockSize;

    SinkBlock(rNode, 0);
}
