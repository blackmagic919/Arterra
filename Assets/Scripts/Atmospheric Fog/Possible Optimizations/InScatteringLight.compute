// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Bake
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float3> inScattering;
RWTexture2D<float3> rayDirs;
RWTexture2D<float2> rayLengths;

const static uint numThreads = 8;
uint screenHeight;
uint screenWidth;

float3 _LightDirection; //Global Variable

float3 _ScatteringCoeffs; //In order RGB
float3 _SensitivityAtten;
float3 _PlanetCenter;
float _PlanetRadius;
float _AtmosphereRadius;
float _DensityFalloff;
uint _NumInScatterPoints;
uint _NumOpticalDepthPoints;
uint depth;

float2 raySphere(float3 s0, float sr, float3 r0, float3 rd) {
    float a = dot(rd, rd);
    float3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sr * sr);
	float disc = b * b - 4.0 * a* c;
                    
    if (disc < 0.0) {
        return float2(-1.0, -1.0);
    }else{
        float t1 = max((-b - sqrt(disc)) / (2.0 * a), 0);
        float t2 = max((-b + sqrt(disc)) / (2.0 * a), 0);
        return float2(t1, t2-t1);
	}
}

float densityAtPoint(float3 samplePoint){
    float heightAboveSurface = length(samplePoint - _PlanetCenter) - _PlanetRadius;
    float height01 = heightAboveSurface / (_AtmosphereRadius - _PlanetRadius);
    float localDensity = exp(-height01 * _DensityFalloff) * (1-height01);
    return localDensity;
}

float opticalDepth(float3 rayOrigin, float3 rayDir, float rayLength){
    float3 densitySamplePoint = rayOrigin;
    float stepSize = rayLength / (_NumOpticalDepthPoints - 1);
    float opticalDepth = 0;

    for(uint i = 0; i < _NumOpticalDepthPoints; i++){
        float localDensity = densityAtPoint(densitySamplePoint);
        opticalDepth += localDensity * stepSize;
        densitySamplePoint += rayDir * stepSize;
    }

    return opticalDepth;
}


float calculateOcclusionFactor(float3 rayOrigin, float3 rayDir, float rayLength){
    half cascadeIndex = ComputeCascadeIndex(rayOrigin);
    float stepSize = pow(2, cascadeIndex);
    int NumShadowPoints = max(1, rayLength / stepSize);

    float3 shadowPoint = rayOrigin;
    float transmittanceCount = 0;

    for(int i = 0; i < NumShadowPoints; i++){

        if(MainLightRealtimeShadow(TransformWorldToShadowCoord(shadowPoint)))
            transmittanceCount++;

        shadowPoint += rayDir * stepSize;
    }
    return (transmittanceCount / NumShadowPoints);
}

[numthreads(numThreads,numThreads,1)]
void Bake (uint3 id : SV_DispatchThreadID)
{
    uint viewX = id.x;
    uint viewY = id.y;

    if(viewX > screenWidth || viewY > screenHeight || depth >= _NumInScatterPoints)
        return;

    float3 rayDir = rayDirs[id.xy] - float3(1, 1, 1);
    float2 lengths = rayLengths[id.xy];
    float rayLength = lengths.y;
    
    float3 rayOrigin = _WorldSpaceCameraPos + rayDir * lengths.x;

    float stepSize = rayLength / (_NumInScatterPoints - 1);
    float3 inScatterPoint = rayOrigin + rayDir * stepSize * depth;

    float occlusionFactor = 1;//calculateOcclusionFactor(inScatterPoint, rayDir, stepSize); //MainLightRealtimeShadow(TransformWorldToShadowCoord(inScatterPoint));
    float sunRayLength = raySphere(_PlanetCenter, _AtmosphereRadius, inScatterPoint, _LightDirection).y;    
    float sunOpticalDepth = opticalDepth(inScatterPoint, _LightDirection, sunRayLength);// Represented by PPc in paper 
    float cameraOpticalDepth = opticalDepth(inScatterPoint, -rayDir, stepSize * depth);// Represented by PPa in paper
    float3 transmittance = exp((-(sunOpticalDepth + cameraOpticalDepth)) * _ScatteringCoeffs); // exp(-t(PPc, lambda)-t(PPa, lambda))
    float pointDensity = densityAtPoint(inScatterPoint);

    inScattering[id.xy] += pointDensity * transmittance * occlusionFactor * stepSize * _ScatteringCoeffs * _SensitivityAtten;
}
