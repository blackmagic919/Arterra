// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

struct SourceVertex{
    float3 positionOS;
    float3 normalOS;
};

StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceTriangles;

struct DrawVertex{
    float3 positionWS;
    float3 normalWS;
    float2 uv;
};

struct DrawTriangle{
    DrawVertex vertices[3];
};

struct Quad {
    float3 topLeft;
    float3 topRight;
    float3 bottomLeft;
    float3 bottomRight;
};

AppendStructuredBuffer<DrawTriangle> _DrawTriangles;

int _NumSourceTriangles;
float _QuadSize;
float _InflationFactor;
float4x4 _LocalToWorld;

float3 randomVector;

DrawVertex MakeBaseDrawVertex(SourceVertex v){
    DrawVertex o = (DrawVertex)0;
    o.positionWS = mul(_LocalToWorld, float4(v.positionOS, 1)).xyz;
    o.normalWS = mul(_LocalToWorld, float4(v.normalOS, 0)).xyz;
    //uv is thrown away and rebuilt for every quad
    return o;
}


DrawVertex InitializeDrawVertex(float3 positionWS, float3 normalWS, float2 uv){
    DrawVertex o = (DrawVertex)0;
    o.positionWS = positionWS;
    o.normalWS = normalWS;
    o.uv = uv;

    return o;
}


float3 GetTriangleCenter(float3 a, float3 b, float3 c) {
    return (a + b + c) / 3.0;
}

float3 random(float3 st)
{
    st = float3(dot(st, float3(127.1, 311.7, 531.5)),
                dot(st, float3(269.5, 183.3, 246.1)),
                dot(st, float3(419.2, 371.9, 619.8)));
    return -1.0 + 2.0 * frac(sin(st) * 43758.5453123);
}

Quad GetQuad(float3 center, float3 normal){
    float3 randomAngles = random(normal*normal);

    // Create the right and up vectors orthogonal to the new normal vector.
    float3 right = normalize(cross(normal, float3(randomAngles.x, randomAngles.y, randomAngles.z)));
    float3 up = cross(right, normal);

    Quad quad = (Quad)0;
    quad.topLeft = center - right * (_QuadSize / 2.0) + up * (_QuadSize / 2.0);
    quad.topRight = center + right * (_QuadSize / 2.0) + up * (_QuadSize / 2.0);
    quad.bottomLeft = center - right * (_QuadSize / 2.0) - up * (_QuadSize / 2.0);
    quad.bottomRight = center + right * (_QuadSize / 2.0) - up * (_QuadSize / 2.0);

    return quad;
}

void AppendQuad(Quad quad, float3 normalWS){
    //Bottom triangle
    DrawTriangle lowerTri = (DrawTriangle)0;
    lowerTri.vertices[0] = InitializeDrawVertex(quad.topLeft + _InflationFactor*normalWS, normalWS, float2(0, 1));
    lowerTri.vertices[2] = InitializeDrawVertex(quad.bottomLeft + _InflationFactor*normalWS, normalWS, float2(0, 0));
    lowerTri.vertices[1] = InitializeDrawVertex(quad.bottomRight + _InflationFactor*normalWS, normalWS, float2(1, 0)); //Add this first because clockwise winding
    _DrawTriangles.Append(lowerTri);
    
    //Top triangle
    DrawTriangle topTri = (DrawTriangle)0;
    topTri.vertices[0] = InitializeDrawVertex(quad.topLeft + _InflationFactor*normalWS, normalWS, float2(0, 1));
    topTri.vertices[2] = InitializeDrawVertex(quad.bottomRight + _InflationFactor*normalWS, normalWS, float2(1, 0));
    topTri.vertices[1] = InitializeDrawVertex(quad.topRight + _InflationFactor*normalWS, normalWS, float2(1, 1));
    _DrawTriangles.Append(topTri);
}

void CreateQuadIntersects(float3 center, float3 normalWS) {

    float3 randomAngle = random(center);

    float3 forward = normalize(normalWS);
    float3 right = normalize(cross(forward, random(randomAngle)));
    float3 up = cross(forward, right);

    AppendQuad(GetQuad(center, forward), normalWS);
    AppendQuad(GetQuad(center, right), normalWS);
    AppendQuad(GetQuad(center, up), normalWS);
}

[numthreads(128,1,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    if((int)id.x >= _NumSourceTriangles)
        return;

    int triStart = id.x * 3;
    DrawVertex inputs[3];

    [unroll] for(int i = 0; i < 3; i++){
        inputs[i] = MakeBaseDrawVertex(_SourceVertices[_SourceTriangles[triStart+i]]);
    }

    float3 center = GetTriangleCenter(inputs[0].positionWS, inputs[1].positionWS, inputs[2].positionWS);
    float3 normalWS = GetTriangleCenter(inputs[0].normalWS, inputs[1].normalWS, inputs[2].normalWS);// If not want to inherit -> normalize(_CameraPosition - center);
    CreateQuadIntersects(center, normalWS);
  
}
