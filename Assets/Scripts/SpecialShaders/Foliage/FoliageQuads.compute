// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

const static int numThreads = 256;

struct Quad {
    float3 topLeft;
    float3 topRight;
    float3 bottomLeft;
    float3 bottomRight;
};

struct SourceVertex{
    float3 positionOS;
    float3 normalOS;
    int2 material; 
};

struct DrawVertex{
    float3 positionWS;
    float3 normalWS;
    float2 uv;
};

struct DrawTriangle{
    DrawVertex vertices[3];
};

StructuredBuffer<SourceVertex> SourceVertices;
StructuredBuffer<uint3> SourceTriangles;
StructuredBuffer<uint2> _AddressDict;
uint vertAddress;
uint triAddress;

RWStructuredBuffer<uint> counters;
StructuredBuffer<uint> BaseTriangles;
RWStructuredBuffer<DrawTriangle> DrawTriangles;
int bSTART_base;
int bCOUNT_base;
int bSTART_oGeo;
int bCOUNT_oGeo;

float _QuadSize;
float _InflationFactor;
float4x4 _LocalToWorld;

DrawVertex MakeBaseDrawVertex(SourceVertex v){
    DrawVertex o = (DrawVertex)0;
    o.positionWS = mul(_LocalToWorld, float4(v.positionOS, 1)).xyz;
    o.normalWS = mul(_LocalToWorld, float4(v.normalOS, 0)).xyz;

    return o;
}


DrawVertex InitializeDrawVertex(float3 positionWS, float3 normalWS, float2 uv){
    DrawVertex o = (DrawVertex)0;
    o.positionWS = positionWS;
    o.normalWS = normalWS;
    o.uv = uv;

    return o;
}


float3 GetTriangleCenter(float3 a, float3 b, float3 c) {
    return (a + b + c) / 3.0;
}

float3 random(float3 st)
{
    st = float3(dot(st, float3(127.1, 311.7, 531.5)),
                dot(st, float3(269.5, 183.3, 246.1)),
                dot(st, float3(419.2, 371.9, 619.8)));
    return -1.0 + 2.0 * frac(sin(st) * 43758.5453123);
}

Quad GetQuad(float3 center, float3 normal){
    float3 randomAngles = random(normal*normal);

    // Create the right and up vectors orthogonal to the new normal vector.
    float3 right = normalize(cross(normal, float3(randomAngles.x, randomAngles.y, randomAngles.z)));
    float3 up = cross(right, normal);

    Quad quad = (Quad)0;
    quad.topLeft = center - right * (_QuadSize / 2.0) + up * (_QuadSize / 2.0);
    quad.topRight = center + right * (_QuadSize / 2.0) + up * (_QuadSize / 2.0);
    quad.bottomLeft = center - right * (_QuadSize / 2.0) - up * (_QuadSize / 2.0);
    quad.bottomRight = center + right * (_QuadSize / 2.0) - up * (_QuadSize / 2.0);

    return quad;
}

void AppendTri(DrawTriangle tri){
    int appendInd = 0;
    InterlockedAdd(counters[bCOUNT_oGeo], 1, appendInd);
    DrawTriangles[bSTART_oGeo + appendInd] = tri;
}

void AppendQuad(Quad quad, float3 normalWS){
    //Bottom triangle
    DrawTriangle lowerTri = (DrawTriangle)0;
    lowerTri.vertices[0] = InitializeDrawVertex(quad.topLeft + _InflationFactor*normalWS, normalWS, float2(0, 1));
    lowerTri.vertices[2] = InitializeDrawVertex(quad.bottomLeft + _InflationFactor*normalWS, normalWS, float2(0, 0));
    lowerTri.vertices[1] = InitializeDrawVertex(quad.bottomRight + _InflationFactor*normalWS, normalWS, float2(1, 0)); //Add this first because clockwise winding
    AppendTri(lowerTri);
    
    //Top triangle
    DrawTriangle topTri = (DrawTriangle)0;
    topTri.vertices[0] = InitializeDrawVertex(quad.topLeft + _InflationFactor*normalWS, normalWS, float2(0, 1));
    topTri.vertices[2] = InitializeDrawVertex(quad.bottomRight + _InflationFactor*normalWS, normalWS, float2(1, 0));
    topTri.vertices[1] = InitializeDrawVertex(quad.topRight + _InflationFactor*normalWS, normalWS, float2(1, 1));
    AppendTri(topTri);
}

void CreateQuadIntersects(float3 center, float3 normalWS) {

    float3 randomAngle = random(center);

    float3 forward = normalize(normalWS);
    float3 right = normalize(cross(forward, random(randomAngle)));
    float3 up = cross(forward, right);

    AppendQuad(GetQuad(center, forward), normalWS);
    AppendQuad(GetQuad(center, right), normalWS);
    AppendQuad(GetQuad(center, up), normalWS);
}

[numthreads(numThreads,1,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    uint startIndex = counters[bCOUNT_base];
    uint numSourceTriangles = counters[bCOUNT_base+1] - startIndex;
    if(id.x >= numSourceTriangles)
        return;

    uint triIndex = BaseTriangles[bSTART_base + startIndex + id.x];
    uint3 sourceTri = SourceTriangles[_AddressDict[triAddress].y + triIndex];

    DrawVertex inputs[3];
    inputs[0] = MakeBaseDrawVertex(SourceVertices[_AddressDict[vertAddress].y + sourceTri.x]);
    inputs[1] = MakeBaseDrawVertex(SourceVertices[_AddressDict[vertAddress].y + sourceTri.y]);
    inputs[2] = MakeBaseDrawVertex(SourceVertices[_AddressDict[vertAddress].y + sourceTri.z]);

    float3 center = GetTriangleCenter(inputs[0].positionWS, inputs[1].positionWS, inputs[2].positionWS);
    float3 normal = GetTriangleCenter(inputs[0].normalWS, inputs[1].normalWS, inputs[2].normalWS);// If not want to inherit -> normalize(_CameraPosition - center);
    CreateQuadIntersects(center, normal);
  
}
