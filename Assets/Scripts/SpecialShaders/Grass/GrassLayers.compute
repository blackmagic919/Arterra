// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

const static int numThreads = 256;

struct SourceVertex{
    float3 positionOS;
    float3 normalOS;
    int2 id;
    int material; 
};

struct SourceTriangle { //Constructor
    SourceVertex points[3];
};

struct DrawVertex{
    float3 positionWS;
    float3 normalWS;
    float2 uv;
    float4 color; //4 channels for 
};

struct DrawTriangle{
    DrawVertex vertices[3];
};

StructuredBuffer<SourceTriangle> _SourceTriangles;
StructuredBuffer<uint> _SourceStartIndices;
int _ShaderIndex;

AppendStructuredBuffer<DrawTriangle> _DrawTriangles;


float _TotalHeight;
int _MaxLayers;
float _WorldPositionToUVScale;
float4x4 _LocalToWorld;

float2 mapCoordinates(float3 worldPos)
{
    float2 projXY = worldPos.xy;
    float2 projXZ = worldPos.xz;
    float2 projYZ = worldPos.yz;

    float2 worldUV = (projXY + projXZ + projYZ) / 3;

    return worldUV;
}

//Experimented a lot with this
/*
    Conventional triplanar:
    float3 blendAxes = abs(worldNormal);
    blendAxes /= blendAxes.x + blendAxes.y + blendAxes.z;

    float2 projXY = worldPos.xy * blendAxes.z;
    float2 projXZ = worldPos.xz * blendAxes.y;
    float2 projYZ = worldPos.yz * blendAxes.x;

    return (projXY+projXZ+projYZ);

    As length(xyz) increases, the coordinates change more as normals change
*/

DrawVertex MakeBaseDrawVertex(SourceVertex v){
    DrawVertex o;

    o.normalWS = mul(_LocalToWorld, float4(v.normalOS, 0)).xyz;
    o.positionWS = mul(_LocalToWorld, float4(v.positionOS, 1)).xyz;
    o.uv = mapCoordinates(o.positionWS) * _WorldPositionToUVScale;
    o.color = float4(0, 0, 0, 0);

    return o;
}

DrawVertex ExtrudeVertex(DrawVertex v, float height){
    DrawVertex o;
    o.positionWS = v.positionWS + v.normalWS * (height * _TotalHeight);
    o.normalWS = v.normalWS;

    o.uv = v.uv;
    o.color = v.color;

    return o;
}

[numthreads(numThreads, 1, 1)]
void Main(uint3 id : SV_DispatchThreadID){

    uint startIndex = _SourceStartIndices[_ShaderIndex];
    uint numSourceTriangles = _SourceStartIndices[_ShaderIndex+1] - startIndex;
    if(id.x >= numSourceTriangles)
        return;

    uint triIndex = startIndex + id.x;

    DrawVertex inputs[3];

    [unroll] for(int i = 0; i < 3; i++){
        inputs[i] = MakeBaseDrawVertex(_SourceTriangles[triIndex].points[i]);
    }

    for(i = 0; i < _MaxLayers; i++)
    {
        float texHeight = (float) i / _MaxLayers;

        float colorHeight = (float)(i) / (_MaxLayers - 1.0); // Use (float)(colorOffset + i) / (_MaxLayers - 1.0); if topColor priority

        DrawTriangle tri = (DrawTriangle)0;
        [unroll] for(int p = 0; p < 3; p++){
            tri.vertices[p] = ExtrudeVertex(inputs[p], texHeight);
            tri.vertices[p].color = float4(texHeight, colorHeight, 0, 0); 
        }

        _DrawTriangles.Append(tri);
    }
}