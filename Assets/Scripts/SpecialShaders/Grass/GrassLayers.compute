// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

const static int numThreads = 256;


struct SourceVertex{
    float3 positionOS;
    float3 normalOS;
    int2 material; 
};


struct DrawVertex{
    float3 positionWS;
    float3 normalWS;
    float2 uv;
};

struct DrawTriangle{
    DrawVertex vertices[3];
};


StructuredBuffer<SourceVertex> SourceVertices;
StructuredBuffer<uint3> SourceTriangles;
StructuredBuffer<uint2> _AddressDict;
uint vertAddress;
uint triAddress;

RWStructuredBuffer<uint> counters;
StructuredBuffer<uint> BaseTriangles;
RWStructuredBuffer<DrawTriangle> DrawTriangles;
int bSTART_base;
int bCOUNT_base;
int bSTART_oGeo;
int bCOUNT_oGeo;

float _TotalHeight;
int _MaxLayers;
float _WorldPositionToUVScale;
float4x4 _LocalToWorld;

float2 mapCoordinates(float3 worldPos)
{
    float2 projXY = worldPos.xy;
    float2 projXZ = worldPos.xz;
    float2 projYZ = worldPos.yz;

    float2 worldUV = (projXY + projXZ + projYZ) / 3;

    return worldUV;
}

//Experimented a lot with this
/*
    Conventional triplanar:
    float3 blendAxes = abs(worldNormal);
    blendAxes /= blendAxes.x + blendAxes.y + blendAxes.z;

    float2 projXY = worldPos.xy * blendAxes.z;
    float2 projXZ = worldPos.xz * blendAxes.y;
    float2 projYZ = worldPos.yz * blendAxes.x;

    return (projXY+projXZ+projYZ);

    As length(xyz) increases, the coordinates change more as normals change
*/

DrawVertex MakeBaseDrawVertex(SourceVertex v){
    DrawVertex o;

    o.normalWS = mul(_LocalToWorld, float4(v.normalOS, 0)).xyz;
    o.positionWS = mul(_LocalToWorld, float4(v.positionOS, 1)).xyz;
    o.uv = float2(0, 0);

    return o;
}

DrawVertex ExtrudeVertex(DrawVertex v, float height){
    DrawVertex o;
    o.positionWS = v.positionWS + v.normalWS * (height * _TotalHeight);
    o.normalWS = v.normalWS;

    o.uv = v.uv;
    return o;
}

[numthreads(numThreads, 1, 1)]
void Main(uint3 id : SV_DispatchThreadID){

    uint startIndex = counters[bCOUNT_base];
    uint numSourceTriangles = counters[bCOUNT_base+1] - startIndex;
    if(id.x >= numSourceTriangles)
        return;

    uint triIndex = BaseTriangles[bSTART_base + startIndex + id.x];
    uint3 sourceTri = SourceTriangles[_AddressDict[triAddress].y + triIndex];

    DrawVertex inputs[3];
    inputs[0] = MakeBaseDrawVertex(SourceVertices[_AddressDict[vertAddress].y + sourceTri.x]);
    inputs[1] = MakeBaseDrawVertex(SourceVertices[_AddressDict[vertAddress].y + sourceTri.y]);
    inputs[2] = MakeBaseDrawVertex(SourceVertices[_AddressDict[vertAddress].y + sourceTri.z]);
    

    for(int i = 0; i < _MaxLayers; i++)
    {
        float texHeight = (float) i / _MaxLayers;
        float colorHeight = (float)(i) / (_MaxLayers - 1.0); // Use (float)(colorOffset + i) / (_MaxLayers - 1.0); if topColor priority

        DrawTriangle tri = (DrawTriangle)0;
        [unroll] for(int p = 0; p < 3; p++){
            tri.vertices[p] = ExtrudeVertex(inputs[p], texHeight);
            tri.vertices[p].uv = float2(texHeight, colorHeight); 
        }

        int appendInd = 0;
        InterlockedAdd(counters[bCOUNT_oGeo], 1, appendInd);
        DrawTriangles[bSTART_oGeo + appendInd] = tri;
    }
}