using UnityEngine;
using Newtonsoft.Json;
using Arterra.Configuration;

namespace Arterra.Data.Generation{
/// <summary>
/// Identifies information used in generating the surface of a chunk. 
/// Locates the noise samplers responsible for creating different aspects of the surface. 
/// The surface is a seperate 2D map generated and cached by every chunk that is necessary
/// to proceed with the rest terrain generation. Resultantly, all noise maps referenced
/// are sampled in a 2D space where the vertical dimension is ignored.
/// <seealso href="https://blackmagic919.github.io/AboutMe/2024/08/01/Base-Generation/"/>
/// </summary>
[CreateAssetMenu(menuName = "Containers/Surface Settings")]
public class Surface : ScriptableObject{
    /// <summary>
    /// The offset in grid space of the surface from the world origin of the grid. This offset is added
    /// to the final terrain height to shift it relative to the grid origin. Because the surface extends
    /// from a grid space height of 0 to <see cref="MaxTerrainHeight"/>, one may desire to shift the surface
    /// to be centered around 0 by setting this value to <see cref="MaxTerrainHeight"/>/2.
    /// </summary>
    public float terrainOffset = 0;

    /// <summary>
    /// The maximum height of the terrain generated by the surface in grid space. Increasing maxTerrainHeight
    /// will stretch the surface vertically. The actual height of the surface is calculated by the <see cref="ContinentalNoise"/>,
    /// <see cref="MajorWarpNoise"/>, <see cref="MinorWarpNoise"/>, and <see cref="ErosionNoise"/> samplers whereby <see cref="MaxTerrainHeight"/> scales this final height
    /// </summary> 
    public float MaxTerrainHeight;
    /// <summary>
    /// The maximum height below the surface where the density falloff begins. At the surface, the density is multiplied
    /// by <see cref="Config.Quality.Terrain.IsoLevel"/> ensuring that it cannot be underground. As the height approaches
    /// <see cref="MaxSquashHeight"/>, this multiplier approaches 1 restoring the original density. A lower height will result
    /// in a flatter surface with less overhangs while a higher height will result in a more shattered surface. The actual squash
    /// height is determined by the <see cref="SquashNoise"/> sampler whereby <see cref="MaxSquashHeight"/> scales this height.
    /// </summary>
    public float MaxSquashHeight;
    /// <summary>
    /// The total length in grid space of the range around the surface where <see cref="Biome.SurfaceBiome">Surface Biomes</see> take
    /// over biome-related generation from <see cref="Biome.CaveBiome">Cave Biomes</see> which control generation across all other
    /// space. The actual height and offset of the range is determined by the <see cref="InfHeightNoise"/> and <see cref="InfOffsetNoise"/>
    /// whereby MaxInfluenceHeight scales this range.
    /// </summary>
    public float MaxInfluenceHeight;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the continental noise
    /// map, or the coarse terrain height for large-scale features. </summary>
    [UISetting(Message = "Surface Generation")]
    public string ContinentalNoise;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the erosion noise
    /// map which blends the amplitude of different octaves within the <see cref="ContinentalNoise"/> heightmap. More specifically,
    /// erosion controls the influence of PVNoise being added to the continental noise and does not scale ContentinalNoise in any way.
    /// </summary>
    public string ErosionNoise;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the Major Domain Warp 
    /// noise map, or specifically the primary noise map which distorts the domain at which the terrain height noise maps are sampled. </summary>
    public string MajorWarpNoise;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the Minor Domain Warp 
    /// noise map, or specifically the secondary noise map which distorts the domain at which the terrain height noise maps are sampled. </summary>
    public string MinorWarpNoise;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the squash noise map.
    /// The squash noise map dictates, for each 2D surface coordinate, the distance below the surface where the density falloff
    /// begins. <seealso cref="MaxSquashHeight"/>.
    /// </summary>
    public string SquashNoise;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the influence height noise map.
    /// The influence height noise map dictates, for each 2D surface coordinate, total length in grid space of the range around the surface
    /// where <see cref="Biome.SurfaceBiome">Surface Biomes</see> takes over biome-related generation.
    /// </summary>
    [UISetting(Message = "Surface Control")]
    public string InfHeightNoise;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the influence offset noise map.
    /// The range determined by <see cref="InfHeightNoise"/> is shifted by the influence offset noise map where an offset of 0 places the range
    /// completely above the surface, an offset of 1 places the range completely below the surface, and an offset of 0.5 places the range 
    /// such that it is bisected by the surface.
    /// </summary>
    public string InfOffsetNoise;
    /// <summary>
    /// The name of the noise sampler in the <see cref="Config.GenerationSettings.Noise">Noise</see> registry that generates the atmosphere noise map.
    /// The atmophere noise describes how fast the atmosphere falls off as the height above the surface increases. This is physically done
    /// by reducing the density of the map as the height approaches infinity. <seealso cref="Generation.Map.heightFalloff"/>.
    /// </summary>
    public string AtmosphereNoise;
    
    /// <summary> The index of the noise function described by <see cref="ContinentalNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int ContinentalIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(ContinentalNoise);
    /// <summary> The index of the noise function described by <see cref="ErosionNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int ErosionIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(ErosionNoise);
    /// <summary> The index of the noise function described by <see cref="MajorWarpNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int MajorWarpIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(MajorWarpNoise);
    /// <summary> The index of the noise function described by <see cref="MinorWarpNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int MinorWarpIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(MinorWarpNoise);
    /// <summary> The index of the noise function described by <see cref="SquashNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int SquashIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(SquashNoise);
    /// <summary> The index of the noise function described by <see cref="InfHeightNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int InfHeightIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(InfHeightNoise);
    /// <summary> The index of the noise function described by <see cref="InfOffsetNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int InfOffsetIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(InfOffsetNoise);
    /// <summary> The index of the noise function described by <see cref="AtmosphereNoise"/> in the <see cref="Config.GenerationSettings.Noise">noise</see> registry </summary>
    [JsonIgnore]
    public int AtmosphereIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(AtmosphereNoise);
}}

/*
public ComputeBuffer SimplifyMap(int addressIndex, int sourceLOD, int destLOD, int chunkSize, bool isFloat)
{
    int sourceSkipInc = meshSkipTable[sourceLOD];
    int destSkipInc = meshSkipTable[destLOD];

    ComputeBuffer simplified = TerrainGenerator.SimplifyMap(settings.surfaceMemoryBuffer.AccessStorage(), settings.surfaceMemoryBuffer.AccessAddresses(), 
                                            addressIndex, chunkSize, sourceSkipInc, destSkipInc, isFloat, null);

    return simplified;
}*/

/*
//Small error at edges--someone fix
public T[] SimplifyMap<T>(T[] sourceMap, int sourceLOD, int destLOD, int chunkSize)
{
    int sourceSkipInc = meshSkipTable[sourceLOD];
    int sourcePointsAxes = chunkSize / sourceSkipInc + 1;

    int destSkipInc = meshSkipTable[destLOD];
    int destPointsAxes = chunkSize / destSkipInc + 1;
    int destPointCount = destPointsAxes * destPointsAxes;

    T[] destMap = new T[destPointCount];

    //Simplify Area
    for(int x = 0; x <= chunkSize; x += destSkipInc)
    {
        for (int y = 0; y <= chunkSize; y += destSkipInc)
        {
            int destIndex = CustomUtility.indexFromCoord2D(x / destSkipInc, y / destSkipInc, destPointsAxes);

            T sourceNoise = sourceMap[CustomUtility.indexFromCoord2D(x / sourceSkipInc, y / sourceSkipInc, sourcePointsAxes)];
            destMap[destIndex] = sourceNoise;
        }
    }

    return destMap;
}*/

    /*
public ComputeBuffer GenerateTerrainMaps(int chunkSize, int LOD, Vector2 offset, out ComputeBuffer continentalNoise, out ComputeBuffer erosionNoise, out ComputeBuffer PVNoise)
{
    int meshSkipInc = meshSkipTable[LOD];
    int numPointsAxes = chunkSize / meshSkipInc + 1;
    int numOfPoints = numPointsAxes * numPointsAxes;

    ComputeBuffer continentalDetail; ComputeBuffer pVDetail; ComputeBuffer erosionDetail;
    continentalNoise = GetNoiseMap(settings.TerrainContinentalDetail, offset, settings.MaxContinentalHeight, chunkSize, meshSkipInc, tempBuffers, out continentalDetail);
    PVNoise = GetNoiseMap(settings.TerrainPVDetail, offset, settings.MaxPVHeight, chunkSize, meshSkipInc, tempBuffers, out pVDetail);
    erosionNoise = GetNoiseMap(settings.TerrainErosionDetail, offset, 1, chunkSize, meshSkipInc, tempBuffers, out erosionDetail);

    tempBuffers.Enqueue(continentalDetail);
    tempBuffers.Enqueue(pVDetail);
    tempBuffers.Enqueue(erosionDetail);

    ComputeBuffer heightBuffer = CombineTerrainMaps(continentalDetail, erosionDetail, pVDetail, numOfPoints, settings.terrainOffset, tempBuffers);

    return heightBuffer;
}

public ComputeBuffer GenerateSquashMap(int chunkSize, int LOD, Vector2 offset, out ComputeBuffer squashNoise)
{
    int meshSkipInc = meshSkipTable[LOD];
    int numPointsAxes = chunkSize / meshSkipInc + 1;

    ComputeBuffer squashBuffer;
    squashNoise = GetNoiseMap(settings.SquashMapDetail, offset, settings.MaxSquashHeight, chunkSize, meshSkipInc, tempBuffers, out squashBuffer);
    tempBuffers.Enqueue(squashBuffer);

    return squashBuffer;
}

//Use interpolated values
public void GetBiomeNoises(int chunkSize, int LOD, Vector2 offset, out ComputeBuffer humidNoise)
{
    int meshSkipInc = meshSkipTable[LOD];

    GetNoiseMap(settings.HumidityDetail, offset, 1, chunkSize, meshSkipInc, tempBuffers, out humidNoise);

    tempBuffers.Enqueue(humidNoise);
}

public ComputeBuffer GetAtmosphereMap(int chunkSize, int LOD, Vector2 offset, out ComputeBuffer atmosphereNoise)
{
    int meshSkipInc = meshSkipTable[LOD];

    ComputeBuffer atmosphereBuffer;
    atmosphereNoise = GetNoiseMap(settings.AtmosphereDetail, offset, 1, chunkSize, meshSkipInc, tempBuffers, out atmosphereBuffer);
    tempBuffers.Enqueue(atmosphereBuffer);
    
    return atmosphereBuffer;
}

public ComputeBuffer ConstructBiomes(int chunkSize, int LOD, ref SurfaceChunk.NoiseMaps noiseMaps)
{
    int meshSkipInc = meshSkipTable[LOD];

    ComputeBuffer biomeMap = GetBiomeMap(chunkSize, meshSkipInc, noiseMaps, tempBuffers);
    int[] ret = new int[numOfPoints];
    biomeMap.GetData(ret);

    for(int i = 0; i < numOfPoints; i++)
    {
        float[] point = new float[6]
        {
            noiseMaps.continental[i],
            noiseMaps.erosion[i],
            noiseMaps.pvNoise[i],
            noiseMaps.squash[i],
            noiseMaps.temperature[i],
            noiseMaps.humidity[i]
        };

        ret[i] = biomeData.dictionary.Query(point);
    }
    return biomeMap;
}
*/