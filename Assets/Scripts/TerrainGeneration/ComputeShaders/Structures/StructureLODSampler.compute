
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

const static int numThreads = 8;

//You can't seperate these values into different append buffers
//because there is no way to gaurantee they're appended in same order
struct structurePoint{
    float3 position;
    uint LoD;
};

AppendStructuredBuffer<structurePoint> structures;
int maxLOD;
int3 originChunkCoord;
uint chunkSize;

//The average number of structures at minimum LoD(not collective LoD)
uint numPoints0;
float LoDFalloff;

float random(int seed)
{
    seed = (seed ^ 12345) * 6789;
    return frac((seed & 0x7FFFFFFF) * (1.0 / 2147483648.0));
}

float3 random(float3 seed)
{
    seed = float3(dot(seed, float3(127.1, 311.7, 531.5)),
                dot(seed, float3(269.5, 183.3, 246.1)),
                dot(seed, float3(419.2, 371.9, 619.8)));
    return frac(sin(seed) * 43758.5453123);
}

float3 random(int3 seed){
    return random(float3(random(seed.x), random(seed.y), random(seed.z)));
}

float random(float seed){
    float hash = frac(sin(seed) * 43758.5453);
    return frac(hash * seed);
}

[numthreads(numThreads,numThreads,numThreads)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    int maxDistance = max(max(id.x, id.y), id.z); 
    int LoD = max(0, maxDistance - 1); //This means range from max->LoD 

    if(LoD > maxLOD)
        return;

    //Obtain random seed
    int3 offsetCoord = int3(id.x, id.y, id.z); //Center coords
    int3 chunkCoord = originChunkCoord - offsetCoord;
    float3 seed3 = random(chunkCoord);
    float seed1 = random(dot(seed3, float3(1, 1, 1)));

    //I was using uint, so cLOD evalues 0 >= 0, then says cLOD--; which returns 2^32 XD
    for(int cLoD = maxLOD; cLoD >= LoD; cLoD--){ //Double loop but hey what can you do ʅ(°_°)ʃ
        uint numPoints = uint(numPoints0 * pow(abs(LoDFalloff), -cLoD) + random(seed1)); //Random to process fractional points 

        for(uint i = 0; i < numPoints; i++){
            float3 position =  (seed3 * chunkSize + float3(1, 1, 1)) - offsetCoord * chunkSize;
            //We add one here because structures cannot generate on bottom border, but can on top border

            structurePoint newStructure;
            newStructure.position = position;
            newStructure.LoD = (uint)cLoD;
            structures.Append(newStructure);

            seed3 = random(seed3);
        }

        seed1 = random(seed1); 
    }
}
