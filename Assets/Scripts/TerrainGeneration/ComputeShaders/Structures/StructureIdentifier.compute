#pragma kernel CSMain

#include "Assets/Scripts/TerrainGeneration/ComputeShaders/Includes/RotationTables.hlsl"

struct settings{ 
    int minimumLOD;

    uint randThetaRot;
    uint randPhiRot;
    int sizeX;
    int sizeY;
    int sizeZ;
};

struct density{
    int lowerLimit;
    int upperLimit;
    int center;

    float multiplier;
    float power;
};

struct structureInfo{
    float3 structurePos;
    uint structureIndex;
    uint2 rotation;
};

struct structurePoint{
    float3 position;
    uint LoD;
};

// 11 Buffers!! Lol I'm going insane
// Global references
StructuredBuffer<uint> _BiomeStructurePrefix; //Gets range of details for biome
StructuredBuffer<density> _BiomeStructureVerticalPref; //detail
StructuredBuffer<float> _BiomeStructureFrequency; //detail
StructuredBuffer<uint> _BiomeStructureIndex; //actual structure from each detail 
StructuredBuffer<settings> _StructureSettings; //settings for structure

//Input
StructuredBuffer<int> biome;
StructuredBuffer<structurePoint> structurePoints;

StructuredBuffer<uint> numPoints;
int3 originChunkCoord;
int chunkSize;


//Output
AppendStructuredBuffer<structureInfo> structurePlans;

float random(float seed){
    float hash = frac(sin(seed) * 43758.5453);
    return frac(hash * seed);
}

float3 random(float3 seed)
{
    seed = float3(dot(seed, float3(127.1, 311.7, 531.5)),
                dot(seed, float3(269.5, 183.3, 246.1)),
                dot(seed, float3(419.2, 371.9, 619.8)));
    return frac(sin(seed) * 43758.5453123);
}

float invLerp(float from, float to, float value){
  return (value - from) / (to - from);
}

float getDensity(int structIndex, float y){ //Same as in C#
    density structVertPref = _BiomeStructureVerticalPref[structIndex]; //copy
    float height = clamp(y, structVertPref.lowerLimit, structVertPref.upperLimit);
    float percent = y > structVertPref.center ?
                1-invLerp(structVertPref.center, structVertPref.upperLimit, y) :
                invLerp(structVertPref.lowerLimit, structVertPref.center, y);
    return pow(abs(percent), structVertPref.power) * structVertPref.multiplier;
}

int BinSearchStructures(uint startIndex, uint arraySize, uint searchLoD) //Returns smallest LoD structure closest to it
{
    int low = startIndex;
    int high = startIndex + (arraySize - 1);
    int ret = -1; //Not found yet

    while (low <= high)
    {
        int mid = ((uint)low + (uint)high) / 2; //so it stops complaining about int division
        uint structLoD = _StructureSettings[_BiomeStructureIndex[mid]].minimumLOD;

        if (structLoD == searchLoD)
            return mid;
        else if (structLoD < searchLoD)
        {
            ret = mid;
            low = mid + 1;
        }
        else
            high = mid - 1;
    }
    return ret;
}

int determineStructure(int pointIndex, float seed, float yPos){
    //Determine Structure
    int biomeIndex = biome[pointIndex];
    uint biomeStart = _BiomeStructurePrefix[biomeIndex];
    uint biomeLength = _BiomeStructurePrefix[biomeIndex+1] - biomeStart;
    uint pointLoD = structurePoints[pointIndex].LoD;

    int structureIndex = BinSearchStructures(biomeStart, biomeLength, pointLoD);

    //Allow frequency control(if there are multiple of same LoD)
    //Allowing to try other structures if fail allows better utilization of limited structure points
    //Because of this, each frequency isn't fixed, but multiplicative, however, it allows for more structures for less cost
    while(structureIndex >= (int)biomeStart){
        if(_BiomeStructureFrequency[structureIndex] > seed && //Frequency Condition
            getDensity(structureIndex, yPos) > random(seed)) //Height Condition
                break;
        seed = random(random(seed));
        structureIndex--;
    }

    return structureIndex;
}

const static int numThreads = 8;
[numthreads(numThreads,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //Note, operations are better if ordered from less expensive to more
    if(id.x >= numPoints[0])
        return;

    //This is what makes this function deterministic, pointCoord is same no matter which chunk samples the point
    float3 pointPosition = structurePoints[id.x].position;

    float3 pointCoord = pointPosition + (originChunkCoord - 0.5f) * chunkSize; 
    float seedStruct = random(dot(random(pointCoord), float3(456.7, 789.2, 123.4))); 
    int structureIndex = determineStructure(id.x, seedStruct, pointCoord.y);

    //No structure found
    if(structureIndex < (int)_BiomeStructurePrefix[biome[id.x]])
        return;
    settings structureSettings = _StructureSettings[_BiomeStructureIndex[structureIndex]];

    float seedRot = random(dot(random(pointCoord), float3(876.5, 234.8, 567.3))); 

    //Determine if it Intersects with current generating chunk
    float3 origin = pointPosition; //structure origin
    uint rotTheta = 0; uint rotPhi = 0;

    if(structureSettings.randThetaRot != 0)
        rotTheta = uint(seedRot * 4); //0 -> 3

    seedRot = random(seedRot);

    if(structureSettings.randPhiRot != 0)
        rotPhi = uint(seedRot * 3); //0 -> 2

    float3 sizes = float3(structureSettings.sizeX, structureSettings.sizeY, structureSettings.sizeZ);
    float xLength = abs(dot(sizes, mul(RotationLookupTable[rotTheta][rotPhi], float3(1, 0, 0))));
    float yLength = abs(dot(sizes, mul(RotationLookupTable[rotTheta][rotPhi], float3(0, 1, 0))));
    float zLength = abs(dot(sizes, mul(RotationLookupTable[rotTheta][rotPhi], float3(0, 0, 1))));

    //If doesn't intersect
    if(origin.x + xLength < 0 || origin.y + yLength < 0 || origin.z + zLength < 0) 
        return;

    //If passes all checks
    structureInfo newStructure;
    newStructure.structurePos = pointPosition;
    newStructure.structureIndex = _BiomeStructureIndex[structureIndex];
    newStructure.rotation = uint2(rotTheta, rotPhi);

    structurePlans.Append(newStructure);
}
