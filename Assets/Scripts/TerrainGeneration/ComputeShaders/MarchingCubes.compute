#pragma kernel March

#include "Assets/Scripts/TerrainGeneration/ComputeShaders/Includes/MarchingTables.compute"
#include "Assets/Scripts/TerrainGeneration/ComputeShaders/Includes/GetIndex.compute"

struct Point{
    float3 tri;
    float3 norm;
    int2 id;
    int material;
};

struct TriangleConst { //Constructor
    Point points[3];
};

const static int numThreads = 8;
AppendStructuredBuffer<TriangleConst> triangles;
RWStructuredBuffer<float> points;
StructuredBuffer<int> material;
float IsoLevel;
float ResizeFactor;
uint numCubesPerAxis;

/*               
*  _____________  8  ------
* |  _________  | 7 6      |<-NumOfPoints, Density Map Size
* | |_|_|_|_|_| | 6 5 5 -  |
* | |_|_|_|_|_| | 5 4 4  | |
* | |_|_|_|_|_| | 4 3 3  |<+--ChunkSize / meshSkipInc
* | |_|_|_|_|_| | 3 2 2  | |  "Real Vertices"
* | |_|_|_|_|_| | 2 1 1 _| |
* |_____________| 1_^_^____|
*Purpose:           ^ | |
*   Border Normals⅃ | |
*          Last Edge⅃ |     
*      Number of Cubes⅃
*
*    4---4----5
*   7|       5|
*  / 8      / 9
* 7--+-6---6  |
* |  |     10 |
*11  0---0-+--1
* | 3      | 1
* 3----2---2/
* 
* z
* ^     .--------.
* |    /|       /|
* |   / |      / |    y
* |  .--+-----.  |   /\
* |  |  |     |  |   /
* |  |  .-----+--.  /
* |  | /      | /  /
* | xyz_______./  /
* +---------> x  /
*/

float sampleDensity(int3 coord) {
	coord = max(0, min(coord, numCubesPerAxis));
	return points[indexFromCoord(coord.x, coord.y, coord.z)];
}

bool isBorder(int3 coord){
    return (uint)max(coord.x, max(coord.y, coord.z)) == numCubesPerAxis || min(coord.x, min(coord.y, coord.z)) == 0;
}

float3 calculateNormal(int3 coord) {
	int3 offsetX = int3(1, 0, 0);
	int3 offsetY = int3(0, 1, 0);
	int3 offsetZ = int3(0, 0, 1);

    //Someone fix this later(I tried it's pain)
    //Either expand 3D map by 2 overlap points(which will make everything else very hard)
    //Or get 6 edge planes from neighbors(also hard)

	float dx = sampleDensity(coord - offsetX) - sampleDensity(coord + offsetX);
	float dy = sampleDensity(coord - offsetY) - sampleDensity(coord + offsetY);
	float dz = sampleDensity(coord - offsetZ) - sampleDensity(coord + offsetZ);


	return normalize(float3(dx, dy, dz));
}


float interpolate(float p1Val, float p2Val) {
    return ((IsoLevel - p1Val) / (p2Val - p1Val));
}


[numthreads(numThreads,numThreads,numThreads)]
void March (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numCubesPerAxis || id.y >= numCubesPerAxis || id.z >= numCubesPerAxis) {
        return;
    }

    int x = id.x;
    int y = id.y;
    int z = id.z;

    uint cubeIndex = 0;
    if (points[indexFromCoord(x, y + 1, z)] > IsoLevel) cubeIndex |= 1;
    if (points[indexFromCoord(x + 1, y + 1, z)] > IsoLevel) cubeIndex |= 2;
    if (points[indexFromCoord(x + 1, y, z)] > IsoLevel) cubeIndex |= 4;
    if (points[indexFromCoord(x, y, z)] > IsoLevel) cubeIndex |= 8;
    if (points[indexFromCoord(x, y + 1, z + 1)] > IsoLevel) cubeIndex |= 16;
    if (points[indexFromCoord(x + 1, y + 1, z + 1)] > IsoLevel) cubeIndex |= 32;
    if (points[indexFromCoord(x + 1, y, z + 1)] > IsoLevel) cubeIndex |= 64;
    if (points[indexFromCoord(x, y, z + 1)] > IsoLevel) cubeIndex |= 128;

    bool Borders[3] = {false, false, false};
    for (int i = 0; triangulation[cubeIndex][i] != -1; i +=3) {

        TriangleConst tric;
        [unroll] for(int v = 0; v < 3; v++){
            Point newPoint;

            //Get the point indexes
            int p1Ind = cornerIndexAFromEdge[triangulation[cubeIndex][i + v]];
            int p2Ind = cornerIndexBFromEdge[triangulation[cubeIndex][i + v]];

            //Figure out point positions
            float3 p1 = float3(x,y,z) + positionFromIndex[p1Ind];
            float3 p2 = float3(x,y,z) + positionFromIndex[p2Ind];

            //Get point densities
            float p1Val = points[indexFromCoord(p1.x, p1.y, p1.z)];
            float p2Val = points[indexFromCoord(p2.x, p2.y, p2.z)];

            float interpFactor = interpolate(p1Val, p2Val);

            if(p2Val > p1Val){
                float3 temp = p1;
                p1 = p2;
                p2 = temp;

                interpFactor = (1.0f-interpFactor);
            }

            float3 p1Norm = calculateNormal(p1);
            float3 p2Norm = calculateNormal(p2);

            newPoint.tri = p1 + interpFactor * (p2 - p1);
            newPoint.norm = normalize(p1Norm + interpFactor * (p2Norm - p1Norm));
            newPoint.material = material[indexFromCoord(p1.x, p1.y, p1.z)];

            int numOfPoints = numPointsPerAxis * numPointsPerAxis * numPointsPerAxis;
            newPoint.id = int2(indexFromCoord(p1.x, p1.y, p1.z), indexFromCoord(p2.x, p2.y, p2.z));

            tric.points[v] = newPoint, v;

            if(isBorder(p1) || isBorder(p2)) Borders[v] = true;
        }

        float3 triNorm = cross(tric.points[1].tri - tric.points[0].tri, tric.points[2].tri - tric.points[0].tri);
        if(Borders[0]) tric.points[0].norm = triNorm;
        if(Borders[1]) tric.points[1].norm = triNorm;
        if(Borders[2]) tric.points[2].norm = triNorm;

        tric.points[0].tri *= ResizeFactor;
        tric.points[1].tri *= ResizeFactor;
        tric.points[2].tri *= ResizeFactor;
        /*This is a temporary workaround, someone fix this
        *Two Options:
        *Expand mesh info by 2 to get out-of-mesh normal info (Hard)
        *Get 6 planes out-of-mesh info seperately(Still Hard)
        */

        triangles.Append(tric);
    }
}
