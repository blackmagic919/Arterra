// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
const static uint numThreads = 128;
const static uint VERTEX_STRIDE_4BYTES = 3 * 2 + (2 + 1);

struct Point{
    float3 tri;
    float3 norm;
    int2 id;
    int material;
};

struct TriangleConst { //Constructor
    Point points[3];
};

StructuredBuffer<TriangleConst> _BaseTriangles;

StructuredBuffer<uint> startAddress;
StructuredBuffer<uint> triLength;

RWStructuredBuffer<uint> _MemoryBuffer;

[numthreads(numThreads,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if(startAddress[0] == 0) //Out of space
        return;
    if(id.x >= triLength[0])
        return;

    TriangleConst tri = _BaseTriangles[id.x];
    uint triAddress = startAddress[0] + (id.x * (VERTEX_STRIDE_4BYTES * 3));

    [unroll]for(uint i = 0; i < 3; i++){
        uint vertAddress = triAddress + (VERTEX_STRIDE_4BYTES * i);

        _MemoryBuffer[vertAddress] = asuint(tri.points[i].tri.x);
        _MemoryBuffer[vertAddress + 1] = asuint(tri.points[i].tri.y);
        _MemoryBuffer[vertAddress + 2] = asuint(tri.points[i].tri.z);

        _MemoryBuffer[vertAddress + 3] = asuint(tri.points[i].norm.x);
        _MemoryBuffer[vertAddress + 4] = asuint(tri.points[i].norm.y);
        _MemoryBuffer[vertAddress + 5] = asuint(tri.points[i].norm.z);

        _MemoryBuffer[vertAddress + 6] = asuint(tri.points[i].id.x);
        _MemoryBuffer[vertAddress + 7] = asuint(tri.points[i].id.y);

        _MemoryBuffer[vertAddress + 8] = asuint(tri.points[i].material);
    }
}
