#pragma kernel March

#include "/Includes/MarchingTables.compute"
#include "/Includes/GetIndex.compute"

struct Point{
    float3 tri;
    float3 p1;
    float3 p2;
};

struct TriangleConst { //Constructor
    Point a;
    Point b;
    Point c;

    void Add(Point p, int n){
    if(n == 0)
        a = p;
    else if(n == 1)
        b = p;
    else if(n==2)
        c = p;
    }
};

const static int numThreads = 8;
AppendStructuredBuffer<TriangleConst> triangles;
RWStructuredBuffer<float> points;
float IsoLevel;

/*
*  
*    4---4----5
*   7|       5|
*  / 8      / 9
* 7--+-6---6  |
* |  |     10 |
*11  0---0-+--1
* | 3      | 1
* 3----2---2/
* 
* z
* ^     .--------.
* |    /|       /|
* |   / |      / |    y
* |  .--+-----.  |   /\
* |  |  |     |  |   /
* |  |  .-----+--.  /
* |  | /      | /  /
* | xyz_______./  /
* +---------> x  /
*/

float scaleNormals(float noise){
    float ret;
    if(noise >= IsoLevel)
        ret = -1*(noise-IsoLevel)/(1.0-IsoLevel);
    else
        ret = -1*(noise-IsoLevel)/(IsoLevel);
    return ret;
}

float interpolate(float p1Val, float p2Val) {
    return ((IsoLevel - p1Val) / (p2Val - p1Val));
}

[numthreads(numThreads,numThreads,numThreads)]
void March (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis-1 || id.y >= numPointsPerAxis-1 || id.z >= numPointsPerAxis-1) {
        return;
    }

    int x = id.x;
    int y = id.y;
    int z = id.z;

    uint cubeIndex = 0;
    if (points[indexFromCoord(x, y + 1, z)] > IsoLevel) cubeIndex |= 1;
    if (points[indexFromCoord(x + 1, y + 1, z)] > IsoLevel) cubeIndex |= 2;
    if (points[indexFromCoord(x + 1, y, z)] > IsoLevel) cubeIndex |= 4;
    if (points[indexFromCoord(x, y, z)] > IsoLevel) cubeIndex |= 8;
    if (points[indexFromCoord(x, y + 1, z + 1)] > IsoLevel) cubeIndex |= 16;
    if (points[indexFromCoord(x + 1, y + 1, z + 1)] > IsoLevel) cubeIndex |= 32;
    if (points[indexFromCoord(x + 1, y, z + 1)] > IsoLevel) cubeIndex |= 64;
    if (points[indexFromCoord(x, y, z + 1)] > IsoLevel) cubeIndex |= 128;
    
    for (int i = 0; triangulation[cubeIndex][i] != -1; i +=3) {

        TriangleConst tric;
        [unroll] for(int v = 0; v < 3; v++){
            Point newPoint;

            //Get the point indexes
            int p1Ind = cornerIndexAFromEdge[triangulation[cubeIndex][i + v]];
            int p2Ind = cornerIndexBFromEdge[triangulation[cubeIndex][i + v]];

            //Figure out point positions
            newPoint.p1 = float3(x,y,z) + positionFromIndex[p1Ind];
            newPoint.p2 = float3(x,y,z) + positionFromIndex[p2Ind];

            //Get point densities
            float p1Val = points[indexFromCoord(newPoint.p1.x, newPoint.p1.y, newPoint.p1.z)];
            float p2Val = points[indexFromCoord(newPoint.p2.x, newPoint.p2.y, newPoint.p2.z)];

            float interpFactor = interpolate(p1Val, p2Val);

            if(p2Val > p1Val){
                float3 temp = newPoint.p1;
                newPoint.p1 = newPoint.p2;
                newPoint.p2 = temp;

                interpFactor = (1.0f-interpFactor);
            }

            newPoint.tri = newPoint.p1 + interpFactor * (newPoint.p2 - newPoint.p1);

            tric.Add(newPoint, v);
        }
        triangles.Append(tric);
    }
}
