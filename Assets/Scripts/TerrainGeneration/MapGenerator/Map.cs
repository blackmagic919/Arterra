using Unity.Mathematics;
using UnityEngine;
using Unity.Collections;
using WorldConfig;


namespace WorldConfig.Generation{
/// <summary>
/// Identifies information used in generating the map info for a chunk.
/// Locates the noise samplers responsible for creating different aspects
/// of the terrain. <seealso href="https://blackmagic919.github.io/AboutMe/2024/08/01/Base-Generation/"/>
/// </summary>
[CreateAssetMenu(menuName = "Containers/Map Settings")]
public class Map : ScriptableObject{ 

    /// <summary>
    /// The height in grid space of the water surface. Water will only be generated if the <i>surface</i>, as defined in 
    /// <see cref="Surface"/> is below this height, water will then fill the space between the surface and this height.
    /// </summary> 
    /// <remarks>Water only generates below this height as creating various water heights involves topological examination 
    /// to affirm a water body is contained within the terrain which is expensive.</remarks>
    public float waterHeight;
    /// <summary>
    /// The falloff intensity of the height from the surface as height approaches infinity. <see cref="Biome.CaveBiome"/>s are permitted
    /// to generate preferrably based off the height from the surface, but as this height is unbounded, an inverse exponential function is
    /// used to remap the sample space to the range, 0 to 1. HeightFalloff descibes how quickly the function approaches its asymptote,
    /// with a higher value allowing for more control over a greater distance from the surface, and a lower value restricting the range
    /// to be closer to the surface. <seealso cref="Biome.CaveBiome.HeightStart"/>
    /// </summary>
    public float heightFalloff;
    /// <summary>
    /// The falloff intensity of the atmosphere that is multipled with the <see cref="Surface.AtmosphereNoise"/> map to 
    /// falloff the atmosphere as height approaches infinity. Because this number is very small, it is difficult to control directly 
    /// in the <see cref="Material.MaterialData">noise</see> settings, so this value is just used as a scalar for the entire function.
    /// </summary>
    public float atmosphereFalloff;
    /// <summary>
    /// The name of the noise function within the <see cref="WorldConfig.Config.GenerationSettings.Noise"/> registry of noise functions
    /// that is used to generate the frequency of the caves. Increased cave frequency will make caves appear more frequently by shifting
    /// the boundary between cave and non-cave space. This has the effect of enlarging pre-existing caves as well.
    /// </summary>
    public string CaveFrequencyNoise;
    /// <summary>
    /// The name of the noise function within the <see cref="WorldConfig.Config.GenerationSettings.Noise"/> registry of noise functions
    /// that is used to generate the size of the caves. It does this by assuming <see cref="CoarseTerrainNoise"/> generates larger caves 
    /// while <see cref="FineTerrainNoise"/> generates smaller caves, whereby it blends the two accordingly by the outputed <see cref="CaveSizeNoise"/>.
    /// </summary>
    public string CaveSizeNoise;
    /// <summary>
    /// The name of the noise function within the <see cref="WorldConfig.Config.GenerationSettings.Noise"/> registry of noise functions
    /// that is used to generate the shape of the caves. This is done by taking evaluating each entry's cave density by the distance
    /// from it to the outputed <see cref="CaveSizeNoise"/> and using that as the new density. This has the effect of creating blobular 
    /// regular caves when <see cref="CaveSizeNoise"/> approaches 0 or 1, and more stringy shell-like caves when <see cref="CaveSizeNoise"/> 
    /// is closer to 0.5.
    /// </summary>
    public string CaveShapeNoise;
    /// <summary>
    /// The name of the noise function within the <see cref="WorldConfig.Config.GenerationSettings.Noise"/> registry of noise functions
    /// that is used to generate a coarse noise map. <see cref="Biome.Info.BMaterial.genSize"/> may selectively blend between this map and
    /// the map generated by <see cref="FineMaterialNoise"/> to create a unique generation pattern without the need for a new noise function.
    /// </summary>
    public string CoarseMaterialNoise;
    /// <summary>
    /// The name of the noise function within the <see cref="WorldConfig.Config.GenerationSettings.Noise"/> registry of noise functions
    /// that is used to generate a fine noise map. <see cref="Biome.Info.BMaterial.genSize"/> may selectively blend between this map and
    /// the map generated by <see cref="CoarseMaterialNoise"/> to create a unique generation pattern without the need for a new noise function.
    /// </summary>
    public string FineMaterialNoise;
    /// <summary>
    /// The name of the noise function within the <see cref="WorldConfig.Config.GenerationSettings.Noise"/> registry of noise functions
    /// that is used to generate a coarse noise map. <see cref="CaveSizeNoise"/> may selectively blend between this map and
    /// the map generated by <see cref="FineTerrainNoise"/> to create a unique generation pattern without the need for a new noise function.
    /// </summary>
    public string CoarseTerrainNoise; //For underground terrain generation
    /// <summary>
    /// The name of the noise function within the <see cref="WorldConfig.Config.GenerationSettings.Noise"/> registry of noise functions
    /// that is used to generate a fine noise map. <see cref="CaveSizeNoise"/> may selectively blend between this map and
    /// the map generated by <see cref="CoarseTerrainNoise"/> to create a unique generation pattern without the need for a new noise function.
    /// </summary>
    public string FineTerrainNoise;
    /// <summary> The index of the noise function described by <see cref="CaveFrequencyNoise"/> in the <see cref="WorldConfig.Config.GenerationSettings.Noise">noise</see> registry </summary>
    public int CaveFrequencyIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(CaveFrequencyNoise);
    /// <summary> The index of the noise function described by <see cref="CaveSizeNoise"/> in the <see cref="WorldConfig.Config.GenerationSettings.Noise">noise</see> registry </summary>
    public int CaveSizeIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(CaveSizeNoise);
    /// <summary> The index of the noise function described by <see cref="CaveShapeNoise"/> in the <see cref="WorldConfig.Config.GenerationSettings.Noise">noise</see> registry </summary>
    public int CaveShapeIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(CaveShapeNoise);
    /// <summary> The index of the noise function described by <see cref="CoarseMaterialNoise"/> in the <see cref="WorldConfig.Config.GenerationSettings.Noise">noise</see> registry </summary>
    public int CoarseMaterialIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(CoarseMaterialNoise);
    /// <summary> The index of the noise function described by <see cref="FineMaterialNoise"/> in the <see cref="WorldConfig.Config.GenerationSettings.Noise">noise</see> registry </summary>
    public int FineMaterialIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(FineMaterialNoise);
    /// <summary> The index of the noise function described by <see cref="CoarseTerrainNoise"/> in the <see cref="WorldConfig.Config.GenerationSettings.Noise">noise</see> registry </summary>
    public int CoarseTerrainIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(CoarseTerrainNoise);
    /// <summary> The index of the noise function described by <see cref="FineTerrainNoise"/> in the <see cref="WorldConfig.Config.GenerationSettings.Noise">noise</see> registry </summary>
    public int FineTerrainIndex => Config.CURRENT.Generation.Noise.RetrieveIndex(FineTerrainNoise);
}}

/*

public CPUDensityManager.MapData[] GetChunkInfo(StructureCreator structCreator, uint surfaceData, Vector3 offset, float IsoLevel, int chunkSize)
    {
        int numPointsAxes = chunkSize + 1;
        int numOfPoints = numPointsAxes * numPointsAxes * numPointsAxes;

        GenerateBaseChunk(offset, surfaceData, chunkSize, 1, IsoLevel);
        structCreator.GenerateStrucutresGPU(chunkSize, 0, 0, IsoLevel);

        CPUDensityManager.MapData[] chunkMap = new CPUDensityManager.MapData[numOfPoints];

        UtilityBuffers.GenerationBuffer.GetData(chunkMap);
        return chunkMap;
    }

public ComputeBuffer GenerateDensity(SurfaceChunk.SurfData surfaceData, Vector3 offset, int LOD, int chunkSize, float IsoLevel)
{
    int meshSkipInc = meshSkipTable[LOD];
    ComputeBuffer density = GenerateTerrain(chunkSize, meshSkipInc, surfaceData, settings.CoarseTerrainNoise, settings.FineTerrainNoise, offset, IsoLevel, ref tempBuffers);

    return density;
}*/

/* old Direct Readback logic
    public MeshInfo ReadBackMesh(ComputeBuffer sourceMeshBuffer)
    {
        MeshInfo chunk = new MeshInfo();

        ComputeBuffer argsBuffer = new ComputeBuffer(1, sizeof(int) * 4, ComputeBufferType.IndirectArguments);
        argsBuffer.SetData(new int[] { 0, 1, 0, 0 });

        ComputeBuffer.CopyCount(sourceMeshBuffer, argsBuffer, 0);
        tempBuffers.Enqueue(argsBuffer);

        int[] data = { 0, 1, 0, 0 };
        argsBuffer.GetData(data);
        int numTris = data[0];
        
        if (numTris == 0)
        {
            ReleaseTempBuffers();
            return chunk;
        }
        
        TriangleConst[] tris = new TriangleConst[numTris];
        sourceMeshBuffer.GetData(tris, 0, 0, numTris);
        
        Dictionary<int2, int> vertDict = new Dictionary<int2, int>();
        int vertCount = 0;

        for (int i = 0; i < numTris; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (vertDict.TryGetValue(tris[i][j].id, out int vertIndex))
                {
                    chunk.triangles.Add(vertIndex);
                }
                else
                {
                    vertDict.Add(tris[i][j].id, vertCount);
                    chunk.triangles.Add(vertCount);
                    chunk.vertices.Add(tris[i][j].tri);
                    chunk.normals.Add(tris[i][j].norm);
                    chunk.colorMap.Add(new Color(tris[i][j].material, 0, 0));
                    vertCount++;
                }
            }
        }
        return chunk;

    }
    
    public Dictionary<int, Mesh> CreateSpecialMeshes(SpecialShaderData[] specialShaderData, MeshInfo terrainData)
    {
        Dictionary<int, Mesh> meshes = new Dictionary<int, Mesh>();
        for(int i = 0; i < specialShaderData.Length; i++)
        {
            MeshInfo meshData = GetSpecialMesh(specialShaderData[i], terrainData);
            meshes.TryAdd(specialShaderData[i].materialIndex, ChunkData.GenerateMesh(meshData));
        }
        return meshes;
    }


    public static MeshInfo GetSpecialMesh(SpecialShaderData shaderData, MeshInfo meshData)
    {
        MeshInfo subMesh = new MeshInfo();

        Dictionary<int, int> vertDict = new Dictionary<int, int>();
        int vertCount = 0;
        for (int t = 0; t < meshData.triangles.Count; t += 3)
        {
            float percentMaterial = 0;
            for (int i = 0; i < 3; i++)
            {
                int vertexInd = meshData.triangles[t + i];

                int material = (int)meshData.colorMap[vertexInd].r;

                if (material == shaderData.materialIndex)
                    percentMaterial++;
            }
            percentMaterial /= 3;

            if (percentMaterial < shaderData.cuttoffThreshold)
                continue;

            for (int i = 0; i < 3; i++)
            {
                int index = meshData.triangles[t + i];
                int vertIndex;
                if (vertDict.TryGetValue(index, out vertIndex))
                {
                    subMesh.triangles.Add(vertIndex);
                }
                else
                {
                    if (shaderData.replaceOriginal)
                        meshData.colorMap[index] = new Color(meshData.colorMap[index].r, meshData.colorMap[index].g, meshData.colorMap[index].b, 0f);

                    vertDict.Add(index, vertCount);
                    subMesh.vertices.Add(meshData.vertices[index]);
                    subMesh.normals.Add(meshData.normals[index]);
                    subMesh.triangles.Add(vertCount);
                    subMesh.colorMap.Add(new Color(0, 0, 0, percentMaterial));
                    vertCount++;
                }
            }
        }

        return subMesh;
    }*/


    /*y     
    * ^
    * |     .--------.      z
    * |    /|  5    /|     /\
    * |   / |   1  / |     /
    * |  .--+-----.  |    /
    * |  |4 |     |2 |   /
    * |  |  .--3--+--.  /
    * |  | /    6 | /  /
    * | xyz_______./  /
    * +--------------->x
    */
    /*
    public ComputeBuffer GetBorderPlanes(int chunkSize, int meshSkipInc, Vector3 offset)
    {
        Vector2 offset2D = new Vector2(offset.x, offset.z);
        int[] borderAxis = new int[6] { 2, 0, 2, 0, 1, 1 };
        int[] borderChunk = new int[6] { 1, 1, -1, -1, 1, -1 };
        int[] borderPlane = new int[6] { 1, 1, chunkSize - 1, chunkSize - 1, 1, chunkSize - 1 };

        for(int i = 0; i < 6; i++)
        {
            for()
        }

        ComputeBuffer baseDensity = densityGenerator.AnalyzeBase(rawPositions, TerrainNoise, offset, chunkSize);
        ComputeBuffer terrainHeights = mapCreator.AnalyzeTerrainMap(rawPositions, offset2D, chunkSize);
        ComputeBuffer squashHeights = mapCreator.AnalyzeSquashMap(rawPositions, offset2D, chunkSize);

        float[] densities = densityGenerator.AnalyzeTerrain(posY, baseDensity, terrainHeights, squashHeights);
    }

    public void GenerateStructures(Vector3 CCoord, float IsoLevel, int LOD, int chunkSize)
    {
        GenerateStructures(CCoord, IsoLevel, LOD, chunkSize, out float[] _, apply: true);
    }
    public struct TriangleConst
    {
        #pragma warning disable 649
        public Point a;
        public Point b;
        public Point c;

        public struct Point
        {
            public Vector3 tri;
            public Vector3 norm;
            public int2 id;
            public int material;
        }

        public Point this[int i] //courtesy of sebastian laugue, this is pretty smart
        {
            get
            {
                switch (i)
                {
                    case 0:
                        return a;
                    case 1:
                        return b;
                    default:
                        return c;
                }
            }
        }
    }
*/


/* old async logic that's too slow

    public void onTrianglesRecieved(AsyncGPUReadbackRequest request)
    {
        int[] data = request.GetData<int>().ToArray();
        numRealTris = data[0];
        //  Debug.Log(numRealTris);

        if (numRealTris == 0)
        {
            callback(chunk);
            return;
        }
            

        tris = new TriangleConst[numRealTris];
        triangelBuffer.GetData(tris, 0, 0, numRealTris); //Will already have calculated since count is binded

        this.vertexColor = new ComputeBuffer(numRealTris * 3, (sizeof(float) + sizeof(uint) + sizeof(uint)));
        densityGenerator.GenerateMat(GenerationData.Materials, vertexColor, tris, numRealTris, chunk.heightCurves, mapChunkSize, meshSkipInc, offset);

        AsyncGPUReadbackRequest newRequest = AsyncGPUReadback.Request(vertexColor, onColorsRecieved);
    }

    public void onColorsRecieved(AsyncGPUReadbackRequest request)
    {
        VertexColor[] vertColors = request.GetData<VertexColor>().ToArray();

        chunk.meshData.vertices = new List<Vector3>(new Vector3[numRealTris * 3]);
        chunk.meshData.triangles = new List<int>(new int[numRealTris * 3]);
        chunk.meshData.vertexParents = new List<Vector3>(new Vector3[numRealTris * 3 * 2]);
        chunk.colorMap = new Color[numRealTris * 3];

        for (int i = 0; i < numRealTris; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                chunk.meshData.triangles[i * 3 + j] = i * 3 + j;
                chunk.meshData.vertices[i * 3 + j] = tris[i].tri[j] * meshSkipInc;
                chunk.colorMap[i * 3 + j] = new Color(vertColors[i * 3 + j].p1Index, vertColors[i * 3 + j].p2Index, vertColors[i * 3 + j].interp * 255);
                chunk.meshData.vertexParents[2 * (i * 3 + j)] = tris[i].p1[j];
                chunk.meshData.vertexParents[2 * (i * 3 + j) + 1] = tris[i].p2[j];
            }
        }
        
        releaseBuffers();

        TextureData.ApplyToMaterial(terrainMat, GenerationData.Materials);

        callback(chunk);
    }*/

//Terrain Noise -> Vertices -> Generation Noise -> Material Map -> Color Map -> Color Vertices
/*public ChunkData GenerateMapData(NoiseData TerrainNoise, NoiseData SurfaceNoise, GenerationHeightData GenerationData, float IsoLevel, int surfaceMaxDepth, Vector3 offset, int LOD)
{
    int meshSkipInc = ((LOD == 0) ? 1 : LOD * 2);

    ChunkData chunk = new ChunkData();

    chunk.undergroundNoise = Noise.GenerateNoiseMap(TerrainNoise, mapChunkSize, mapChunkSize, mapChunkSize, offset, meshSkipInc); //This is so ineffecient cause it only matters when y pos is < depth but I'm lazy somebody fix this

    chunk.surfaceNoise = Noise.GenerateNoiseMap(SurfaceNoise, mapChunkSize, mapChunkSize, mapChunkSize, offset, meshSkipInc);

    chunk.terrainNoiseMap = LegacyGeneration.terrainBelowGround(mapChunkSize, mapChunkSize, mapChunkSize, chunk.surfaceNoise, chunk.undergroundNoise, surfaceMaxDepth, IsoLevel, offset, meshSkipInc);

    chunk.meshData = MeshGenerator.GenerateMesh(chunk.terrainNoiseMap, IsoLevel);

    chunk.partialGenerationNoises = LegacyGeneration.GetPartialGenerationNoises(GenerationData, offset, chunk.meshData.vertexParents);

    chunk.heightCurves = LegacyGeneration.GetHeightCurves(GenerationData.Materials, (int)(offset.y), mapChunkSize, meshSkipInc);

    chunk.materialMap = LegacyGeneration.GetPartialMaterialMap(chunk.partialGenerationNoises, GenerationData, chunk.meshData.vertexParents, meshSkipInc, chunk.heightCurves);

    chunk.meshData.colorMap = new List<Color>(LegacyGeneration.GetPartialColors(chunk.meshData.vertices, chunk.meshData.vertexParents, chunk.materialMap));

    chunk.meshData.vertices = LegacyGeneration.RescaleVertices(chunk.meshData.vertices, meshSkipInc);

    chunk.meshData.vertexParents = LegacyGeneration.RescaleVertices(chunk.meshData.vertexParents, meshSkipInc);

    return chunk;
}*/
