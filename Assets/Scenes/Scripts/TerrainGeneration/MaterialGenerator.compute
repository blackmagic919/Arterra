#pragma kernel Generate
#pragma multi_compile _ HAS_EXISTING_MATERIALS

#include "/Includes/PerlinNoiseGenerator.compute"

struct parentMat{
    uint materialIndex;
    float weight; //Purely for generation purposes
};

struct vertexMat{
    uint p1Index;
    uint p2Index;
    float interp; //Range 0-1
};

#ifdef HAS_EXISTING_MATERIALS

StructuredBuffer<float> existingMats;
uint pointsPerAxis;

uint indexFromCoord(uint x, uint y, uint z) {
    return x * pointsPerAxis * pointsPerAxis + y * pointsPerAxis + z;
}

#endif

uint numVerts;
uint numVertsAxis;
uint matIndex;
uint genOrder;
uint numMats;
StructuredBuffer<float3> trianglesR;
StructuredBuffer<float3> parentTriR;
RWStructuredBuffer<parentMat> materials;
RWStructuredBuffer<vertexMat> vertexColor;
StructuredBuffer<float> heights;

const static int numThreads = 8;

//2D threading
[numthreads(numThreads,numThreads, numThreads)]
void Generate (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x*numVertsAxis*numVertsAxis + id.y*numVertsAxis + id.z;

    if (index >= numVerts) {
        return;
    }
    
    float3 p1PosF = parentTriR[2*index];
    uint3 p1PosI = uint3(p1PosF.x, p1PosF.y, p1PosF.z);
    float p1Weight = GetNoise(p1PosI) * heights[p1PosI.y];

    if(genOrder == 0 || p1Weight > materials[2*index].weight){
        materials[2*index].weight = p1Weight;
        materials[2*index].materialIndex = matIndex;
    }

    float3 p2PosF = parentTriR[2*index+1];
    uint3 p2PosI = uint3(p2PosF.x, p2PosF.y, p2PosF.z);
    float p2Weight = GetNoise(p2PosI) * heights[p2PosI.y];

    if(genOrder == 0 || p2Weight > materials[2*index + 1].weight){
        materials[2*index + 1].weight = p2Weight;
        materials[2*index + 1].materialIndex = matIndex;
    }

    if(genOrder+1 == numMats){
        vertexColor[index].p1Index = materials[2*(index)].materialIndex;
        vertexColor[index].p2Index = materials[2*(index) + 1].materialIndex;

#ifdef HAS_EXISTING_MATERIALS

        float p1MatE = existingMats[indexFromCoord(p1PosI.x, p1PosI.y, p1PosI.z)];
        float p2MatE = existingMats[indexFromCoord(p2PosI.x, p2PosI.y, p2PosI.z)];
        vertexColor[index].p1Index = (p1MatE == -1.0f) ? materials[2*(index)].materialIndex : (uint)p1MatE;
        vertexColor[index].p2Index = (p2MatE == -1.0f) ? materials[2*(index) + 1].materialIndex : (uint)p2MatE;
#else
        vertexColor[index].p1Index = materials[2*(index)].materialIndex;
        vertexColor[index].p2Index = materials[2*(index) + 1].materialIndex;
#endif

        vertexColor[index].interp = distance(trianglesR[index], p1PosF) / distance(p2PosF, p1PosF);
    }
}