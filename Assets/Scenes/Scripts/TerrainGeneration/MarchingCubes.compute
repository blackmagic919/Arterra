#pragma kernel March

#include "/Includes/MarchingTables.compute"
#include "/Includes/GetIndex.compute"

struct Triangle{
    float3 x;
    float3 y;
    float3 z;
};

struct TriangleConst { //Constructor
    Triangle tri;
    Triangle p1;
    Triangle p2;
};

const static int numThreads = 8;
AppendStructuredBuffer<TriangleConst> triangles;
RWStructuredBuffer<float> points;
float IsoLevel;

/*
*  
*    4---4----5
*   7|       5|
*  / 8      / 9
* 7--+-6---6  |
* |  |     10 |
*11  0---0-+--1
* | 3      | 1
* 3----2---2/
* 
* z
* ^     .--------.
* |    /|       /|
* |   / |      / |    y
* |  .--+-----.  |   /\
* |  |  |     |  |   /
* |  |  .-----+--.  /
* |  | /      | /  /
* | xyz_______./  /
* +---------> x  /
*/
float lerp(float a, float b, float value){
    return (a*value) + (b*(1-value));
}

float scaleNormals(float noise){
    float ret;
    if(noise >= IsoLevel)
        ret = -1*(noise-IsoLevel)/(1.0-IsoLevel);
    else
        ret = -1*(noise-IsoLevel)/(IsoLevel);
    return ret;
}

float interpolate(float p1Val, float p2Val) {
    return ((IsoLevel - p1Val) / (p2Val - p1Val));
}

[numthreads(numThreads,numThreads,numThreads)]
void March (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis-1 || id.y >= numPointsPerAxis-1 || id.z >= numPointsPerAxis-1) {
        return;
    }

    int x = id.x;
    int y = id.y;
    int z = id.z;

    uint cubeIndex = 0;
    if (points[indexFromCoord(x, y + 1, z)] > IsoLevel) cubeIndex |= 1;
    if (points[indexFromCoord(x + 1, y + 1, z)] > IsoLevel) cubeIndex |= 2;
    if (points[indexFromCoord(x + 1, y, z)] > IsoLevel) cubeIndex |= 4;
    if (points[indexFromCoord(x, y, z)] > IsoLevel) cubeIndex |= 8;
    if (points[indexFromCoord(x, y + 1, z + 1)] > IsoLevel) cubeIndex |= 16;
    if (points[indexFromCoord(x + 1, y + 1, z + 1)] > IsoLevel) cubeIndex |= 32;
    if (points[indexFromCoord(x + 1, y, z + 1)] > IsoLevel) cubeIndex |= 64;
    if (points[indexFromCoord(x, y, z + 1)] > IsoLevel) cubeIndex |= 128;
    
    for (int i = 0; triangulation[cubeIndex][i] != -1; i +=3) {
        
        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i+1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i+1]];

        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i+2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i+2]];
        
        float3 a0Pos = float3(x,y,z) + positionFromIndex[a0];
        float3 a1Pos = float3(x,y,z) + positionFromIndex[a1];
        float3 a2Pos = float3(x,y,z) + positionFromIndex[a2];

        float3 b0Pos = float3(x,y,z) + positionFromIndex[b0];
        float3 b1Pos = float3(x,y,z) + positionFromIndex[b1];
        float3 b2Pos = float3(x,y,z) + positionFromIndex[b2];

        float a0Val = points[indexFromCoord(a0Pos.x, a0Pos.y, a0Pos.z)];
        float a1Val = points[indexFromCoord(a1Pos.x, a1Pos.y, a1Pos.z)];
        float a2Val = points[indexFromCoord(a2Pos.x, a2Pos.y, a2Pos.z)];

        float b0Val = points[indexFromCoord(b0Pos.x, b0Pos.y, b0Pos.z)];
        float b1Val = points[indexFromCoord(b1Pos.x, b1Pos.y, b1Pos.z)];
        float b2Val = points[indexFromCoord(b2Pos.x, b2Pos.y, b2Pos.z)];

        float interpFactorX = interpolate(a0Val, b0Val);
        float interpFactorY = interpolate(a1Val, b1Val);
        float interpFactorZ = interpolate(a2Val, b2Val);
       
        TriangleConst tric;
        Triangle tri;
        Triangle p1;
        Triangle p2;

        p1.x = a0Pos;
        p1.y = a1Pos;
        p1.z = a2Pos;
        tric.p1 = p1;

        p2.x = b0Pos;
        p2.y = b1Pos;
        p2.z = b2Pos;
        tric.p2 = p2;

        tri.x = a0Pos + interpFactorX * (b0Pos - a0Pos);
        tri.y = a1Pos + interpFactorY * (b1Pos - a1Pos);
        tri.z = a2Pos + interpFactorZ * (b2Pos - a2Pos);
        tric.tri = tri;


        triangles.Append(tric);
    }
}
