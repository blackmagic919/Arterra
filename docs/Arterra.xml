<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Assembly-CSharp</name>
    </assembly>
    <members>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.PeekItem(System.Int32)">
            <summary> Retrieves the item at the given index without modifying the entry </summary>
            <param name="index">The index of the item being peeked</param>
            <returns>The item being peeked</returns>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.IInventory.Capacity">
            <summary> Gets the capacity of the inventory </summary>
            <returns>The capacity of the inventory</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.RemoveEntry(System.Int32)">
            <summary> Removes the entry at a given index, does nothing
            if nothing is there. </summary>
            <param name="slot">The index of the item being removed</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.AddEntry(Arterra.Configuration.Generation.Item.IItem,System.Int32)">
            <summary> Adds an item to the inventory at a certain slot index. </summary>
            <param name="entry">The item to be added </param>
            <param name="index">The slot index for the item to be added at</param>
            <returns>Whether or not the item was succesffully added</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.AddEntry(Arterra.Configuration.Generation.Item.IItem,System.Int32@)">
            <summary>Adds an item to the next available/empty slot in the inventory.</summary>
            <param name="entry">The item to be added</param>
            <param name="head">The slot index it was added at</param>
            <returns>Whether or not the item was successfully added</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.ReapplyHandles">
            <summary> Reapplies all OnEnter hooks to items. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.UnapplyHandles">
            <summary> Reapplies all OnLeave hooks to items. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.RemoveStackableKey(System.Int32,System.Int32,System.Action{Arterra.Configuration.Generation.Item.IItem})">
            <summary>Removes an amount of a specific type of item. </summary>
            <param name="KeyIndex"> The item index, or the unique <see cref="P:IRegistered.Index"/> for every item</param>
            <param name="delta">The raw amount to remove</param>
            <param name="OnRemove"> The callback that will be called for every item removed</param>
            <returns>The raw amount removed</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.AddStackable(Arterra.Configuration.Generation.Item.IItem)">
            <summary> Adds a stackable amount of an item to an inventory. By default same as AddEntry;
            override this to add an item to try combine into an already existing non-full slot with same item. </summary>
            <param name="mat">The item to be added </param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.AddStackable(Arterra.Configuration.Generation.Item.IItem,System.Int32)">
            <summary> Adds an item of a 
            </summary>
            <param name="mat"></param>
            <param name="SlotIndex"></param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.RemoveStackableSlot(System.Int32,System.Int32)">
            <summary> Removes an amount of the item at a given slot. </summary>
            <param name="SlotIndex">The index of the item to be removed</param>
            <param name="delta">The raw amount ot remove</param>
            <returns>The actual raw amount removed</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IInventory.TryGetKey(System.Int32,System.Int32@)">
            <summary> Tries to find an item of the given item index in the inventory. </summary>
            <param name="itemIndex">The type index of the item to be found</param>
            <param name="slotIndex">The index of the slot holding the item</param>
            <returns></returns>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.BowItemAuthoring.MaxDurability">
            <summary>  The maximum durability of the item, the durability it possesses when it is first
            created. Removing material with tools will decrease durability by the amount indicated
            in the tag <see cref="T:ToolTag"/> for more info. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Item.AuthoringTemplate`1">
            <summary> A template for creating an item. To create an inspector serializable object, the 
            concrete type must be known. This allows us to quickly fulfill the contract with
            the <see cref="T:Arterra.Configuration.Generation.Item.IItem"/>  interface. </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.AuthoringTemplate`1.Item">
            <summary> Returns a new instance of the concrete type implementing <see cref="T:Arterra.Configuration.Generation.Item.IItem"/>, fulfilling the contract. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Item.Authoring">
            <summary>
            Information shared by all instances of an item containing static properties
            that describe the apperance of the item as well as its connection to the 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"> material registry </see>. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.Authoring.TextureName">
            <summary> The name of the entry within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Textures"> texture registry </see>
            of the texture that is displayed when the item is in a UI panel. It is also used to create an <see cref="T:EItem"> entity item</see> mesh
            if the item is dropped in the world. This must always be a valid entry. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.Authoring.Item">
            <summary>
            The item instance that stores information specific to a specific instance of the item. The instance
            should store the index within <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/> of the entry it 
            is created from to retrieve the item's shared information contained within its <see cref="T:Arterra.Configuration.Generation.Item.Authoring"/> object.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.Authoring.Description">
            <summary>An(optional) description of the item 
            used as helpful tooltips for the player. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Item.IItem">
            <summary>
            A contract for an item instance that is created from an <see cref="T:Arterra.Configuration.Generation.Item.Authoring"/> object. 
            An item can be anything and define however much data it needs to store and how to manage it.
            However, for it to be properly managed by the system, it must detail several properties
            related to its apperance, storage, and serialization. </summary> <remarks> 
            The contract also provides some hooks that the item can subscribe to which will be answered 
            when specific events occur for the item. There is <i>almost</i> no limit on what can't be
            done on a hooked event, such as reassigning keybinds, moving items, changing player effects, etc. 
            As long as the event itself is safe, the item can do whatever it wants allowing for a very
            flexible system. </remarks>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.IItem.StackLimit">
            <summary> How much of the item can be combined together before the item is considered full. If 
            an item is not full, when another item of the same <see cref="P:IRegistered.Index"/> is encountered it may 
            be combined with the current item and the <see cref="P:Arterra.Configuration.Generation.Item.IItem.AmountRaw"/> increased to the sum the amounts of the two items. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.IItem.UnitSize">
            <summary> The <see cref="P:Arterra.Configuration.Generation.Item.IItem.AmountRaw">raw amount</see> of an item that is considered a unit
            amount. For exmaple, if five units of an item is added to an item, <see cref="P:Arterra.Configuration.Generation.Item.IItem.AmountRaw"/>
            will increase by (5 * UnitSize).  </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.IItem.AmountRaw">
            <summary> The amount of the item that is stored. Used when determing how to stack identical items </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.IItem.TexIndex">
            <summary>The maximum amount of item that all systems can stably support.</summary>
            <summary> The index within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Textures"> texture registry </see> of the item's texture.
            This is obtained by using the <see cref="P:IRegistered.Index"/> within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"> item registry </see>
            to obtain the <see cref="F:Arterra.Configuration.Generation.Item.Authoring.TextureName"/> of the texture which can be used to find the texture in the external
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Textures"> texture registry </see>. See <seealso cref="F:Arterra.Configuration.Generation.Item.Authoring.TextureName"/> for
            more information. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IItem.Create(System.Int32,System.Int32)">
            <summary> The constructor function called whenever an item is created.
            This should be used to setup Index and AmountRaw. </summary>
            <param name="Index">The index of the item within <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/> registry</param>
            <param name="AmountRaw">The amount of the item</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IItem.OnEnter(Arterra.Configuration.Generation.Item.ItemContext)">
            <summary>  An event hook that is called on the frame when the item enters the situation context given by <paramref name="cxt"/>.
            This is an airtight state, meaning <see cref="M:Arterra.Configuration.Generation.Item.IItem.OnLeave(Arterra.Configuration.Generation.Item.ItemContext)"/> must be called before <see cref="M:Arterra.Configuration.Generation.Item.IItem.OnEnter(Arterra.Configuration.Generation.Item.ItemContext)"/> can be called
            a second time. </summary>
            <param name="cxt">The context in which the item is being entered.</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IItem.OnLeave(Arterra.Configuration.Generation.Item.ItemContext)">
            <summary> An event hook that is called on the frame when the item leaves the  situation context given by <paramref name="cxt"/>.
            This is an airtight state meaning <see cref="M:Arterra.Configuration.Generation.Item.IItem.OnEnter(Arterra.Configuration.Generation.Item.ItemContext)"/> must be called before <see cref="M:Arterra.Configuration.Generation.Item.IItem.OnLeave(Arterra.Configuration.Generation.Item.ItemContext)"/> can be called. </summary>
            <param name="cxt">The context in which the item is being entered.</param>/// 
        </member>
        <member name="M:Arterra.Configuration.Generation.Item.IItem.UpdateEItem">
            <summary> An event hook that is called every frame the item is held by an <see cref="T:EItem">EntityItem</see>. </summary>
            <remarks> TODO: This has yet to be implemented </remarks>
        </member>
        <member name="T:Arterra.Configuration.Generation.Item.PlaceableItem">
            <summary> An interface implemented by items that have a direct translation to material 
            representation and thus are placeable in the world. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialName">
            <summary>
            The name of the entry within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"> material registry </see>
            of the material that is placed when the item is selected when placing terrain.
            If the material name is not a valid entry, the item will not be able to be placed as a material (e.g. a tool).
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialState">
            <summary>
            If the material is <see cref="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialName">placable as a material</see>, whether it should place the material indicated
            by <see cref="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialName"/> in a solid or liquid state. If it is not placable this value is ignored. 
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.PlaceableItem.IsSolid">
            <summary> If the item is <see cref="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialName">placable as a material</see>, whether <see cref="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialState"/> is solid. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.PlaceableItem.IsLiquid">
            <summary> If the item is <see cref="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialName">placable as a material</see>, whether <see cref="F:Arterra.Configuration.Generation.Item.PlaceableItem.MaterialState"/> is liquid. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Item.PlaceableItem.State">
            <summary>
            The states a material can be placed as from an item. 
            This is either a solid or liquid.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.PlaceableItem.State.Solid">
            <summary> The material is placed as a solid. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.PlaceableItem.State.Liquid">
            <summary> The material is placed as a liquid. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Item.PlaceableTemplate`1">
            <summary> A template for creating an item. To create an inspector serializable object, the 
            concrete type must be known. This allows us to quickly fulfill the contract with
            the <see cref="T:Arterra.Configuration.Generation.Item.IItem"/>  interface. </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="P:Arterra.Configuration.Generation.Item.PlaceableTemplate`1.Item">
            <summary> Returns a new instance of the concrete type implementing <see cref="T:Arterra.Configuration.Generation.Item.IItem"/>, fulfilling the contract. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.BucketItemAuthoring.TerraformRadius">
            <summary> The radius, in grid space, of the spherical region around the user's
            cursor that will be modified when the user terraforms the terrain. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.BucketItemAuthoring.TerraformSpeed">
            <summary> The speed at which the user can terraform the terrain. As terraforming is a 
            continuous process, the speed is measured in terms of change in density per frame. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.MatConverterAuthoring.TerraformRadius">
            <summary> The radius, in grid space, of the spherical region around the user's
            cursor that will be modified when the user terraforms the terrain. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.MatConverterAuthoring.ConverterTag">
            <summary> The tag used to determine what a material is converted to and how 
            to convert it. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.FishingRodAuthoring.MaxDurability">
            <summary>  The maximum durability of the item, the durability it possesses when it is first
            created. Removing material with tools will decrease durability by the amount indicated
            in the tag <see cref="T:ToolTag"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.FishingRodAuthoring.MinDrawTime">
            <summary> The tag used to determine how each material's removal should be handled.
            A material's most specific tag that fits this enum will be used to determine
            how this tool effects it. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.FishingRodAuthoring.BaitTag">
            <summary> If none, it will always cast Hook Entity, which can be useful
            if we don't want the rod to take an item from the holder's inventory and cast it </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.MatConverterToolAuthoring.ConverterTag">
            <summary> The tag used to determine what a material is converted to and how 
            to convert it. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.ToolItemAuthoring.TerraformRadius">
            <summary> The radius, in grid space, of the spherical region around the user's
            cursor that will be modified when the user terraforms the terrain. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.ToolItemAuthoring.MaxDurability">
            <summary>  The maximum durability of the item, the durability it possesses when it is first
            created. Removing material with tools will decrease durability by the amount indicated
            in the tag <see cref="F:Arterra.Configuration.Generation.Item.ToolItemAuthoring.ToolTag"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Item.ToolItemAuthoring.ToolTag">
            <summary> The tag used to determine how each material's removal should be handled.
            A material's most specific tag that fits this enum will be used to determine
            how this tool effects it. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Surface">
            <summary>
            Identifies information used in generating the surface of a chunk. 
            Locates the noise samplers responsible for creating different aspects of the surface. 
            The surface is a seperate 2D map generated and cached by every chunk that is necessary
            to proceed with the rest terrain generation. Resultantly, all noise maps referenced
            are sampled in a 2D space where the vertical dimension is ignored.
            <seealso href="https://blackmagic919.github.io/AboutMe/2024/08/01/Base-Generation/"/>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.terrainOffset">
            <summary>
            The offset in grid space of the surface from the world origin of the grid. This offset is added
            to the final terrain height to shift it relative to the grid origin. Because the surface extends
            from a grid space height of 0 to <see cref="F:Arterra.Configuration.Generation.Surface.MaxTerrainHeight"/>, one may desire to shift the surface
            to be centered around 0 by setting this value to <see cref="F:Arterra.Configuration.Generation.Surface.MaxTerrainHeight"/>/2.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.MaxTerrainHeight">
            <summary>
            The maximum height of the terrain generated by the surface in grid space. Increasing maxTerrainHeight
            will stretch the surface vertically. The actual height of the surface is calculated by the <see cref="F:Arterra.Configuration.Generation.Surface.ContinentalNoise"/>,
            <see cref="F:Arterra.Configuration.Generation.Surface.MajorWarpNoise"/>, <see cref="F:Arterra.Configuration.Generation.Surface.MinorWarpNoise"/>, and <see cref="F:Arterra.Configuration.Generation.Surface.ErosionNoise"/> samplers whereby <see cref="F:Arterra.Configuration.Generation.Surface.MaxTerrainHeight"/> scales this final height
            </summary> 
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.MaxSquashHeight">
            <summary>
            The maximum height below the surface where the density falloff begins. At the surface, the density is multiplied
            by <see cref="!:Config.Quality.Terrain.IsoLevel"/> ensuring that it cannot be underground. As the height approaches
            <see cref="F:Arterra.Configuration.Generation.Surface.MaxSquashHeight"/>, this multiplier approaches 1 restoring the original density. A lower height will result
            in a flatter surface with less overhangs while a higher height will result in a more shattered surface. The actual squash
            height is determined by the <see cref="F:Arterra.Configuration.Generation.Surface.SquashNoise"/> sampler whereby <see cref="F:Arterra.Configuration.Generation.Surface.MaxSquashHeight"/> scales this height.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.MaxInfluenceHeight">
            <summary>
            The total length in grid space of the range around the surface where <see cref="T:Arterra.Configuration.Generation.Biome.SurfaceBiome">Surface Biomes</see> take
            over biome-related generation from <see cref="T:Arterra.Configuration.Generation.Biome.CaveBiome">Cave Biomes</see> which control generation across all other
            space. The actual height and offset of the range is determined by the <see cref="F:Arterra.Configuration.Generation.Surface.InfHeightNoise"/> and <see cref="F:Arterra.Configuration.Generation.Surface.InfOffsetNoise"/>
            whereby MaxInfluenceHeight scales this range.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.ContinentalNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the continental noise
            map, or the coarse terrain height for large-scale features. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.ErosionNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the erosion noise
            map which blends the amplitude of different octaves within the <see cref="F:Arterra.Configuration.Generation.Surface.ContinentalNoise"/> heightmap. More specifically,
            erosion controls the influence of PVNoise being added to the continental noise and does not scale ContentinalNoise in any way.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.MajorWarpNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the Major Domain Warp 
            noise map, or specifically the primary noise map which distorts the domain at which the terrain height noise maps are sampled. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.MinorWarpNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the Minor Domain Warp 
            noise map, or specifically the secondary noise map which distorts the domain at which the terrain height noise maps are sampled. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.SquashNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the squash noise map.
            The squash noise map dictates, for each 2D surface coordinate, the distance below the surface where the density falloff
            begins. <seealso cref="F:Arterra.Configuration.Generation.Surface.MaxSquashHeight"/>.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.InfHeightNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the influence height noise map.
            The influence height noise map dictates, for each 2D surface coordinate, total length in grid space of the range around the surface
            where <see cref="T:Arterra.Configuration.Generation.Biome.SurfaceBiome">Surface Biomes</see> takes over biome-related generation.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.InfOffsetNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the influence offset noise map.
            The range determined by <see cref="F:Arterra.Configuration.Generation.Surface.InfHeightNoise"/> is shifted by the influence offset noise map where an offset of 0 places the range
            completely above the surface, an offset of 1 places the range completely below the surface, and an offset of 0.5 places the range 
            such that it is bisected by the surface.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Surface.AtmosphereNoise">
            <summary>
            The name of the noise sampler in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">Noise</see> registry that generates the atmosphere noise map.
            The atmophere noise describes how fast the atmosphere falls off as the height above the surface increases. This is physically done
            by reducing the density of the map as the height approaches infinity. <seealso cref="F:Arterra.Configuration.Generation.Map.heightFalloff"/>.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.ContinentalIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.ContinentalNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.ErosionIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.ErosionNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.MajorWarpIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.MajorWarpNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.MinorWarpIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.MinorWarpNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.SquashIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.SquashNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.InfHeightIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.InfHeightNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.InfOffsetIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.InfOffsetNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Surface.AtmosphereIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Surface.AtmosphereNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.DecayMaterial">
            <summary> A concrete material that will attempt to decay to one other state
            after a certain amount of time. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.DecayMaterial.DecayChance">
            <summary>The chance that the grass will decay and become <see cref="T:Arterra.Configuration.Generation.Material.DecayMaterial"/> when randomly updated. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.DecayMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Random Material Update entry used to trigger grass growth. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.DecayMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Mandatory callback for when grass is forcibly updated. Do nothing here. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.DecayMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.DecayMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter"/> 
            for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.DecayMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.ConditionedGrowthMat">
            <summary> A concrete material that will attempt to spread itself to neighboring entries 
            when and only when  randomly updated. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.ConditionedGrowthMat.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.ConditionedGrowthMat.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter"/> 
            for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.ConditionedGrowthMat.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.Generation">
            <summary> The container for all materials that can be generated. Materials determine how the terrain appears
            when it is solid, liquid, or atmospheric as well as <see cref="T:Arterra.Core.Terrain.TerrainUpdate"> possible 
            interactions </see>. Materials only exist as part of the terrain and once picked up are handled by the 
            <see cref="T:Arterra.Configuration.Generation.Item.Authoring"/> system. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.Generation.MaterialDictionary">
            <summary> The registry containing all materials that can be generated. The number of materials that can be generated is limited by this registry.
            See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.Generation.liquidFineWave">
            <summary> The liquid fine wave texture that is blended with <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidCoarseWave"/> to create waves. This can
            be tuned by <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.liquidData"/> depending on the liquid that is being displayed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.Generation.liquidCoarseWave">
            <summary> The liquid coarse wave texture that is blended with <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidFineWave"/> to create waves. This can
            be tuned by <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.liquidData"/> depending on the liquid that is being displayed. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.SourceDecayMaterial">
            <summary> A concrete material that will attempt to decay to one other state
            after a certain amount of time. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.SourceDecayMaterial.DecayChance">
            <summary>The chance that the grass will decay and become <see cref="T:Arterra.Configuration.Generation.Material.DecayMaterial"/> when randomly updated. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.SourceDecayMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Random Material Update entry used to trigger grass growth. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.SourceDecayMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Mandatory callback for when grass is forcibly updated. Do nothing here. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.SourceDecayMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.SourceDecayMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter"/> 
            for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.SourceDecayMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData">
            <summary> All settings related to the apperance and interaction of 
            materials in the game world. Different materials are allowed
            to define their own subclass of <see cref="T:Arterra.Configuration.Generation.Material.MaterialData"/> to define 
            different interaction behaviors. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.Names">
            <summary>
            The registry names of all entries referencing registries within <see cref="T:Arterra.Configuration.Generation.Material.MaterialData"/>. When an element needs to 
            reference an entry in an external registry, they can indicate the index within this list of the name of the entry 
            within the registry that they are referencing. This allows for the material module to be decoupled from the rest 
            of the world's configuration. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.terrainData">
            <summary> Settings controlling the appearance of the terrain when the material is solid. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.TerrainData"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.AtmosphereScatter">
            <summary> Settings controlling the apperance of the terrain when the material is atmospheric. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.AtmosphericData"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.liquidData">
            <summary> Settings controlling the appearance of the terrain when the material is liquid. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.LiquidData"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.Roughness">
            <summary> The amount of friction entities touching this material will experience </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.GetRegistry">
            <summary>Gets the material registry, Implementation of <see cref="M:IRegistered.GetRegistry"/>. </summary>
            <returns></returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary>
            Called whenever a map entry of this material has been modified. This method can be
            overrided to provide specific behavior when a certain material has been modified. See
            <see cref="T:Arterra.Core.Terrain.TerrainUpdate"/> for more information.
            </summary>
            <param name="GCoord">The coordinate in grid space of the entry that has been updated. It is guaranteed
            that the map entry at GCoord will be of the same material as the instance that recieves the update. </param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Called whenever a map entry of this material has been randomly updated. Random updates are used to
            simulate the natural changes of the material over time. They cannot be added externally and
            are sampled at random from an internal system. See <see cref="T:Arterra.Core.Terrain.TerrainUpdate"/> 
            for more information </summary>
            <param name="GCoord">The coordinate in grid space of the entry that has been updated. It is guaranteed
            that the map entry at GCoord will be of the same material as the instance that recieves the update.</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoving(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)">
            <summary> Called whenever the player is about to remove the terrain; called for all the materials
            that will be removed by the player if not prevented. This handle is answered before any part of the
            terrain is actually updated and can be used to trigger material-specific behaviors. </summary>
            <param name="GCoord">The coordinate in grid space of the entry that will be updated. It is guaranteed
            that the map entry at GCoord will be of the same material as the instance that recieves the update.</param>
            <param name="caller"> The entity responsible for removing the terrain. If the terrain is not being removed 
            by an entity this will be null </param>
            <returns>Whether or not to prevent the user from modifying the terrain. Also stops answering all
            calls to <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoving(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)"/> after this point. </returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.OnPlacing(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)">
            <summary> Called whenever the player is about to place the terrain; called for all the materials
            that will be placed by the player if not prevented. This handle is answered before any part of the
            terrain is actually updated and can be used to trigger material-specific behaviors. </summary>
            <param name="GCoord">The coordinate in grid space of the entry that will be updated. It is guaranteed
            that the map entry at GCoord will be of the same material as the instance that recieves the update.</param>
            <param name="caller"> The entity responsible for removing the terrain. If the terrain is not being removed 
            by an entity this will be null </param>
            <returns>Whether or not to prevent the user from modifying the terrain. Also stops answering all
            calls to <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnPlacing(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)"/> after this point. </returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> Called whenever the player is during the process of removing the terrain; called for all the materials
            that will be removed by the player. Importantly, this is answered <b>after</b> the material has been removed
            from the terrain. Also indicates what item should be given in return for removing this amount of this material </summary>
            <param name="GCoord">The coordinate in grid space of the entry that has been updated. It is guaranteed
            that the map entry at GCoord will be of the same material as the instance that recieves the update.</param>
            <param name="amount">The amount of material that was removed from the terrain</param>
            <returns> The item to be given to the caller through this action </returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.OnPlaced(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> Called whenever the player is during the process of placing the terrain; called for all the materials
            that are placed by the player. Importantly, this is answered for the new material states that are placed; if a previous 
            material(e.g. air) is replaced by a new material(e.g. dirt), this handle is answered only for the new material(dirt) 
            while <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnPlacing(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)"/> will be answered only for the old material(air)</summary>
            <param name="GCoord">The coordinate in grid space of the entry that has been updated. It is guaranteed
            that the map entry at GCoord will be of the same material as the instance that recieves the update.</param>
            <param name="amount">The amount of material that was added to the terrain</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.OnEntityTouchSolid(Arterra.Configuration.Generation.Entity.Entity)">
            <summary> Called whenever an entity touches the solid form of this material.
            Specifically, when an entity's collider overlaps a point that <see cref="P:Arterra.Core.Storage.MapData.IsSolid"/>
            and this material is the main contributor to that point's density </summary>
            <param name="entity">The entity that is touching the solid ground</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.OnEntityTouchLiquid(Arterra.Configuration.Generation.Entity.Entity)">
            <summary> Called whenever an entity touches the liquid form of this material.
            Specifically, when an entity's collider overlaps a point that <see cref="P:Arterra.Core.Storage.MapData.IsLiquid"/>
            and this material is the main contributor to that point's density </summary>
            <param name="entity">The entity that is touching the solid ground</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.ConstructMetaData(Unity.Mathematics.int3,Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor)">
            <summary>Called to generate material-specific meta data at the given location
            based on the specifications given within <paramref name="constructor"/> </summary>
            <param name="GCoord">The coordinate in grid space of the material which will be populated with meta data </param> 
            <param name="constructor">The <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor"/> containing settings dictating how meta data should be generated</param>
            <returns>A constructed meta-data instance that the material may expect to reference in the future.</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.SwapMaterial(Unity.Mathematics.int3,System.Int32,Arterra.Configuration.Generation.Item.IItem@,Arterra.Configuration.Generation.Entity.Entity)">
            <summary> A static utility function to swap a mapData's material with another material
            handling all the necessary handler calls to <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnPlacing(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)"/>, <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/>,
            etc., that this requires. </summary>
            <param name="GCoord">The coordinate in grid space of the mapEntry whose material is being swapped</param>
            <param name="newMaterial">The new material that is being put at this location</param>
            <param name="ReplacedItem"> The item produced as a result of removing the original material at this location 
            given for the caller to decide how to handle </param>
            <param name="caller">The caller who is making this request; given to material handles </param>
            <returns>Whether or not the material was successfully swapped.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.TerrainData">
            <summary>
            The apperance of the terrain when the material <see cref="P:Arterra.Core.Storage.MapData.IsSolid">is solid</see>. 
            When a material is solid, it will be under or adjacent to a mesh. If it is adjacent, the mesh will display the 
            material of the closest solid map entry with the apperance defined below.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.Texture">
            <summary>
            The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> Name Registry </see> of the name within the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Textures"/> registry,
            of the texture that is displayed when a mesh primitive is rendered with this material. This index must always refer to a valid texture if it can be solid.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.textureScale">
            <summary>
            The scale of the texture when it is drawn to the terrain. The scale difference between world space and 
            the UV space of the texture when it is being sampled. A larger value will result in a larger texture on the terrain.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.FlipStateRendering">
            <summary>
            Determines whether or not to reverse the rendering material for solids and liquids. If true(not 0)
            the material as a liquid will be rendered using opaque shading using settings from <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.TerrainData"/>
            and the material as a solid will be rendered using transparent shading using settings from <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.LiquidData"/>.
            This is especially useful for transparent geometry(like glass).
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderIndex">
            <summary> The information describing what type of <see cref="T:Arterra.Configuration.Quality.GeoShader"/> to render the current 
            material with if it is responsible for creating a mesh triangle. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo"/> for more info.</summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo">
            <summary> Information about how the material should be handled by <see cref="T:Arterra.Configuration.Quality.GeoShader">Geoshaders</see> which
            are responsible for an assortment of mildly performance intensive mesh-based visual effects. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo.data">
            <summary> The raw data described by these settings. This is the raw 
            compacted information recieved by the GPU </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo.MajorIndex">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> Name Registry </see> of the name within the external <see cref="F:Arterra.Configuration.Config.QualitySettings.GeoShaders"/> registry,
            of the geometry shader that is generated ontop of the mesh when it is solid. If the index is -1, no extra geoshader will be
            generated for this material. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo.MinorIndex">
            <summary> The index within the specific registry at the <see cref="P:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo.MajorIndex"/> within the <see cref="F:Arterra.Configuration.Config.QualitySettings.GeoShaders"/> registry
            containing variant settings describing how to generate/render the geoshader. Simply put, materials with the 
            same <see cref="P:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo.MajorIndex"/> utilize the same source logic during rendering/generation, but may possess 
            unique settings effecting each process. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Material.MaterialData.TerrainData.GeoShaderInfo.HasGeoShader">
            <summary> Whether or not the material possesses a geoshader and is processed by the geoshader system.
            If a material does not possess a geoshader, it is filtered out at an early stage 
            and does not tax the geoshader/rendering system.  </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.AtmosphericData">
            <summary>
            The apperance of the terrain when the material <see cref="P:Arterra.Core.Storage.MapData.IsGaseous">is gaseous</see>.
            A gaseous material will be rendered by the <see cref="T:AtmosphereBake">atmosphere </see> post process and must describe
            its optical interactions since light is permitted to pass through it. See <see href="https://blackmagic919.github.io/AboutMe/2024/09/07/Atmospheric-Scattering/">
            here </see> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.AtmosphericData.InScatterCoeffs">
            <summary>
            How much this gaseous material reflects light traveling through it towards the viewer. The channels, ordered rgb, and each describe how 
            much of that wavelength is reflected when light encounters the material. As light travels through the material,
            lower wavelengths will be more prominent with a thinner optical density (the amount of atmosphere the light travels through)
            while higher wavelengths will be more prominent with a thicker optical density.
            </summary> <remarks>as a percentage, between 0 and 1</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.AtmosphericData.OutScatterCoeffs">
            <summary>
            How much this gaseous material reflects light traveling through it away from the viewer. The channels, ordered rgb, and each describe how 
            much of that wavelength is reflected when light encounters the material.
            </summary> <remarks>as a percentage, between 0 and 1</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.AtmosphericData.GroundExtinction">
            <summary>
            When light travels from a surface fragment to the camera, how quickly the light is scattered away. Deescribes 
            how much of that wavelength is reflected away from the camera as light travels through it. A higher ground extinction
            will result in lower visibility of distant objects. 
            </summary> <remarks>as a percentage, between 0 and 1</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.AtmosphericData.LightIntensity">
            <summary>
            Controls how much light is emitted from this block as both a solid and liquid.
            Divided into 2 15 bit sections; 0x7FFF controls light emitted as a solid; 0x7FFF0000
            controls the light emitted as a liquid and gas. Each 15 bit section is divided into 3 
            5 bit regions, each controlling on a scale from 0->31 the intensity of the RGB channels.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.LiquidData">
            <summary>  The apperance of the terrain when the material <see cref="P:Arterra.Core.Storage.MapData.IsLiquid">is liquid</see>.
            A liquid material is under or adjacent to a seperate liquid mesh that displays the surface of the liquid terrain.
            If it is adjacent, the mesh will display the material of the closest liquid map entry with the apperance defined below.
            </summary> <remarks>If the liquid mesh borders the solid mesh, the liquid mesh will adopt the solid mesh's vertices</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.shallowCol">
            <summary> The color, ordered rgb, of the liquid as the view depth through it approaches zero. That is,
            as the depth of the liquid approaches zero relative to the viewer's perspective. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.deepCol">
            <summary> The color, ordered rgb, of the liquid as the view depth through it approaches infinity. That is,
            as the depth of the liquid approaches infinity relative to the viewer's perspective. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.colFalloff">
            <summary> How quickly does the color transition from <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.shallowCol"/> to <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.deepCol"/> as the
            depth increases. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.waveBlend">
            <summary> How large/coarse are the waves. Specifically, how much the waves are blended between a <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidCoarseWave">coarse</see> wave
            map and a <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidFineWave">fine</see> wave map. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.waveStrength">
            <summary> How noticeable are waves on the liquid's surface. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.waveScale">
            <summary> The scale of each wave map when they are sampled.  The x component describes the scale of <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidCoarseWave"/> while the y component
            describes the scale of <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidFineWave"/>. A smaller scale will result in larger features (zooming in) while a larger scale will result 
            in smaller features (zooming out). </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.LiquidData.waveSpeed">
            <summary>
            The speed at which the waves move across the liquid's surface. The x component describes the speed of the <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidCoarseWave"/> while the y component
            describes the speed of the <see cref="F:Arterra.Configuration.Generation.Material.Generation.liquidFineWave"/>. A higher speed will result in faster waves of that respective wave map.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter">
            <summary> An optional handler for most materials that handles how items
            are given in return for removing a specified amount of material
            depending on the state of the material removed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter.SolidItem">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the name within the external registry, 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/>, of the item to be given when the material is picked up when it is solid. 
            If the index does not point to a valid name (e.g. -1), no item will be picked up when the material is removed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter.LiquidItem">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the name within the external registry, 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/>, of the item to be given when the material is picked up when it is liquid. 
            If the index does not point to a valid name (e.g. -1), no item will be picked up when the material is removed. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter.LootItem(Arterra.Core.Storage.MapData@,System.Collections.Generic.List{System.String}@)">
            <summary>  Creates a generic item from map information of what has been removed. 
            This is the standard logic for item acquirement for most materials. Returns a 
            solid item if <see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/> is nonzero, a liquid material otherwise,
            or null if a suitable item cannot be found. </summary>
            <param name="mapData">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="Names">The <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> specific to the material
            holding this object. </param>
            <returns>The item that was created from this operation, or null.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor">
            <summary>Information determining how meta-data of a single 
            map data point is generated</summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor.Material">
            <summary> The index within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/> registry
            of the material with meta-data to place at the given offset from the structure's origin </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor.offset">
            <summary>The offset from the structure's origin to place the new material </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor.LootTable">
            <summary>The table consistenting of items to supply as map data.</summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor.ConfigSettings">
            <summary> Other config information that may be used depending on the type of meta data the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor.Material"/> expects. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter">
            <summary> An optional handler for materials which are capable of dropping
            multiple types of items on a probabilistic basis. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.SolidLootTable">
            <summary> The list of materials that can optionally be
            dropped if the material being removed is solid. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.DefaultSolidLoot">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the name within the external registry, 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/>, of the item to be given when the material is picked up when it is solid
            and no other material in <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.SolidLootTable"/> is selected. If the index does not point to a valid name 
            (e.g. -1), no item will be picked up when the material is removed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LiquidLootTable">
            <summary> The list of materials that can optionally be
            dropped if the material being removed is liquid. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.DefaultLiquidLoot">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the name within the external registry, 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/>, of the item to be given when the material is picked up when it is liquid
            and no other material in <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LiquidLootTable"/> is selected. If the index does not point to a valid name 
            (e.g. -1), no item will be picked up when the material is removed. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LootItem(Arterra.Core.Storage.MapData@,System.Collections.Generic.List{System.String}@)">
            <summary>  Creates a generic item from map information of what has been removed. 
            This is the standard logic for item acquirement for most materials. Returns a 
            solid item if <see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/> is nonzero, a liquid material otherwise,
            or null if a suitable item cannot be found. </summary>
            <param name="mapData">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="Names">The <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> specific to the material
            holding this object. </param>
            <returns>The item that was created from this operation, or null.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LootInfo">
            <summary> The settings describing an optional material that can be dropped
            and how often it should be dropped. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LootInfo.DropItem">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the name within the external registry, 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/>, of the item to be given when if the material is randomly selected.
            If the index does not point to a valid name (e.g. -1), no item will be picked up when the material is removed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LootInfo.DropChance">
            <summary> The chance the material is dropped. This is resampled 
            only once everytime any amount of material is removed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LootInfo.DropMultiplier">
            <summary> How much the material is multiplied by when it is dropped. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.DefaultLoot">
            <summary> Settings describing the default loot that is dropped when no other loot is selected.
            The only difference between this and the <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.LootInfo"/> is that it does not
            specify a drop chance as it will always be dropped if no other loot is dropped. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.DefaultLoot.DropItem">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the name within the external registry, 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"/>, of the item to be given when if the material is randomly selected.
            If the index does not point to a valid name (e.g. -1), no item will be picked up when the material is removed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter.DefaultLoot.DropMultiplier">
            <summary> How much the material is multiplied by when it is dropped. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialData.RetrieveKey(System.Int32)">
            <summary> Returns the registry entry's name of a registry reference coupled with the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names">name register</see> </summary>
            <param name="index">The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names">name register</see> of the name of the reference</param>
            <returns>The name of the reference in an external registry or null if a name for <paramref name="index"/> cannot be found. </returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MaterialInstance">
            <summary>
            A generic instance of a material at a given position. These are created
            to represent a material at one specific position and are not always persisted.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialInstance.Authoring">
            <summary>The material authoring controlling generic logic of the material.
            This is logic that does not require metadata and is applied to all materials </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MaterialInstance.position">
            <summary>The coordinate in grid space of this instance. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialInstance.GetRegistry">
            <summary> Obtains the material registry </summary>
            <returns>The material registry</returns>
        </member>
        <member name="P:Arterra.Configuration.Generation.Material.MaterialInstance.Index">
            <summary>The index within the material registry of this material.</summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialInstance.#ctor">
            <summary>Default Json Constructor</summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialInstance.#ctor(Unity.Mathematics.int3)">
            <summary>Sets up the material instance.</summary>
            <param name="GCoord">The position of the material</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MaterialInstance.#ctor(Unity.Mathematics.int3,System.Int32)">
            <summary>Sets up the material instance.</summary>
            <param name="GCoord">The position of the material</param>
            <param name="index">The index of the material type</param>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.GeoShaderIndexDrawer">
            <summary> A utility class to override serialization of <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.PointInfo"/> into a Unity Inspector format.
            It exposes the internal components of the bitmap so it can be more easily understood by the developer. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GeoShaderIndexDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to be rendered for the property. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GeoShaderIndexDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to know the height of the Inspector element. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.ConditionedDecayMat">
            <summary> A concrete material that will attempt to spread itself to neighboring entries 
            when and only when  randomly updated. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.ConditionedDecayMat.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.ConditionedDecayMat.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter"/> 
            for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.ConditionedDecayMat.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.GrassMaterial">
            <summary> A concrete material that will attempt to spread itself to neighboring entries 
            when and only when  randomly updated. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.GrassMaterial.SpreadChance">
            <summary> The chance that grass will spread to a neighboring entry. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.GrassMaterial.SpreadTag">
            <summary> The tag that must be present on the material for grass to spread to it.  
            The object associated with this tag in <see cref="T:TagRegistry"/> must be of type <see cref="!:ConvertableTag"/> </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GrassMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Random Material Update entry used to trigger grass growth. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GrassMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Mandatory callback for when grass is forcibly updated. Do nothing here. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.GrassMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.GrassMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.MultiLooter"/> 
            for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GrassMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.AquaticGrassMaterial">
            <summary>  A concrete material that will attempt to perform liquid physics when updated and
            will also attempt to spread grass to neighboring entries when randomly updated.
            See <see cref="T:Arterra.Configuration.Generation.Material.GrassMaterial"/> and <see cref="T:Arterra.Configuration.Generation.Material.LiquidMaterial"/> for more information 
            on how these two behaviors work. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.AquaticGrassMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Updates the liquid material to perform liquid physics. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material (a liquid material)</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.MortarMaterial">
            <summary> A mortar material which can crush items put into it to produced
            crushed variants. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MortarMaterial.DisplayIcon">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the 
            texture within the texture registry of the icon displayed on the <see cref="T:PanelNavbarManager">Navbar</see>
            referring to the Container.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MortarMaterial.MaxSlotCount">
            <summary> The maximum amount of  slots this mortar will have for smashing items. Includes both inputs and outputs </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MortarMaterial.MaxRecipeSlotCount">
            <summary> The maximum amount of formulas to display in the help menu </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MortarMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MortarMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MortarMaterial.ConstructMetaData(Unity.Mathematics.int3,Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor)">
            <summary>Returns a mortar inventory created using the meta constructor.</summary>
            <param name="GCoord">The coordinate in grid space of the material</param>
            <param name="constructor">The constructor used to populate the inventory</param>
            <returns>The container instance</returns>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.MortarMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.MortarMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See 
            <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter"/> for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.MortarMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.PlaceableStructureMat.randYRot">
            <summary> Whether or not placement of the structure may include random rotations around the vertical-axis. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.PlaceableStructureMat.randXRot">
            <summary> Whether or not placement of the structure may include random rotations around the major horizontal-axis. The horizontal
            axis that it is rotated upon may shift depending on the <see cref="F:Arterra.Configuration.Generation.Material.PlaceableStructureMat.randYRot"/>.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.PlaceableStructureMat.randZRot">
            <summary> Whether or not placement of the structure may include random rotations around the minor horizontal-axis. The horizontal
            axis that it is rotated upon may shift depending on the <see cref="F:Arterra.Configuration.Generation.Material.PlaceableStructureMat.randYRot"/> and <see cref="F:Arterra.Configuration.Generation.Material.PlaceableStructureMat.randXRot"/>.  </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.FurnaceMaterial">
            <summary> A furnace material which can hold fuel items, input items and output items in its meta-data
            and is accessible to users who click on the item. 
            A furnace is a type of container that can burn fuel items to smelt items and store the resulting output items. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.DisplayIcon">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the 
            texture within the texture registry of the icon displayed on the <see cref="T:PanelNavbarManager">Navbar</see>
            referring to the Container.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.FuelTag">
            <summary> The tag that must be present on the material for furnace to use it as fuel.  
            The object associated with this tag in <see cref="T:TagRegistry"/> must be of type <see cref="!:ConvertableTag"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.LitFurnaceMaterial">
            <summary> The name of the material that will be swapped with the current material
            when the furnace enters a "lit" state, this new material can be used to give a glowing effect  </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.UnlitFurnaceMaterial">
            <summary> The name of the material that will be swapped with the current material
            when the furnace enters an "unlit" state, this should generally be the base material  </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.MaxInputSlotCount">
            <summary> The maximum amount of item slots this furnace will have for Input items </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.MaxOutputSlotCount">
            <summary> The maximum amount of item slots this furnace will have for Output items </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.MaxFuelSlotCount">
            <summary> The maximum amount of item slots this furnace will have for Fuel items </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.MaxRecipeSlotCount">
            <summary> The maximum amount of formulas to display in the help menu </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.FurnaceMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.FurnaceMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.FurnaceMaterial.ConstructMetaData(Unity.Mathematics.int3,Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor)">
            <summary>Returns a furnace inventory created using the meta constructor.</summary>
            <param name="GCoord">The coordinate in grid space of the material</param>
            <param name="constructor">The constructor used to populate the inventory</param>
            <returns>The container instance</returns>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FurnaceMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.FurnaceMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See 
            <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter"/> for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.FurnaceMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.FireMaterial">
            <summary> A concrete material that will attempt to spread itself to neighboring entries 
            when and only when  randomly updated. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FireMaterial.SpreadChance">
            <summary> The chance that grass will spread to a neighboring entry. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FireMaterial.SpreadTag">
            <summary> The tag that must be present on the material for grass to spread to it.  
            The object associated with this tag in <see cref="T:TagRegistry"/> must be of type <see cref="T:ConverterToolTag"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.FireMaterial.ContactDamage">
            <summary>The amount of damage an entity will recieve if it touches this material</summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.FireMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Random Material Update entry used to trigger grass growth. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.LiquidMaterial">
            <summary>
            A concrete material that will attempt to perform liquid physics when updated. Liquid physics
            simulate how liquids flow using a small set of specific rules.
            <list type="number">
            <item> A liquid will try to move from the update entry to the entry below it if it can. </item>
            <item> Liquid above the update entry will try to move to the update entry if it can. </item>
            <item> Liquid around the update entry will try to average out the liquid levels with the update entry if it can </item>
            <item> A neighboring entry will only be updated if the state of the entry changes </item>
            <item> A liquid can move between two entries if the entry it is moving to is gaseous, or if both entries are the same material </item>
            </list>
            This is the default behavior liquids use to emulate liquid physics. If left unchecked, the propogation of liquid
            physics will eventually be ratelimited by <see cref="F:Arterra.Configuration.Intrinsic.TerrainUpdation.MaximumTickUpdates"> the maximum 
            amount of updates </see> defined by the system at which point liquid physics may prevent other terrain updates from occuring.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.LiquidMaterial.RandomUpdatePropogateChance">
            <summary> The chance that a random update will perform checks to 
            propogate the liquid. Increasing this value may reduce performance. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.LiquidMaterial.PropogateLiquid(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Updates the liquid material to perform liquid physics. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material (a liquid material)</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.LiquidMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Mandatory Random Update callback called randomly. Use this to trigger random water propogations </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.LiquidMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Updates the liquid material to perform liquid physics.  </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.LiquidMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.LiquidMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See 
            <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter"/> for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.LiquidMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.GenericMaterial">
            <summary> A concrete material type with no explicit interaction behavior. That is,
            it does not need to do anything when updated. By default most materials
            should not need to do anything. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GenericMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GenericMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.GenericMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.GenericMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See 
            <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter"/> for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.GenericMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Material.ContainerMaterial">
            <summary> A container material which can hold items in its meta-data
            and is accessible to users who click on the item. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.ContainerMaterial.DisplayIcon">
            <summary> The index within the <see cref="F:Arterra.Configuration.Generation.Material.MaterialData.Names"> name registry </see> of the 
            texture within the texture registry of the icon displayed on the <see cref="T:PanelNavbarManager">Navbar</see>
            referring to the Container.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.ContainerMaterial.MaxSlotCount">
            <summary> The maximum amount of item slots this container will have
            if it is at maximum density. The actual amount of slots will scale between
            one and this depending on how dense the material is.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.ContainerMaterial.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.ContainerMaterial.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)">
            <summary> Even though it does nothing, it needs to fufill the contract so
            that it can be used in the same way as other materials. </summary>
            <param name="GCoord">The coordinate in grid space of a map entry that is this material</param>
            <param name="prng">Optional per-thread pseudo-random seed, to use for randomized behaviors</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.ContainerMaterial.ConstructMetaData(Unity.Mathematics.int3,Arterra.Configuration.Generation.Material.MaterialData.MetaConstructor)">
            <summary>Returns a container inventory created using the meta constructor.</summary>
            <param name="GCoord">The coordinate in grid space of the material</param>
            <param name="constructor">The constructor used to populate the inventory</param>
            <returns>The container instance</returns>
        </member>
        <member name="F:Arterra.Configuration.Generation.Material.ContainerMaterial.MaterialDrops">
            <summary> The handler controlling how materials are dropped when
            <see cref="M:Arterra.Configuration.Generation.Material.ContainerMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> is called. See 
            <see cref="T:Arterra.Configuration.Generation.Material.MaterialData.ItemLooter"/> for more info.  </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Material.ContainerMaterial.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)">
            <summary> See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoved(Unity.Mathematics.int3,Arterra.Core.Storage.MapData@)"/> for more information. </summary>
            <param name="amount">The map data indicating the amount of material removed
            and the state it was removed as</param>
            <param name="GCoord">The location of the map information being</param>
            <returns>The item to give.</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.Generation">
            <summary>
            A settings container identifying all biomes and biome related settings 
            that are used during generation. Biomes are placed depending on conditions 
            describing the shape of the terrain <see cref="T:Arterra.Configuration.Generation.Biome.IBiomeCondition"/> and control 
            aspects of the world during structure, entity, and material generation.
            </summary> <remarks><b> 
            In the case that the sample space is not fully covered by the condition bounds defined within
            a Biome registry, the first biome within the registry will be placed if no biome can be resolved </b></remarks> 
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Generation.SurfaceBiomes">
            <summary> The registry containing all surface biomes that can be generated.
            Surface biomes have their unique selection space and only need to not overlap
            other surface biomes within <see cref="F:Arterra.Configuration.Generation.Biome.Generation.SurfaceBiomes"/>. <seealso cref="T:Arterra.Configuration.Generation.Biome.SBiomeInfo"/> </summary> 
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Generation.SeafloorBiomes">
            <summary> The registry containing all seafloor biomes that can be generated.
            Seafloor biomes are biomes that generate on the seafloor and can pick where to generate
            based on the features of the seafloor. Importantly, seafloor biomes may not span all query space,
            and if no seafloor biome is selected, the biome is instead decided by the <see cref="F:Arterra.Configuration.Generation.Biome.Generation.SeaBiomes"/>. </summary> 
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Generation.CaveBiomes">
            <summary>
            The registry containing all cave biomes that can be generated.
            Cave biomes generate underneath the surface of the world and have their unique
            selection space. Cave biomes only need to not overlap other cave biomes within
            <see cref="F:Arterra.Configuration.Generation.Biome.Generation.CaveBiomes"/>. <seealso cref="T:Arterra.Configuration.Generation.Biome.CBiomeInfo"/>
            </summary> <remarks> Cave biomes can be used to create different cave formations, mineral placement,
            or underground biomes independent of what the surface biome is. </remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Generation.SkyBiomes">
            <summary>
            The registry containing all sky biomes that can be generated.
            Sky biomes generate above the surface of the world and have their unique sample
            space. Sky biomes only need to not overlap other sky biomes within <see cref="F:Arterra.Configuration.Generation.Biome.Generation.SkyBiomes"/>.
            </summary>  <remarks> Sky biomes can be used to create different cloud patterns, weather or effects in the 
            sky independently of what the surface biome is. </remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Generation.SeaBiomes">
            <summary> The registry containing all sky biomes that can be generated.
            Sea biomes generate only between an underwater seafloor and the ocean's
            water surface. Seabiomes may be overwritten by <see cref="F:Arterra.Configuration.Generation.Biome.Generation.SeafloorBiomes"/> 
            and only need to not overlap with other sea biomes </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.BDict">
            <summary>
            The decision matrix constructed from a biome registry that facilitates lookup of biomes.
            More exactly, it is an R-Tree containing biomes within its leaf nodes that allows a 
            biome to be matched with a specific set of conditions in O(log(n)) time where n is
            the number of biomes within the registry. 
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.BDict.Create``1(System.Collections.Generic.List{Arterra.Configuration.Generation.Biome.CInfo{``0}},System.Int32)">
            <summary> Constructs a decision matrix from a list of biome conditions. </summary>
            <typeparam name="TCond">The type of biome condition used in the decision matrix. </typeparam>
            <param name="biomes">The registry's biomes that define the leaf nodes of the decision matrix </param>
            <param name="offset">The offset of biome indices if the biomes are not zero-indexed relative to the registry</param>
            <returns>The constructed decision matrix</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.BDict.FlattenTree``1">
            <summary>
            Obtains a flattened array of biome conditions that represents the decision matrix. Normally the decision matrix
            is a reference tree splayed across memory. This method collapses the tree into a single array using binary
            tree indexing to determine hierarchical relations. The size of this flattened tree is equal to 
            2^(h+1) - 1 where h is the next highest power of 2 of the number of leaf nodes in the tree.
            </summary>
            <typeparam name="TCond">The type of bioem condition used to flatten the tree. This should be the same as
            was used when <see cref="M:Arterra.Configuration.Generation.Biome.BDict.Create``1(System.Collections.Generic.List{Arterra.Configuration.Generation.Biome.CInfo{``0}},System.Int32)">creating</see> the tree. </typeparam>
            <returns>The flattened array of biome conditions representing the decision matrix</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.BDict.Query(System.Single[])">
            <summary>
            Queries the R-Tree for the biome that matches the given parameters. The parameters
            must be given in the same order that they are <see cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.SetNode(Arterra.Configuration.Generation.Biome.BDict.RegionBound,System.Int32)">
            provided</see> when constructing the R-Tree.
            </summary> <param name="point">A list of parameters pertaining to each respective condition</param>
            <returns>The index within the registry used to construct the decision matrix of the biome. -1 if 
            no biome is able to be found. </returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.BDict.RegionBound">
            <summary>
            A region bound that describes a list of ranges, each representing a seperate
            dimension in the sample space. It is a more generalized form of representing
            conditions of a <see cref="T:Arterra.Configuration.Generation.Biome.IBiomeCondition"> concrete biome type </see> that
            allows for the construction of Decision Matricies of varying dimensions.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.BDict.RegionBound.maxCorner">
            <summary>
            The maximum bound of each dimension for the region within sample space.
            Equaivalently, the coordinate of the maximum corner of the cuboid region.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.BDict.RegionBound.minCorner">
            <summary>
            The minimum bound of each dimension for the region within sample space.
            Equaivalently, the coordinate of the minimum corner of the cuboid region.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.SBiomeInfo">
            <summary>
            The settings describing the generation of one surface biome. A surface biome 
            controls generation for a thin layer immediately around the surface of the world.
            Information regarding generation dictated by the biome is stored within <see cref="T:Arterra.Configuration.Generation.Biome.Info"/> 
            while information regarding its placement can be found in <see cref="T:Arterra.Configuration.Generation.Biome.SurfaceBiome"/>. 
            </summary> 
            <remarks>This class defines a concrete implementation of <see cref="T:Arterra.Configuration.Generation.Biome.CInfo`1"/> so 
            that its contents can be serialized by Unity.</remarks>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.SurfaceBiome">
            <summary>
            The placement conditions for a <see cref="T:Arterra.Configuration.Generation.Biome.SBiomeInfo">surface biome</see>. The aggregate
            conditions define a cuboid region within a 6D sample space, or all possible values for
            6 different noise parameters each bounded between the range 0 to 1. 
            See <seealso href="https://blackmagic919.github.io/AboutMe/2024/08/10/Biomes/#/Decision-Matrix">
            here</seealso> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.TerrainStart">
            <summary> The lower bound of the surface height that this biome can generate in. The surface height is
            determined by noise maps identified in <see cref="T:Arterra.Configuration.Generation.Surface"/>, where the range is remapped from 
            0 to <see cref="F:Arterra.Configuration.Generation.Surface.MaxTerrainHeight"/> to 0 to 1. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.ErosionStart">
            <summary> The lower bound on the erosion intensity that this biome can generate in. That is the value of erosion <b>before</b>
            it is interpolated through an <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in identifying how interpolation
            will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Surface.ErosionNoise"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.SquashStart">
            <summary> The lower bound on the squash intensity that this biome can generate in. That is the value of the squash map <b>before</b>
            it is interpolated through an <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in identifying how interpolation
            will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Surface.SquashNoise"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.InfluenceStart">
            <summary> The lower bound on the influence height that this biome can generate in. That is the height of the surface biome influences generation
            <b>before</b> it is interpolated through the <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in identifying how interpolation
            will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Surface.InfHeightNoise"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.InfluenceOffStart">
            <summary> The lower bound on the Influence Offset that this biome can generate in. That is the offset relative to the terrain's surface
            of the Influence's range <b>before</b> it is interpolated through the <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in 
            identifying how interpolation will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Surface.InfOffsetNoise"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.AtmosphereStart">
            <summary> The lower bound on the Atmosphere Falloff intensity that this biome can generate in. That is the Intensity density falls off as height 
            increases above the terrain's surface <b>before</b> it is interpolated through the <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in 
            identifying how interpolation will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Surface.InfOffsetNoise"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.TerrainEnd">
            <summary>  The upper bound of the surface height that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.TerrainStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.ErosionEnd">
            <summary> The upper bound on the erosion intensity that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.ErosionStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.SquashEnd">
            <summary> The upper bound on the squash intensity that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.SquashStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.InfluenceEnd">
            <summary> The upper bound on the influence height that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.InfluenceStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.InfluenceOffEnd">
            <summary> The upper bound on the Influence Offset that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.InfluenceOffStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.AtmosphereEnd">
            <summary>  The upper bound on the Atmosphere Falloff intensity that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.AtmosphereStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.biome">
            <exclude><remarks> This is an internal pointer to the biome's generation information that is populated by the <see cref="T:Arterra.Configuration.Generation.Biome.BDict"/> </remarks> </exclude>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.SurfaceBiome.GetDimensions">
            <summary> See <seealso cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.GetDimensions"/> for more info </summary>
            <returns> The number of conditions that a surface biome consideres when being placed. 
            This number is always 6 for a surface biome. </returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.SurfaceBiome.GetBoundDimension(Arterra.Configuration.Generation.Biome.BDict.RegionBound@)">
            <summary> See <seealso cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.GetBoundDimension(Arterra.Configuration.Generation.Biome.BDict.RegionBound@)"/> for more info </summary>
            <param name="bound">The RegionBound whose dimensions are set in-order from the conditions
            stored within the <see cref="T:Arterra.Configuration.Generation.Biome.SurfaceBiome"/>. </param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.SurfaceBiome.SetNode(Arterra.Configuration.Generation.Biome.BDict.RegionBound,System.Int32)">
            <summary> <seealso cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.SetNode(Arterra.Configuration.Generation.Biome.BDict.RegionBound,System.Int32)">See Here</seealso> </summary>
            <param name="bound">The region bound which stores the in-order dimensions that describe
            the bounds of conditions within the <see cref="T:Arterra.Configuration.Generation.Biome.SurfaceBiome"/> which are set respectively </param>
            <param name="biome"></param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.SurfaceBiome.Validate">
            <summary> Asserts that the lower bounds of biomes are less than the upper bounds. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.CInfo`1">
            <summary>
            A template class which defines placement conditions for a biome. Because 
            each biome has a different set of conditions, but also must always defines those
            conditions, this is just a shorthand way of guaranteeing that.
            </summary> <typeparam name="TCond">The set of conditions that describe the placement of the biome.
            See <see cref="T:Arterra.Configuration.Generation.Biome.IBiomeCondition"/> for more information. </typeparam>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CInfo`1.info">
            <summary> Generic setting shared by all biomes, see <see cref="T:Arterra.Configuration.Generation.Biome.Info"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CInfo`1.BiomeConditions">
            <summary> The conditions that define the placement of the biome. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.CInfo`1.OnValidate">
            <summary> This method is called when the object is changed in Unity's editor. It ensures that the conditions
            describe a valid region within the decision matrix. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.Info">
            <summary>
            The settings detailing all generation aspects controlled by a biome. All biomes
            must always define these aspects as each respective system needs to know what to do
            if a specific biome is encountered. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.Names">
            <summary>
            The registry names of all entries referencing registries within <see cref="T:Arterra.Configuration.Generation.Biome.Info"/>. When an element such as
            a material, structure, or entry needs to reference an entry in an external registry, they can indicate the index
            within this list of the name of the entry within the registry that they are referencing. This allows for the biome
            module to be decoupled from the rest of the world's configuration. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.GroundMaterials">
            <summary> A list containing the generation pattern of solid materials within the biome. This list is considered
            only if the density of the map entry is greater than <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/>(i.e. undeground).
            </summary> <remarks> When considered, all materials within the list will attempt to be placed, meaning the time 
            complexity of material assignment is O(n) with respect to the number of materials in the list.</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.SurfaceMaterials">
            <summary> A list containing the generation pattern of non-solid materials within the biome. This list is considered
            only if the density of the map entry is less than <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/>(i.e. above ground).
            </summary> <remarks> When considered, all materials within the list will attempt to be placed, meaning the time 
            complexity of material assignment is O(n) with respect to the number of materials in the list.</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.LiquidMaterials">
            <summary>
            A list containing the generation pattern of liquid materials within the biome. This list is considered
            when the density of the map entry is less than <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/>(i.e. above ground)
            and the point lies above the terrain surface and below the global water level, see <see cref="!:Generation.Map.waterHeight"/>
            for more information.</summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.Structures">
            <summary> A list containing all structures that will attempt to generate within the biome. Anything terrain feature
            not a result of noise based generation should naturally be created through a structure. <see cref="N:Arterra.Configuration.Generation.Structure"/> 
            for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.Entities">
            <summary>
            A list containing all entites that will attempt to generate within the biome. Unlike structures and materials,
            entities will only be generate if the chunk is being generated for the first time <b>ever</b> since the world first
            was created. Otherwise, entities will be loaded from an entity chunk file. 
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Biome.Info.StructureSerial">
            <summary> A getter property that deserializes all structures by recoupling them with the current world's configuration. This involves
            retrieving the real indices of the structures within the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Structures"/> registry. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Biome.Info.EntitySerial">
            <summary> A getter property that deserializes all entities by recoupling them with the current world's configuration. This involves
            retrieving the real indices of the entities within the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"/> registry. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.Info.MaterialSerial(System.Collections.Generic.List{Arterra.Configuration.Option{Arterra.Configuration.Generation.Biome.Info.BMaterial}})">
            <summary>
            Retrieves the deserialized version of a list of materials that are coupled through a reference to the <see cref="F:Arterra.Configuration.Generation.Biome.Info.Names"/> 
            by recoupling them with the current world's configuration. This involves retrieving the real indices 
            of the materials within the external external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/> registry.
            </summary>
            <param name="Materials">The list of materials that are coupled with <see cref="F:Arterra.Configuration.Generation.Biome.Info.Names"/> that is to be decoupled. This is either 
            <see cref="F:Arterra.Configuration.Generation.Biome.Info.GroundMaterials"/> or <see cref="F:Arterra.Configuration.Generation.Biome.Info.SurfaceMaterials"/>. </param>
            <returns>An ordered collection of the recoupled with the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/> registry</returns>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.Info.BMaterial">
            <summary>
            The settings for the generation pattern of a single material within a biome. 
            Each BMaterial describes a list of preferences, and the material placed is determined
            by the material with the closest match to its desired preference. This exact layout
            is copied to the GPU and used to generate the terrain.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.Material">
            <summary> The index of the name of the material within the <see cref="F:Arterra.Configuration.Generation.Biome.Info.Names"/>.
            Once recoupled, this will point to the real index within the external 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/> registry. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.genSize">
            <summary>
            The preferred material size that the material should be generated at. The material size
            blends between the match closeness of <see cref="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.genShape"/> with <see cref="F:Arterra.Configuration.Generation.Map.CoarseMaterialNoise"/>
            and <see cref="F:Arterra.Configuration.Generation.Map.FineMaterialNoise"/> respectively.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.genShape">
            <summary>
            The preferred shape of the material. The match closeness of the material is determined by the 
            distance of the noise parameter <see cref="F:Arterra.Configuration.Generation.Map.CoarseMaterialNoise"/> or <see cref="F:Arterra.Configuration.Generation.Map.FineMaterialNoise"/> to
            the value of <see cref="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.genShape"/>.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.frequency">
            <summary>
            The frequency of the material. This is used to falloff the match closeness such that a frequency
            of 0 will result in a match closeness of 0 for all noise values (meaning it is never placed), 
            and a frequency of 1 will result in a linear match closeness.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.height">
            <summary>
            If the biome is a <see cref="T:Arterra.Configuration.Generation.Biome.SBiomeInfo"/>, describes the preferred height relative to the influence range
            that the material should be generated at. An influence height of 0 will result in the material being generated
            on the surface while an influence height of 1 will result in the material being generated at either the top or
            bottom of the biome depending on whether it's a <see cref="F:Arterra.Configuration.Generation.Biome.Info.SurfaceMaterials">surface</see> or <see cref="F:Arterra.Configuration.Generation.Biome.Info.GroundMaterials">ground</see> material.
            If the biome is a <see cref="T:Arterra.Configuration.Generation.Biome.CBiomeInfo"/>, this value is ignored.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.Info.TerrainStructure">
            <summary> The settings for the generation pattern of a single structure within a biome. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.TerrainStructure.ChancePerStructurePoint">
            <summary> The chance that a randomly sampled point chooses to generate the current structure. The total number
            of points sampled per chunk is determined by the <see cref="!:Generation.Structure.Generation.StructureChecksPerChunk"/>.
            </summary> 
            <remarks>This chance is <b>dependent</b> on the chance of previous entries before it within <see cref="F:Arterra.Configuration.Generation.Biome.Info.Structures"/>.
            If the first structure's <see cref="F:Arterra.Configuration.Generation.Biome.Info.TerrainStructure.ChancePerStructurePoint"/> is 1 (100%), then no other structures will be able to 
            generate as all structure points will attempt to place the first structure. </remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.TerrainStructure.Structure">
            <summary> The index of the name within the <see cref="F:Arterra.Configuration.Generation.Biome.Info.Names"/>, of the structure within 
            the external registry <see cref="F:Arterra.Configuration.Config.GenerationSettings.Structures"/> </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.Info.EntityGen">
            <summary> The settings for the generation pattern of a single entity within a biome. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.EntityGen.Entity">
            <summary> The index of the name within the <see cref="F:Arterra.Configuration.Generation.Biome.Info.Names"/>, of the entity within 
            the external registry <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.Info.EntityGen.ChancePerCoord">
            <summary> The chance that the entity will be spawned at a given coordinate <b>for every coordinate</b> it
            can generate at within a chunk. Whether an entity can generate at a coodrinate is determined by
            the <see cref="!:ProfileE">profile</see> of the entity. </summary>
            <remarks>It is recommended that this is a very small number as it is possible for an extremely large
            amount of coordinates to match the entity's <see cref="!:ProfileE">profile</see>. </remarks>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.IBiomeCondition">
            <summary>
            An interface for all biome conditions to easily translate it between a <see cref="T:Arterra.Configuration.Generation.Biome.CInfo`1">concrete
            field </see> and a <see cref="T:Arterra.Configuration.Generation.Biome.BDict.RegionBound"> general dimension </see>. This is so the same logic
            can be reused to construct the decision matrix regardless of the biome conditions.
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.GetDimensions">
            <summary> obtains the number of conditions a biome's placement requires. Equivalently, 
            the number of dimensions of the sample space of the decision matrix. </summary>
            <returns>The number of dimensions of the sample space</returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.GetBoundDimension(Arterra.Configuration.Generation.Biome.BDict.RegionBound@)">
            <summary> Copies a biome's conditions into a more <see cref="T:Arterra.Configuration.Generation.Biome.BDict.RegionBound">general</see> dimension list. </summary>
            <param name="bound">The bound that recieves the conditions of the concret biome condition</param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.SetNode(Arterra.Configuration.Generation.Biome.BDict.RegionBound,System.Int32)">
            <summary>
            Sets the concrete biome condition to the values prescribed by the region bound and the biome index.
            The conditions should be retrieved from the <paramref name="bound"/> in same order they are set within <see cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.GetBoundDimension(Arterra.Configuration.Generation.Biome.BDict.RegionBound@)"/>.
            </summary>
            <param name="bound">The bound that contains a list of ranges corresponding to the biome's conditions </param>
            <param name="biome">The index of the biome within the original registry used to construct the decision matrix.
            This value is -1 if it is an intermediate internal node used to facilitate lookup. </param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.Validate">
            <summary> Validates the biome conditions to ensure that they are valid bounds within the decision matrix. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.CBiomeInfo">
            <summary>
            The settings describing the generation of one cave biome. Cave biomes control generation for all space apart from 
            the surface of the world. Contrary to what its name implies, cave biomes define generation for both 
            <see cref="!:GenerationData.SkyBiomes"/> and <see cref="!:GenerationData.CaveBiomes"/>, however, each container
            ensures that all of its contents will only generate above or below the surface respectively. Information 
            regarding generation dictated by the biome is stored within <see cref="T:Arterra.Configuration.Generation.Biome.Info"/> while information regarding its placement 
            can be found in <see cref="T:Arterra.Configuration.Generation.Biome.CaveBiome"/>.
            </summary>
            <remarks>This class defines a concrete implementation of <see cref="T:Arterra.Configuration.Generation.Biome.CInfo`1"/> so 
            that its contents can be serialized by Unity.</remarks>
        </member>
        <member name="T:Arterra.Configuration.Generation.Biome.CaveBiome">
            <summary>
            The placement conditions for a <see cref="T:Arterra.Configuration.Generation.Biome.CBiomeInfo">cave biome</see>. The aggregate
            conditions define a cuboid region within a 4D sample space, or all possible values for
            4 different noise parameters each bounded between the range 0 to 1. See 
            <seealso href="https://blackmagic919.github.io/AboutMe/2024/08/10/Biomes/#/Decision-Matrix">
            here</seealso> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveFreqStart">
            <summary> The lower bound on cave frequency that this biome can generate in. That is noise parameter determining the size of caves 
            <b>before</b> it is interpolated through an <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in identifying how interpolation
            will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Map.CaveFrequencyNoise"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveSizeStart">
            <summary> The lower bound on cave size that this biome can generate in. That is the noise parameter determining the size of caves 
            <b>before</b> it is interpolated through an <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in identifying how interpolation
            will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveShapeStart">
            <summary> The lower bound on cave shape that this biome can generate in. That is the noise parameter determining the shape of caves 
            <b>before</b> it is interpolated through an <see cref="F:Arterra.Configuration.Generation.Noise.interpolation"/> curve, which is useful in identifying how interpolation
            will affect the map in its immediate vicinity. See <seealso cref="F:Arterra.Configuration.Generation.Map.CaveShapeNoise"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.HeightStart">
            <summary> The lower bound on surface distance that this biome can generate in. That is the distance from the surface of the map entry
            rescaled through an exponential function (see <seealso cref="F:Arterra.Configuration.Generation.Map.heightFalloff"/> which approaches 1 as distance approaches
            infinity. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveFreqEnd">
            <summary> The upper bound on cave frequency that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveFreqStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveSizeEnd">
            <summary> The upper bound on cave size that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveSizeStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveShapeEnd">
            <summary> The upper bound on cave shape that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.CaveBiome.CaveShapeStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.HeightEnd">
            <summary> The upper bound on surface distance that this biome can generate in. See <seealso cref="F:Arterra.Configuration.Generation.Biome.CaveBiome.HeightStart"/> for more info </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Biome.CaveBiome.biome">
            <exclude><remarks> This is an internal pointer to the biome's generation information that is populated by the <see cref="T:Arterra.Configuration.Generation.Biome.BDict"/> </remarks> </exclude>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.CaveBiome.GetDimensions">
            <summary> See <seealso cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.GetDimensions"/> for more info </summary>
            <returns> The number of conditions that a cave biome consideres when being placed. 
            This number is always 4 for a cave biome. </returns>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.CaveBiome.GetBoundDimension(Arterra.Configuration.Generation.Biome.BDict.RegionBound@)">
            <summary> See <seealso cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.GetBoundDimension(Arterra.Configuration.Generation.Biome.BDict.RegionBound@)"/> for more info </summary>
            <param name="bound">The RegionBound whose dimensions are set in-order from the conditions
            stored within the <see cref="T:Arterra.Configuration.Generation.Biome.CaveBiome"/>. </param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.CaveBiome.SetNode(Arterra.Configuration.Generation.Biome.BDict.RegionBound,System.Int32)">
            <summary> <seealso cref="M:Arterra.Configuration.Generation.Biome.IBiomeCondition.SetNode(Arterra.Configuration.Generation.Biome.BDict.RegionBound,System.Int32)">See Here</seealso> </summary>
            <param name="bound">The region bound which stores the in-order dimensions that describe
            the bounds of conditions within the <see cref="T:Arterra.Configuration.Generation.Biome.CaveBiome"/> which are set respectively </param>
            <param name="biome"></param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Biome.CaveBiome.Validate">
            <summary> Asserts that the lower bounds of biomes are less than the upper bounds. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Noise">
            <summary>
            Noise Data contains settings which defines a distinct noise sampler function, which,
            sampled across all space, creates a unique noise map that is processed and layered
            together to generate the procedural terrain. 
            <seealso href="https://blackmagic919.github.io/AboutMe/2024/07/13/Noise-Generation/"/>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Noise.noiseScale">
            <summary>
            The scale of the noise map relative to grid space; how much the noise varies as the sample point moves.
            A smaller noise scale will result in smaller features while (zooming out), and a larger noise scale will result
            in comparatively larger terrain features (zooming in).
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Noise.octaves">
            <summary>
            The amount of simple noise samples that are layered together to create the final noise map. A simple noise 
            sample is a single call to 3D Simplex Noise. Layering simple noise maps can create more complex noise maps
            with both large and small features.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Noise.persistance">
            <summary>
            The influence strength of the noise output of each proceeding octave relative to the previous octave. 
            Persistance should be less than 1 such that the amplitude of each octave decreases creating less and less noticeable features.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Noise.lacunarity">
            <summary>
            The inverse sample scale of each noise octave relative to the preivous octave. As lacunarity increases, the distance
            between samples increases, creating smaller features in the output map. Lacunarity should be greater than 1 such that
            the frequency(inverse scale) of each octave increases creating more smaller and smaller features.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Noise.seedOffset">
            <summary>
            The seed offset that is added to the global seed to create a unique noise map. This allows for the generation of
            multiple noise maps anchored by the same global seed. Two noise maps with the same seed offset
            will sample an identical noise map (but at different scales/offsets).
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Noise.interpolation">
            <summary>
            The interpolation curve that is used to transform the sampled output of the noise function. Transforms a noise value
            from the range 0 to 1 to the same range. By modifying the curve, one can create localized regions of generation
            that conform to a specific shape or pattern. 
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Noise.SplineKeys">
            <summary>
            The list of control points defining a 2D bezier curve that transforms a value from the x-axis to the y-axis.
            Each control point is a 4D vector describing its 2D coordinate followed by its tangent coming in and out of the point.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Noise.OctaveOffsets">
            <summary>
            The list of offsets that each octave samples noise from. Given the same seed offset and global seed, 
            the same list of offsets will be generated. By default offsets are 3D coordinates, 
            but lower dimensions may use fewer components of the vector.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Entity.Authoring">
            <summary>
            A generic contract that ensures that all entities contain a certain
            set of properties and methods necessary for the system to function.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Authoring.Entity">
            <summary> A reference to the entity that contains the actual instance of the entity. See <see cref="P:Arterra.Configuration.Generation.Entity.Authoring.Entity"/> for more information</summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Authoring.Setting">
            <summary> A reference to the readonly shared settings that all instances of this entity uses. See <see cref="T:Arterra.Configuration.Generation.Entity.EntitySetting"/> for more information</summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.Authoring.Controller">
            <summary> A reference to the controller responsible for displaying the entity. The controller is the visual gameobject
            representing the entity whose display is managed by Unity. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.Authoring.Profile">
            <summary> A list of points defining the profile of the entity, the list is linearly encoded through the dimensions
            specified in <see cref="T:Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo"/>. See <see cref="T:Arterra.Configuration.Generation.Entity.ProfileE"/> for more information </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Entity.Entity">
            <summary>
            A generic entity that defines a virtual function table that all entities must implement,
            as well as some metadata used by the system to manage the entity. All entities in the game
            must inherit from this class and implement the virtual functions to be used by the system.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.Entity.info">
            <summary> Information about the entity instance that is required of every instance for the system to function. See <see cref="T:Arterra.Configuration.Generation.Entity.Entity.Info"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.Entity.active">
            <summary> Whether or not the entity is active. This is the flag set to indicate to the system that
            the entity has been released. Once this flag is set to false, it cannot be set to true without risking race
            conditions and undefined behavior. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.Entity.Update">
            <summary> The entity's virtual update function. This will be called every game tick within a Unity Job to 
            perform computational-heavy tasks related to the entity. Only the Entity in question is provided mutual
            exclusivity. Accessing any external resources(e.g. creating an entity) needs to resynchronize using <see cref="M:EntityManager.AddHandlerEvent(System.Action)"/>
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.Entity.Disable">
            <summary> A callback when the entity is disabled. This will be called whenever the system attempts to destroy an 
            entity and should be used to release any resources tied with it. An entity should assume it is destroyed after 
            processing this callback. </summary> 
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.Entity.Initialize(Arterra.Configuration.Generation.Entity.EntitySetting,UnityEngine.GameObject,Unity.Mathematics.float3)">
            <summary>
            Initializes the entity's instance. Called when creating an instance of the entity.
            The callee may preset any default values during this process but it <b>must</b> guarantee
            that the entity returned is fully populated (i.e. virtual functions all set).
            </summary>
            <param name="setting">The setting of the entity. Specific to the authoring entry it's instantiated from. </param>
            <param name="controller">The controller responsible for displaying the entity. Passed from <see cref="F:Arterra.Configuration.Generation.Entity.Authoring.Controller"/> </param>
            <param name="GCoord">The position in grid space the entity was placed at. </param>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.Entity.Deserialize(Arterra.Configuration.Generation.Entity.EntitySetting,UnityEngine.GameObject,Unity.Mathematics.int3@)">
            <summary>
            Deserializes the entity's instance. Some of the entity's information may be retrieved from serialization
            while others may need to be thrown away. This function is called when the entity is deserialized 
            in case the entity needs to reframe its information.
            </summary>
            <param name="setting">The setting of the entity. Specific to the authoring entry it's instantiated from. </param>
             <param name="controller">The controller responsible for displaying the entity. Passed from <see cref="F:Arterra.Configuration.Generation.Entity.Authoring.Controller"/> </param>
            <param name="GCoord">The position in grid space the entity was placed at. </param>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.transform">
            <summary> The transform of the entity used for positioning and collision detection. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.position">
            <summary>A single line property for retrieving and setting the entity's position in grid space. Most entities 
            require knowledge of other entity's positions; however entities that aren't spatially bound may not fulfill 
            this contract if it no system requires its location.  </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.head">
            <summary> The position of the entity's head--dictating where it attacks and ray traces from.
            By default this is the same as <see cref="P:Arterra.Configuration.Generation.Entity.Entity.position"/>  </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.origin">
            <summary>A single line property for retrieving and setting the entity's origin in grid space.
            Unlike <see cref="P:Arterra.Configuration.Generation.Entity.Entity.position"/>, the origin is the lowest point within the object's collider while
            the position describes the center of the collider. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.velocity">
            <summary>A single line property for retrieving and setting the entity's velocity. Most entities
            require knowledge of other entity's velocities; however entities that aren't spatially bound
            may not fulfill this contract if it no system requires its velocity. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.Facing">
            <summary> The quaternion representing the rotation of the entity. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.Forward">
            <summary>The direction the entity is facing, found by multiplying the forward direction 
            by the entity's <see cref="P:Arterra.Configuration.Generation.Entity.Entity.Facing">rotation</see></summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.Right">
            <summary>The tangent to the direction the entity is facing, found by multiplying the 
            right direction by the entity's <see cref="P:Arterra.Configuration.Generation.Entity.Entity.Facing">rotation</see></summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.weight">
            <summary> The weight of the entity </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.Entity.eventCtrl">
            <summary> The event controller responsible for managing all events related to this entity </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.Events">
            <summary> The interface getter for the event control of the entity </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.Entity.OnDrawGizmos">
            <summary>
            A callback to draw any gizmos that the entity may need to draw. This is only for 
            debugging purposes in UnityEditor to draw any annotations related to entities. This will
            not be called in a build.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Entity.Entity.Info">
            <summary>
            Settings for a structure that is required for the systems governing how entities are identified
            and co-exist in the world. An incorrect setting can lead to not only invalidation of the entity
            but corruption of the entire entity system. This may be read from within the entity's type
            but should not be modified except by the <see cref="T:EntityManager"> entity system </see>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.Entity.Info.entityId">
            <summary> The unique identifier of the entity that remains the same throughout the entity's life cycle, regardless of if it's serialized
            or saved to disk. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.Entity.Info.entityType">
            <summary> The index of the entity's name within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"/> registry. This is guaranteed to be different
            for two different types of entities and can be used to test such. If the entity is serialized, this should be decoupled and recoupled upon deserialization. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.Entity.GetRegistry">
            <summary>
            Gets the <see cref="N:Arterra.Configuration.Generation.Entity">registry</see> containing all entities when the game is loaded. Used to serialize
            and deserialize entities to json. See <see cref="M:IRegistered.GetRegistry"/> for more info.
            </summary>
            <returns>The Registry containing all entities within the game</returns>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.Entity.Index">
            <summary> Gets the index within the <see cref="N:Arterra.Configuration.Generation.Entity">entity registry</see> of the current
            entity's name. Equivalent to <see cref="F:Arterra.Configuration.Generation.Entity.Entity.Info.entityType"/>. See <see cref="P:IRegistered.Index"/> for more info. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Entity.EntitySetting">
            <summary> An interface for all authoring-specific settings used by entities. A setting itself does not need to 
            define any members that has to be known externally so this is an empty contract and in effect no 
            different than an <see cref="T:System.Object"/>, but it offers clarity as to what the object is used for. Explicitly
            must be managed class so instances do individually waste memory on settings. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.EntitySetting.profile">
            <summary> The profile information of the entity. See <see cref="T:Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.EntitySetting.collider">
            <summary> The actual dimensions of the entity used for collisions and hit-box detection </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.EntitySetting.Preset(System.UInt32)">
            <summary> Presets any information shared by all instances of the entity. This is only called once per entity type within
            the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"> entity register </see> and is used to set up any shared readonly information. </summary>
            <param name="entityType">The index of the entity type within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"/> registry.</param>
            <remarks> For example, if the entity uses a state machine it can allocate function pointers to each state within the machine such that
            they may be referenced through an edge list. </remarks>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.EntitySetting.Unset">
            <summary> A callback to release any information set by <see cref="M:Arterra.Configuration.Generation.Entity.EntitySetting.Preset(System.UInt32)"/>. Called once per entity type within the 
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"> entity register </see> before the game is closed.  </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo">
            <summary>
            Settings facilitiating the reading of the entity's profile from a shared location in memory. An entity's profile should define a region of 
            space the entity can exist in and path through. The profile is a list of conditions spanning from the entity's grid space integer 
            origin(the bottom-left corner) in the positive direction such that each condition aligns with an integer grid space. The map 
            entry at each grid position is checked against the <see cref="T:Arterra.Configuration.Generation.Entity.ProfileE"> condition </see> to determine if the profile matches the location. 
            A profile is used to assist in many processess from entity placement, pathfinding, pathfind recalculation, and more. An invalid 
            profile may result in erroneous entity behavior. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo.bounds">
            <summary>
            The size of the entity's profile in grid space, Describes a 3D cuboid whose volume is the amount of <see cref="T:Arterra.Configuration.Generation.Entity.ProfileE"> checks </see> that 
            are performed to validate the entity's profile. The conditions are linearly encoded with the first x compoennt being the major axis and
            the final z component being the minor axis.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo.profileStart">
            <summary>
            The start of the entity's profile within a global shared location, <see cref="F:Arterra.Core.Terrain.GenerationPreset.EntityHandle.entityProfileArray"/> 
            that contains the profiles for all entities. This should not be modified and will be assigned in runtime by the configuration of the entity registry.
            The size of the information read at this location is determined by <see cref="F:Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo.bounds"/>.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Entity.ProfileE">
            <summary>
            A single condition that is considered when verifying an entity's <see cref="T:Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo"> profile </see>.
            This is a condition that is tested against a point in space to verify that the entity can exist there. The 
            condition may also define flags for how it should be evaluated when considering the entity's combined profile.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.ProfileE.bounds">
            <summary>
            A bitmask representing two conditions that a map entry must fall within to be considered a match. Divided
            into two-byte shorts where each short represents a range defined by the bounds stored within the high and 
            low byte. The high short is used for viscosity and the low short for density. See <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo"/>
            for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Entity.ProfileE.flags">
            <summary>
            A bitmask representing the flags that should be used when evaluating the profile. The flags are used to determine
            how the condition should effect the overall validity of the profile. 
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.ProfileE.AndFlag">
            <summary> Whether this condition must be true for the profile to be valid. 
            If this flag is set, the profile may only be valid if this condition is met. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.ProfileE.OrFlag">
            <summary> Whether this condition may be ignored if another condition with the OrFlag is set. If no condition 
            sets this flag, the profile does not consider this. If multiple conditions set this flag, the profile will be valid
            only if one of the conditions within that group is met. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Entity.ProfileE.ExFlag">
            <summary> Whether this condition should be excluded when considering pathfinding the profile. In case animals(e.g. birds) may
            pathfind through locations that they can't generate on. This flag is ignored when placing the entity but is used to 
            ignore this condition when pathfinding. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Entity.MapDataDrawer">
            <summary> A utility class to override serialization of <see cref="T:Arterra.Configuration.Generation.Entity.ProfileE"/> into a Unity Inspector format.
            It exposes the internal components of the bitmap so it can be more easily understood by the developer. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.MapDataDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to be rendered for the property. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Entity.MapDataDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to know the height of the Inspector element. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Map">
            <summary>
            Identifies information used in generating the map info for a chunk.
            Locates the noise samplers responsible for creating different aspects
            of the terrain. <seealso href="https://blackmagic919.github.io/AboutMe/2024/08/01/Base-Generation/"/>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.waterHeight">
            <summary>
            The height in grid space of the water surface. Water will only be generated if the <i>surface</i>, as defined in 
            <see cref="T:Arterra.Configuration.Generation.Surface"/> is below this height, water will then fill the space between the surface and this height.
            </summary> 
            <remarks>Water only generates below this height as creating various water heights involves topological examination 
            to affirm a water body is contained within the terrain which is expensive.</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.heightFalloff">
            <summary>
            The falloff intensity of the height from the surface as height approaches infinity. <see cref="T:Arterra.Configuration.Generation.Biome.CaveBiome"/>s are permitted
            to generate preferrably based off the height from the surface, but as this height is unbounded, an inverse exponential function is
            used to remap the sample space to the range, 0 to 1. HeightFalloff descibes how quickly the function approaches its asymptote,
            with a higher value allowing for more control over a greater distance from the surface, and a lower value restricting the range
            to be closer to the surface. <seealso cref="F:Arterra.Configuration.Generation.Biome.CaveBiome.HeightStart"/>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.atmosphereFalloff">
            <summary>
            The falloff intensity of the atmosphere that is multipled with the <see cref="F:Arterra.Configuration.Generation.Surface.AtmosphereNoise"/> map to 
            falloff the atmosphere as height approaches infinity. Because this number is very small, it is difficult to control directly 
            in the <see cref="T:Arterra.Configuration.Generation.Material.MaterialData">noise</see> settings, so this value is just used as a scalar for the entire function.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.CaveFrequencyNoise">
            <summary>
            The name of the noise function within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> registry of noise functions
            that is used to generate the frequency of the caves. Increased cave frequency will make caves appear more frequently by shifting
            the boundary between cave and non-cave space. This has the effect of enlarging pre-existing caves as well.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.CaveSizeNoise">
            <summary>
            The name of the noise function within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> registry of noise functions
            that is used to generate the size of the caves. It does this by assuming <see cref="F:Arterra.Configuration.Generation.Map.CoarseTerrainNoise"/> generates larger caves 
            while <see cref="F:Arterra.Configuration.Generation.Map.FineTerrainNoise"/> generates smaller caves, whereby it blends the two accordingly by the outputed <see cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/>.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.CaveShapeNoise">
            <summary>
            The name of the noise function within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> registry of noise functions
            that is used to generate the shape of the caves. This is done by taking evaluating each entry's cave density by the distance
            from it to the outputed <see cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/> and using that as the new density. This has the effect of creating blobular 
            regular caves when <see cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/> approaches 0 or 1, and more stringy shell-like caves when <see cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/> 
            is closer to 0.5.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.CoarseMaterialNoise">
            <summary>
            The name of the noise function within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> registry of noise functions
            that is used to generate a coarse noise map. <see cref="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.genSize"/> may selectively blend between this map and
            the map generated by <see cref="F:Arterra.Configuration.Generation.Map.FineMaterialNoise"/> to create a unique generation pattern without the need for a new noise function.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.FineMaterialNoise">
            <summary>
            The name of the noise function within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> registry of noise functions
            that is used to generate a fine noise map. <see cref="F:Arterra.Configuration.Generation.Biome.Info.BMaterial.genSize"/> may selectively blend between this map and
            the map generated by <see cref="F:Arterra.Configuration.Generation.Map.CoarseMaterialNoise"/> to create a unique generation pattern without the need for a new noise function.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.CoarseTerrainNoise">
            <summary>
            The name of the noise function within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> registry of noise functions
            that is used to generate a coarse noise map. <see cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/> may selectively blend between this map and
            the map generated by <see cref="F:Arterra.Configuration.Generation.Map.FineTerrainNoise"/> to create a unique generation pattern without the need for a new noise function.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Map.FineTerrainNoise">
            <summary>
            The name of the noise function within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> registry of noise functions
            that is used to generate a fine noise map. <see cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/> may selectively blend between this map and
            the map generated by <see cref="F:Arterra.Configuration.Generation.Map.CoarseTerrainNoise"/> to create a unique generation pattern without the need for a new noise function.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Map.CaveFrequencyIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Map.CaveFrequencyNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Map.CaveSizeIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Map.CaveSizeNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Map.CaveShapeIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Map.CaveShapeNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Map.CoarseMaterialIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Map.CoarseMaterialNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Map.FineMaterialIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Map.FineMaterialNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Map.CoarseTerrainIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Map.CoarseTerrainNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Map.FineTerrainIndex">
            <summary> The index of the noise function described by <see cref="F:Arterra.Configuration.Generation.Map.FineTerrainNoise"/> in the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise">noise</see> registry </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructureData">
            <summary>
            A collection of settings that describe the contents of a structure
            as well as shared metadata on its variants, and specifications on
            how it should be generated in the world.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.settings">
            <summary>  See <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.Settings"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.Names">
            <summary>
            The names of all materials within the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/> registry that
            are used in the structure. All entries that require references to a material may indicate the index within
            this list of the name of the material in the external registry.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.map">
            <summary>
            The map information contained by the structure. This is the list of map entries that 
            define the structure, linearly encoded through the dimensions specified in <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.GridSize"/>.
            The size of the map must be equal to the product of the dimensions specified in <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.GridSize"/>
            to avoid undefined behavior. The layout of each map entry also contains metadata on how it 
            should be placed in the world, see <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.PointInfo"/> for more information.
            </summary> <remarks> As structures need to define the entire grid space they occupy, it is recommended that 
            the size of structures be not too big to avoid excessive memory usage. </remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.checks">
            <summary>
            The list of checks that need to be verified before a structure can be placed at a certain location.
            Each check samples the map to verify its information such that the time required to place a 
            structure grows linearly with the number of checks. See <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckPoint"/> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.Enhancements">
            <summary> Enhanced features allowing structures to dictate more aspects of its generation than the 
            raw map data. This feature will only be used if enabled via <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.IsEnhanced"/>.
            See <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures"/> </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.SerializePoints">
            <summary> A getter property that deserializes the structure's map data by recoupling them with the current world's configuration. This involves
            retrieving the real indices of the materials within the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/> registry. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Structure.StructureData.Initialize">
            <summary> When modifiying a structure through the <see cref="T:DensityDeconstructor"/> editor, initializes the sturcture's map 
            to match the grid size of the structure. Additionally ensures that no elements of the structure are null. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructureData.CheckPoint">
            <summary>
            A check that the structure must perform before it can be placed at a certain location
            in the world. A check involves sampling the map relative to its desired placement //
            location and orientation and verifying that the obtained map information is consistent
            with the set of requirements specified in <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo"/> .
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.CheckPoint.position">
            <summary>
            The offset in grid space from the structure's origin (the bottom left corner of the structure),
            of the map entry that the check will sample. This offset is subject to possible rotations 
            detailed by <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randYRot"/>, <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randXRot"/> and <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randZRot"/> whereby
            the location of the check will be rotated in the same manner as the structure's contents.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.CheckPoint.checkInfo">
            <summary> The information that the sampled entry will be tested against. See <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo"/> for more information. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Structure.StructureData.CheckPoint.#ctor(Unity.Mathematics.float3,Arterra.Configuration.Generation.Structure.StructureData.CheckInfo)">
            <summary> Initializes a new check point. </summary>
            <param name="position">The offset from the structure origin of the check.</param>
            <param name="checkInfo">The requirements verified by the check.</param>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructureData.Settings">
            <summary> The settings for a structure that describe its contents 
            and variations on how it can be generated. See <see hred="https://blackmagic919.github.io/AboutMe/2024/07/03/Structure-Placement/">
            here </see> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.GridSize">
            <summary>
            The size of the structure in grid space that the structure occupies. The structure's <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.map">contents</see>
            must match these dimensions to avoid undefined behavior. Ignoring rotations, the structure contents will be 
            read with the third(z) component as the minor axis and the first(x) component as the major axis.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.minimumLOD">
            <summary>
            The minimum level of detail that the structure can generate from. The minimum LoD is the size of the floor of the 
            largest side-length of the structure in chunk space. It must be less than or equal to <seealso cref="F:Arterra.Configuration.Generation.Structure.Generation.maxLoD"/>. 
            Larger structures will be generated less frequently by the nature of structure placement so a larger <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.minimumLOD"/>
            may inadvertently result in a lower density of structures. Incorrectly setting this value can result in corrupted generation. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.config">
            <summary> The raw configuration bitmap </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randYRot">
            <summary> Whether or not placement of the structure may include random rotations around the vertical(y)-axis. Rotations are
            possible by changing the axis and order the structure's contents are read when being placed in the world.
            </summary> 
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randXRot">
            <summary>
            Whether or not placement of the structure may include random rotations around the major horizontal(x)-axis. The horizontal
            axis that it is rotated upon may shift depending on the <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randYRot"/>. Rotations are possible by changing 
            the axis and order the structure's contents are read when being placed in the world.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randZRot">
            <summary>
            Whether or not placement of the structure may include random rotations around the mino horizontal(z)-axis. The horizontal
            axis that it is rotated upon may shift depending on the <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randYRot"/> and <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.randXRot"/>. Rotations 
            are possible by changing the axis and order the structure's contents are read when being placed in the world.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.IsEnhanced">
            <summary> Whether or not the structure has enhanced features. See <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.Enhancements"/> for more info. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo">
            <summary>
            The requirements that are tested against a map entry sampled by a <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckPoint"/>. The
            ranges of different measurements that the map entry must fall within to be considered valid. See
            <see href="https://blackmagic919.github.io/AboutMe/2024/06/16/Structure-Pruning/">here</see> for more info.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo.data">
            <summary>
            The raw data of the bounds. Each range is defined by a 2-byte short whereby the bottom and top bounds of
            each range occupy the first and second byte of the short respectively. Bitmasking is used
            to retrieve the bounds of each range during generation.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo.MinLiquid">
            <summary>
            The lower bound of the liquid density that the map entry must be above to be considered valid.
            The liquid density is defined by <see cref="P:Arterra.Core.Storage.MapData.LiquidDensity"/>. 
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo.MaxLiquid">
            <summary>
            The upper bound of the liquid density that the map entry must be below to be considered valid.
            The liquid density is defined by <see cref="P:Arterra.Core.Storage.MapData.LiquidDensity"/>.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo.MinSolid">
            <summary>
            The lower bound of the solid density that the map entry must be above to be considered valid.
            The solid density is defined by <see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/>.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo.MaxSolid">
            <summary>
            The upper bound of the solid density that the map entry must be below to be considered valid.
            The solid density is defined by <see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/>.
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo.Contains(Arterra.Core.Storage.MapData@)">
            <summary>
            Determines whether or not the specified map entry satisifies the check's
            bounds. A map entry satisifes the check's bounds if its density and viscosity
            fall between the defined lower and upper limits of the check.
            </summary>
            <param name="pt">The map data which is tested against the bounds</param>
            <returns>Whether or not the <paramref name="pt"/> is within the bound</returns>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo.IsNull">
            <summary> Whether or not the check's bounds are null, meaning that
            the check is always valid. Equivalent the min and max bounds being
            set to their maximum range. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructureData.PointInfo">
            <summary> A single map entry contained by the structure. Contains <see cref="T:Arterra.Core.Storage.MapData">
            standard map information</see> as well as metadata on how it should be interpreted when the 
            structured is placed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.data">
            <summary>
            The raw map data. Map information is stored in sections of this 4 byte integer and may be
            retrieved through bit masking, like how it is done during structure generation.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.preserve">
            <summary> Whether or not the map entry should be copied exactly as it is when being placed. The default
            behavior is to take the maximum density or viscosity between the structure and the map entry it is
            replacing; this is to allow for smoother transitions between structures and terrain. If multiple structures
            contain multiple overlaping points set to preserve, the maximum density and viscosity will be taken only of those 
            specific points.</summary> <remarks>The highest bit of <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.data"/> is used as this flag</remarks>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.density">
            <summary> The density of the map entry. Must be less than or equal to <c>255</c>. 
            Occupies the lowest byte of <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.data"/>. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.viscosity">
            <summary> The viscosity of the map entry. Must always be less than or equal to <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.density"/>. 
            Occupies the second lowest byte of <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.data"/>. </summary>
        </member>
        <member name="P:Arterra.Configuration.Generation.Structure.StructureData.PointInfo.material">
            <summary> The index of the name of the material within <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/>. When used during terrain generation,
            this value is recoupled with the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/> registry by 
            retrieving the index of the material name within the registry.  </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures">
            <summary>Optional features structures can specify if they have it enabled
            via <see cref="P:Arterra.Configuration.Generation.Structure.StructureData.Settings.IsEnhanced"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures.Entities">
            <summary> List of entities that this structure can spawn. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures.MapMetaData">
            <summary> List of map meta data that this structure can spawn.</summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures.StructureEntity">
            <summary>Spawning information for a
            single entity by the structure. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures.StructureEntity.Entity">
            <summary> The index within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"/> registry
            of the entity to spawn if its profile matches. </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures.StructureEntity.offsetMin">
            <summary> The minimum offset from the structure origin
            the entity can attempt to spawn at </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures.StructureEntity.offsetMax">
            <summary> The maximum offset from the structure origin
            the entity can attempt to spawn at </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures.StructureEntity.GenCount">
            <summary>The average amount of entities to spawn in the given region.</summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructPointDrawer">
            <summary> A utility class to override serialization of <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.PointInfo"/> into a Unity Inspector format.
            It exposes the internal components of the bitmap so it can be more easily understood by the developer. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Structure.StructPointDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to be rendered for the property. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Structure.StructPointDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to know the height of the Inspector element. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.StructCheckDrawer">
            <summary> A utility class to override serialization of <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo"/> into a Unity Inspector format.
            It exposes the internal components of the bitmap so it can be more easily understood by the developer. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Structure.StructCheckDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to be rendered for the property. </summary>
        </member>
        <member name="M:Arterra.Configuration.Generation.Structure.StructCheckDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to know the height of the Inspector element. </summary>
        </member>
        <member name="T:Arterra.Configuration.Generation.Structure.Generation">
            <summary>
            A collection of settings that describe how structures are generated. 
            Any terrain not generated through noise-based generation should be created 
            through a structure. See <seealso href="https://blackmagic919.github.io/AboutMe/2024/06/08/Structure%20Planning/">
            here</seealso> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.Generation.StructureDictionary">
            <summary>
            A registry containing all structures that can be generated. 
            The number of structures that can be generated is limited by this registry.
            See <see cref="T:Arterra.Configuration.Generation.Structure.StructureData"/> for more info.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.Generation.StructureChecksPerChunk">
            <summary>
            The amount of structures that attempt to be placed per <see cref="!:Terrain.TerrainChunk.RealChunk"> Real Chunk </see>
            sampled. The higher this value, the more structures that will attempt to be placed per the same region of space resulting in 
            a higher density of structures.
            </summary> 
            <remarks>The amount of checks is solely space dependent meaning a chunk spanning a larger region in space will perform
            proportionately more checks. The amount of checks performed grows at a rate of <c> 8^depth * StructureChecksPerChunk</c>
            where <see cref="!:Terrain.TerrainChunk.depth">depth</see> is the size of a chunk of that layer within the octree.</remarks>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.Generation.LoDFalloff">
            <summary>
            How quickly the amount of structure checks falls off with the size of the structure. The size of a structure
            is categorized by the <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.minimumLOD"/> of the structure, which reflects the size in chunk space
            of the largest side-length of the structure. See <see href="https://blackmagic919.github.io/AboutMe/2024/06/08/Structure%20Planning/"> 
            here </see> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Generation.Structure.Generation.maxLoD">
            <summary>
            The maximum LoD that a structure can generate from. The LoD of a structure is determined by <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.Settings.minimumLOD"/>.
            Equivalently, describes the maximum side-length of a structure in chunk space that is supported. I.e. the maximum side-length any
            structure can take is (maxLoD * <see cref="F:Arterra.Configuration.Quality.Terrain.mapChunkSize"/>) without risking corrupted generation.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.CraftingAuthoring">
            <summary> An authoring object for a crafting recipe allowing for it 
            to be created via Unity's Inspector. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingAuthoring.Names">
            <summary> A list of names within external registries used by entries referencing external resources. When an entry
            referes to an entry in an external registry it should refer to the index within this list of the name
            of the entry in the external registry. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingAuthoring.Recipe">
            <summary> The recipe that is being authored. </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.CraftingAuthoring.AttachDisplay(UnityEngine.Transform)">
            <summary> Controls how recipes are created as UI slots. See <see cref="T:ISlot"/> for more information </summary>
            <param name="parent">The parent object containing the new slot</param>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.CraftingAuthoring.ClearDisplay(UnityEngine.Transform)">
            <summary> Releases UI slot objects associated with this recipe. See <see cref="T:ISlot"/> for more information </summary>
            /// <param name="parent">The parent object containing the slot to be removed</param>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.CraftingRecipe">
            <summary> A recipe describing a configuration of materials on the crafting grid
            that will create a specific item. Modifying recipes create an unfair advantage
            or upend the difficulty progression. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.materials">
            <summary> The materials that must be matched to successfully craft this recipe. Materials
            correspond to a grid of points whose size is dictated by <see cref="F:Arterra.Configuration.Intrinsic.Crafting.GridWidth"/>.
            This grid must match the player's crafting grid for the recipe to be considered
            craftable and the result to be obtained. </summary> 
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.items">
            <summary> The items that must be matched to successfully craft this recipe. Items
            correspond to the slots between the grid lines dictated by <see cref="F:Arterra.Configuration.Intrinsic.Crafting.GridWidth"/>.
            These slots must match the player's crafting slots for the recipe to be considered
            craftable and the result to be obtained. </summary> 
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.result">
            <summary> If the recipe can be crafted, the result that is given to the player if the recipe is crafted.
            <see cref="T:Arterra.Configuration.Intrinsic.CraftingRecipe.Result"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.NoSubUnitCreation">
            <summary> Whether or not the recipe can be extended for quantities less than the minimum required amount</summary>
        </member>
        <member name="P:Arterra.Configuration.Intrinsic.CraftingRecipe.ResultItem">
            <summary> The result item of the recipe. This is the actual item given to the player if the recipe is crafted.
            Obtained by retrieving the item indicated by <see cref="!:ResultIndex"/> from the item registry. </summary>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.CraftingRecipe.Ingredient">
            <summary>
            A structure representing the information
            of a single ingredient in a recipe.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.Ingredient.Index">
            <summary>  The index within the item registry of the item that needs to be placed here.
            This will be ignored if Amount is 0. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.Ingredient.Amount">
            <summary> The amount of unit material that will be used to create a unit amount of 
            result. If <see cref="F:Arterra.Configuration.Intrinsic.CraftingRecipe.NoSubUnitCreation"/> is true, the amount that must be present
            to create the recipe. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.Ingredient.flags">
            <exclude />
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.CraftingRecipe.NormalInd(System.Int32)">
            <summary> Obtains the material index of the map entry at a specific grid index in the recipe. 
            If the entry is dirty, the material is ignored as it is not part of the real recipe
            and is not used when testing whether the recipe is craftable. </summary>
            <param name="index">The index within <see cref="!:entry"/> of the entry whose material is retrieved</param>
            <returns>The material of the entry at the specified <paramref name="index"/></returns>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.CraftingRecipe.Result">
            <summary> The result of a recipe. Indicates what is given to the player if the recipe is crafted. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.CraftingRecipe.Result.data">
            <summary>
            The bitmap containing the result's information. The low 2-bytes indicate the 
            <see cref="P:Arterra.Configuration.Intrinsic.CraftingRecipe.Result.Index"/> and the high 2-bytes indicate the <see cref="P:Arterra.Configuration.Intrinsic.CraftingRecipe.Result.Multiplier"/>.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Intrinsic.CraftingRecipe.Result.Index">
            <summary>
            The index within the <see cref="!:Names"> name registry </see> of the name of the entry
            within the external <see cref="F:Arterra.Configuration.Config.GenerationSettings.Items"> item registry </see> of the item
            that is given to the player if the recipe is crafted. 
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Intrinsic.CraftingRecipe.Result.Multiplier">
            <summary> When an item is crafted, the amount of the item that is created is taken by adding all the 
            amounts of materials used in creating the recipe and multiplying it by the multiplier. </summary>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.RecipeResultDrawer">
            <summary> A utility class to override serialization of <see cref="!:Recipe.Result"/> into a Unity Inspector format.
            It exposes the internal components of the bitmap so it can be more easily understood by the developer. </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.RecipeResultDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to be rendered for the property. </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.RecipeResultDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to know the height of the Inspector element. </summary>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.WorldApperance">
            <summary> Settings controlling how the world appears in 
            the menu when selecting and viewing the world 
            before entering </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.WorldApperance.DisplayedChunk">
            <summary> The coordinate in Chunk Space of the chunk that will be
            used to generate the chunk display. If this chunk is not saved,
            any arbitrary saved chunk will be selected to be displayed. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.WorldApperance.RotateSpeed">
            <summary> The speed at which the camera rotates around this display chunk. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.WorldApperance.GridScale">
            <summary>
            The amount of 
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.Armor">
            <summary>
            Settings controlling the apperance of the armor display menu. The armor 
            system allows the player to equip armor items onto their character.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Armor.DisplayIcon">
            <summary> The name of the texture within the texture registry of 
            the icon displayed on the <see cref="T:PanelNavbarManager">Navbar</see>
            referring to Armor Display.  </summary>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.Furnace.FurnaceMaConversion">
            <summary>
            A structure defining how a material is converted in a furnace.
            
            This conversion can be used for input materials being smelted or output materials being produced.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Furnace.FurnaceMaConversion.Index">
            <summary>
            The name of the material.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Furnace.FurnaceMaConversion.Rate">
            <summary>
            The rate of amount per second at which the material is converted or being converted to.
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.Furnace.FurnaceFormula.AttachDisplay(UnityEngine.Transform)">
            <summary> Controls how recipes are created as UI slots. See <see cref="T:ISlot"/> for more information </summary>
            <param name="parent">The parent object containing the new slot</param>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.Furnace.FurnaceFormula.ClearDisplay(UnityEngine.Transform)">
            <summary> Releases UI slot objects associated with this recipe. See <see cref="T:ISlot"/> for more information </summary>
            /// <param name="parent">The parent object containing the slot to be removed</param>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.Mortar.MortarMaConversion">
            <summary>
            A structure defining how a material is converted in a mortar.
            This conversion can be used for input materials being smelted or output materials being produced.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Mortar.MortarMaConversion.Index">
            <summary>
            The name of the material.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Mortar.MortarMaConversion.Rate">
            <summary>The rate of amount per second at which the material is converted or being converted to. </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.Mortar.MortarFormula.AttachDisplay(UnityEngine.Transform)">
            <summary> Controls how recipes are created as UI slots. See <see cref="T:ISlot"/> for more information </summary>
            <param name="parent">The parent object containing the new slot</param>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.Mortar.MortarFormula.ClearDisplay(UnityEngine.Transform)">
            <summary> Releases UI slot objects associated with this recipe. See <see cref="T:ISlot"/> for more information </summary>
            /// <param name="parent">The parent object containing the slot to be removed</param>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.Readback">
            <summary> Settings for the readback system. 
            <see cref="T:Arterra.Core.Terrain.Readback.AsyncMeshReadback"/> 
            for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Readback.TerrainMats">
            <summary> The list of all materials normally used to render the terrain. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Readback.LitShadedMats">
            <summary> List of other materials that depend on the game's custom lit shading to work </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Readback.indirectTerrainMats">
            <summary> Variants of all normal materials used to intermediately draw the terrain
            directly from the GPU. Each material in <see cref="F:Arterra.Configuration.Intrinsic.Readback.TerrainMats"/> should define a compiler
            keyword that creates a variant allowing it to render information directly from a custom buffer. </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.Readback.Initialize">
            <summary> Populates the <see cref="F:Arterra.Configuration.Intrinsic.Readback.indirectTerrainMats"/> array with variants of materials in <see cref="F:Arterra.Configuration.Intrinsic.Readback.TerrainMats"/>. </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.Readback.Release">
            <summary> Releases all variant materials created in <see cref="F:Arterra.Configuration.Intrinsic.Readback.indirectTerrainMats"/> </summary>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.TerrainUpdation">
            <summary>
            Settings controlling how updates to the terrain are performed 
            and how much load it is allotted. Terrain updates are point-operations
            applied to any map entry in <see cref="T:Arterra.Core.Storage.CPUMapManager"/>. Once a map entry is updated
            the correspondng material's unique update method will be called if it is defined.
            See <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)"/> and
            <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)"/> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.TerrainUpdation.RandomUpdatesPerChunk">
            <summary> How many random points are chosen to be updated at random 
            per update cycle per chunk. Random Updates allow certain materials to 
            base behavior off stochastic sampling. Random Updates will only
            be added if the backlog of update points does not exceed 
            <see cref="F:Arterra.Configuration.Intrinsic.TerrainUpdation.MaximumTickUpdates"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.TerrainUpdation.MaximumTickUpdates">
            <summary>
            The maximum number of updates that can be performed in a 
            single update cycle. Increasing this value may increase simulation
            speed of update-based-effects at the cost of performance.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.TerrainUpdation.UpdateTickDelay">
            <summary>
            The number of in-game-ticks that must pass before the next update cycle.
            An in-game tick is one update to Unity's FixedUpdate loop.
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Intrinsic.TerrainUpdation.Clone">
            <summary> Clones the object </summary>
            <returns></returns>
        </member>
        <member name="T:Arterra.Configuration.Intrinsic.Crafting">
            <summary>
            Settings controlling the apperance and behavior of the crafting system. The crafting 
            system allows the player to create items from materials enabling a wider variety of 
            content and functionality within the game.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.DisplayIcon">
            <summary> The name of the texture within the texture registry of 
            the icon displayed on the <see cref="T:PanelNavbarManager">Navbar</see>
            referring to Crafting.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.GridWidth">
            <summary> The width of the square grid in terms of grid spaces. As recipe entries are stored on 
            grid corners, the amount of entries necessary to fill the grid is <c> (GridWidth + 1)^2 </c>. 
            If the grid width changes all recipes must be modified to refit the new grid size. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.CraftSpeed">
            <summary> How fast the user can place materials in the crafting grid, measured in change in density
            per frame. As placement of materials is a continuous process, the speed effects how quickly
            the player can craft items. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.PointSizeMultiplier">
            <summary> When a user's cursor hovers closer to a grid corner, how large the grid corner point grows.
            This is used to help the user see where they are placing materials.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.MaxRecipeDistance">
            <summary> The maximum L1 distance between a recipe entry and the player's crafting grid
            for the recipe to be displayed in the crafting menu. The point is to show only the 
            closest recipes to the player's input to avoid cluttering the crafting menu. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.NumMaxSelections">
            <summary> The maximum amount of selections that will be displayed under the crafting grid.
            This is the maximum amount of recipes that will be shown in case too many recipes are
            within <see cref="F:Arterra.Configuration.Intrinsic.Crafting.MaxRecipeDistance"/> of the player's crafting grid. </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.MaxRecipeSearchDisplay">
            <summary>The maximum number of recipes that will be displayed when they are searched in the UI panel </summary>
        </member>
        <member name="F:Arterra.Configuration.Intrinsic.Crafting.Recipes">
            <summary> The registry of all recipes that can be crafted within the game. See <see cref="T:Arterra.Configuration.Intrinsic.CraftingRecipe"/> for more information. </summary>
        </member>
        <member name="T:Arterra.Configuration.Quality.Memory">
            <summary>
            Settings describing the long-term GPU memory customly managed and used to 
            store/visualize the world throughout terrain generation. 
            <seealso cref="T:Arterra.Configuration.Quality.MemoryBufferHandler"/>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Memory.StorageSize">
            <summary> The amount of storage memory allocated in a GPU buffer that is used
            for long-term storage of intermediate and final terrain data. Measured
            in terms of 4-byte words. Running out of space may result in failure
            to generate terrain. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Memory.HeapSize">
            <summary> The amount of heap blocks allocated for the free-block heap tracking addresses
            of free blocks within the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage">Storage</see> buffer.
            The maximum amount of free blocks that will be used is equal to the maximum amount of concurrent allocations that 
            are made. Running out of space may result in failure to generate terrain. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Memory.AddressSize">
            <summary>
            The maximum amount of addresses that can be stored in the address buffer which holds the direct
            address within the storage buffer of allocated blocks. Running out of space may result in failure to generate terrain.
            <seealso cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Address"/>.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Quality.BalancedMemory">
            <summary>  Settings describing a multi-buffer GPU memory handler, 
            mainly used for saving blocks of CPU-side unknown sizes on the GPU  </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.BalancedMemory.InitBlockCount">
            <summary> The initial amount of compute buffer meta data to allocate.
            This does not indicate the actual memory initially allocated,
            but the maximum blocks that can be allocated without resizing 
            meta data buffers which is an expensive operation. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.BalancedMemory.OverflowHandlerSizeReq">
            <summary>The percentage of a buffer that must be free for the system to continue trying
            to allocate to the buffer before it tries to redirect allocations to a different buffer. </summary>
        </member>
        <member name="T:Arterra.Configuration.Quality.MemoryBufferHandler">
            <summary>
            Responsible for managing the allocation and deallocation of memory on the GPU for generation
            related tasks. Rather than allowing each system to maintain its own <see cref="T:UnityEngine.ComputeBuffer"/>, 
            memory is allocated through a shader-based malloc which allows for more efficient memory management and 
            fewer buffer locations to track. Settings on the size of this memory heap can be found in <see cref="T:Arterra.Configuration.Quality.Memory"/>.
            <seealso href = "https://blackmagic919.github.io/AboutMe/2024/08/18/Memory-Heap/"/> 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler.HeapSetupShader">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateShader">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler.DeallocateShader">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler.d_AllocateShader">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler.d_DeallocateShader">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler._GPUMemorySource">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler._EmptyBlockHeap">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler._AddressBuffer">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Quality.MemoryBufferHandler.initialized">
            <exclude />
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.#ctor(Arterra.Configuration.Quality.Memory)">
            <summary>
            Initializes the <see cref="T:Arterra.Configuration.Quality.MemoryBufferHandler"/>. Allocates a memory heap on the GPU for use in the terrain generation process.
            Information is stored in local GPU Buffers which should be obtained through <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/> and <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Address"/>
            properties and bound to any shader that needs to use it. 
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.Release">
            <summary>
            Releases all buffers used by the MemoryHandle.
            Call this method before the program exits to prevent memory leaks.
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemoryDirect(System.Int32,System.Int32)">
            <summary>
            Allocates a memory block of size (<paramref name="count"/> * <paramref name="stride"/>) with the 
            specified <paramref name="stride"/> on the GPU. The unit is a 4-byte integer(word) and byte-level
            allocation is not supported. 
            </summary>
            <remarks>
            As this malloc functions on the GPU, though its synchronous complexity is O(log N) where N is the size of
            the free heap, it is an inefficient use of GPU resources as it must be performed synchronously. As a result
            avoid using this function for small allocations or in performance-critical sections of the code.
            
            The <paramref name="stride"/> is specified such that one can cast the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/> buffer as containing a struct of size <paramref name="stride"/>
            which expedites and simplifies the process of reading and writing to the buffer.
            </remarks>
            <param name="count">The amount of structures of size <paramref name = "stride" /> to be allocated adjacently. The total size of the allocation is (<paramref name="count"/> * <paramref name="stride"/>)</param>
            <param name="stride">The alignment of structures relative to <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/>, every entry will be at a relative address that is a multiple of <paramref name = "stride" />. Stride is in terms of 4-byte words </param>
            <returns>
            The address within the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Address"/> buffer of the entry which holds the address of the first entry
            within the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/> buffer. To read from the memory block, a shader should follow the access pattern
            <b>return addres</b> -> Address Buffer -> Storage Memory. This indirection is necessary to avoid GPU readback. 
            <remarks> 
            The address within the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Address"/> buffer is will contain two entries, the first being the 4-byte relative address
            and the second being relative to the requested <paramref name = "stride" /> <paramref name="stride"/>.
            </remarks>
            </returns>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemory(UnityEngine.ComputeBuffer,System.Int32,System.Int32)">
            <summary>
            Same as <see cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemoryDirect(System.Int32,System.Int32)"/> but with the count being indirectly referenced. This is applicable
            if the amount of objects to be allocated is not known on the CPU. To reference the count, a <see cref="T:UnityEngine.ComputeBuffer"/> is passed
            while the location of the count within the buffer is specified by <paramref name="countOffset"/>.
            </summary>
            <param name="count">A buffer containing the amount of objects of size stride to be allocated. The count must be a 4-byte integer aligned within the buffer. <seealso cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemoryDirect(System.Int32,System.Int32)"/></param>
            <param name="stride"><see cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemoryDirect(System.Int32,System.Int32)"/></param>
            <param name="countOffset">The 4-byte offset within the buffer of the count.</param>
            <returns> <see cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemoryDirect(System.Int32,System.Int32)"/> </returns>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.ReleaseMemory(System.UInt32)">
            <summary>
            Releases an allocated memory block from the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/> buffer. The caller
            must ensure that the address points to a valid allocated memory block. Improper use
            may corrupt the memory heap and cause undefined behavior.
            </summary>
            <param name="addressIndex">
            The address of the entry within the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Address"/> buffer which points to the
            allocated memory block within the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/> buffer. 
            </param>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.ReleaseMemoryDirect(UnityEngine.ComputeBuffer,System.Int32)">
            <summary>
            Same as <see cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.ReleaseMemory(System.UInt32)"/> but with the address being directly referenced. If the caller
            knows the specific location of the address within the GPU, this method can be used to release memory.
            </summary>
            <param name="address">A compute buffer containing the 4-byte sized and aligned address within <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/> of the memroy block.</param>
            <param name="countOffset">The 4-byte offset within <paramref name="address"/> of the entry containing the address to the memory block</param>
        </member>
        <member name="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage">
            <summary> The primary memory buffer used for long-term memory storage in the terrain generation process. </summary>
        </member>
        <member name="P:Arterra.Configuration.Quality.MemoryBufferHandler.Address">
            <summary> A buffer containing addresses to memory blocks within the <see cref="P:Arterra.Configuration.Quality.MemoryBufferHandler.Storage"/> buffer. This buffer tracks the 
            raw 4-byte address as well as the address relative to the requested stride during allocation of each memory block. </summary>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.GetBlockBuffer(System.UInt32)">
            <summary>Retrieves the Storage Buffer associated with this allocation. </summary>
            <param name="index">The address returned by <see cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemory(UnityEngine.ComputeBuffer,System.Int32,System.Int32)"/>.</param>
            <returns>The Compute Buffer which contains the referenced allocation</returns>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.GetBlockBuffer(System.Int32)">
            <summary>Same as <see cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.GetBlockBuffer(System.UInt32)"/> </summary>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.GetBlockBufferSafe(System.Int32,UnityEngine.ComputeBuffer@)">
            <summary>Attempts to retrieve the Storage Buffer associated with this allocation if it is valid </summary>
            <param name="index">The address returned by <see cref="M:Arterra.Configuration.Quality.MemoryBufferHandler.AllocateMemory(UnityEngine.ComputeBuffer,System.Int32,System.Int32)"/>.</param>
            <param name="buffer">If successful, the compute buffer holding this allocation </param> 
            <returns>Whether or not the buffer containing thsi allocation can be successfully obtained</returns>
        </member>
        <member name="M:Arterra.Configuration.Quality.MemoryBufferHandler.TestAllocIsEmpty(System.Int32,System.Action{System.Int32})">
            <summary> Will test if the given allocation is empty(e.g. failed or allocated
            size zero) and callback a handler if it is. </summary>
            <param name="alloc">The allocation that is tested to be empty</param>
            <param name="OnIsEmpty">The callback that is answered if it is empty</param>
        </member>
        <member name="T:Arterra.Configuration.Quality.Terrain">
            <summary>
            Settings controlling the detail of generated terrain and the frequency of its updates. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.maxFrameLoad">
            <summary>
            The maximum amount of resource load that can be used by a single frame.
            The load for a task is specified by <see cref="F:Arterra.Core.Terrain.OctreeTerrain.taskLoadTable"/>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.viewDistUpdate">
            <summary>
            The maximum distance in grid space the viewer needs to move from the previous position used to update the terrain
            to trigger the terrain to update itself. This is so that small movements over critical areas do not 
            cause repeated terrain updates.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.MaxDepth">
            <summary>
            The maximum depth of the terrain octree; the amount of layers betweeen the smallest leaf node and the root.
            Given the size of the smallest leaf node is <see cref="F:Arterra.Configuration.Quality.Terrain.MinChunkRadius"/>, the size of the root node is (<see cref="F:Arterra.Configuration.Quality.Terrain.MinChunkRadius"/> * 2^<see cref="F:Arterra.Configuration.Quality.Terrain.MaxDepth"/>).
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.MinChunkRadius">
            <summary>
            The <see cref="!:Core.Terrain.OctreeTerrain.Octree.Node.GetMaxDist(Unity.Mathematics.int3)"> component distance </see>, 
            in terms of the chunk space away from  the viewer of the farthest chunk that will become a real chunk. 
            As real chunks define the interactive game environment, this effectively defines the size of the game 
            environment relative to the size of the environment chunk (chunk space).
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.Balance">
            <summary>
            The balance factor of the terrain octree. Balance factor refers to the maximum difference in depth between
            two nodes in the octree physically adjacent to each other in space. Accordingly the octree is said to be 
            (<see cref="F:Arterra.Configuration.Quality.Terrain.Balance"/> + 1 : 1) balanced. A lower balance will result in a smoother LoD transition but a 
            larger amount of terrain chunks, decreasing performance.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.MapExtendDist">
            <summary>
            The minimum <see cref="!:Core.Terrain.OctreeTerrain.Octree.Node.GetMaxDist(Unity.Mathematics.int3)"> component distance </see> in 
            chunk space on top of <see cref="F:Arterra.Configuration.Quality.Terrain.MinChunkRadius"/> away from the viewer of the farthest chunk that will be cached in <see cref="!:GPUDensityManager"/>. 
            Chunks not cached in <see cref="!:GPUDensityManager"/> are incapable of reflecting terrain changes and displaying atmospheric effects. Increasing this value
            thus increases the size of the atmosphere at the cost of more GPU memory usage. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.MaxStructureDepth">
            <summary> The maximum depth within the terrain octree that structures will attempt to be generated. </summary>
            <remarks> The process of generating structures scales by a factor of 8 for every increasing depth level. As
            larger chunks can contain a larger amount of structures, the process becomes exponentially more expensive. </remarks>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.lerpScale">
            <summary> The final scaling factor of the terrain; the scale between the grid space and the world space. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.IsoLevel">
            <summary>
            The IsoValue of the terrain. The IsoValue is the density of the terrain that is considered the surface of the ground, 
            or the threshold of the surface. <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/> represents the IsoValue as a percentage of the difference between
            the maximum and minimum density of a map entry.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.mapChunkSize">
            <summary>
            The size in grid space of the smallest node, a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk">Real Chunk</see>, in the terrain octree. 
            This is synonymous to the axis-amount of map entries sampled by any chunk regardless of depth.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.FileRegionDepth">
            <summary>
            The depth within the terrain octree that will be used to organize chunk files into folders. A region
            folder concurrently holds a maximum of 2^<see cref="F:Arterra.Configuration.Quality.Terrain.FileRegionDepth"/> chunk files, similar to an octree node
            of that depth.This is useful in expediting chunk-reading operations as described in <see cref="!:ChunkStorageManager"/>. 
            </summary> <remarks>Alteration of this value in a world with modified chunks may cause data to be lost.</remarks>
        </member>
        <member name="F:Arterra.Configuration.Quality.Terrain.transitionWidth">
            <summary>
            The total size of a chunk's transition voxel as a percentage of a chunk's normal voxel size. When a chunk
            borders another chunk of a different depth, the transition voxel is used to blend the two chunks together.
            If multiple transition layers are required, each layer will be smaller such that the total width of the transition
            is equal to <see cref="F:Arterra.Configuration.Quality.Terrain.transitionWidth"/>.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Quality.Atmosphere">
            <summary>
            Settings controlling the quality of the atmosphere. 
            The atmosphere is a purely visual effect and does not affect gameplay.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Atmosphere.BakedTextureSizePX">
            <summary>
            The size of the baked texture in pixels. The baked texture is
            the resolution used to actually raymarch and sample the map information made
            available by <see cref="!:GPUDensityManager"/> which is an expensive operation.
            The result is upscaled to the screen resolution.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Atmosphere.InScatterDetail">
            <summary>
            The detail of the in-scatter. An in-scatter point is a point along the pixel's ray 
            in which the in-scattered light is calculated through calculating the optical depth along other
            rays with a resolution of <see cref="F:Arterra.Configuration.Quality.Atmosphere.NumOpticalDepthPoints"/>. The amount of in-scatter points
            is 2^<see cref="F:Arterra.Configuration.Quality.Atmosphere.InScatterDetail"/>. It must be a power of 2 for an acceleration step to work.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.Atmosphere.NumOpticalDepthPoints">
            <summary>
            The number of optical depth points to sample along rays used to calculate in-scatter.
            The number of optical depth points is exactly <see cref="F:Arterra.Configuration.Quality.Atmosphere.NumOpticalDepthPoints"/>. 
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Quality.GeoShader">
            <summary>
            A template for a custom GeoShader, a logical mesh generation unit 
            that generates more geometry given a base batch of geometry. Not to be 
            confused with the pipeline geoshading step, this custom geoshader occurs in
            the compute shader and the output geometry is cached in memory as long as the chunk's 
            base mesh exists. <seealso href="https://blackmagic919.github.io/AboutMe/2024/11/03/GeoShaders/">More Info</seealso>
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Quality.GeoShader.GetMaterial">
            <summary> Obtains the material using the <see cref="!:shader"/> stored within this reference.
            A material is an instance of a shader with custom properties set. </summary>
            <returns>The instantiated material with the geoshader's configuration. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arterra.Configuration.Quality.GeoShader.PresetData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Arterra.Configuration.Quality.GeoShader.Release">
            <summary> Used to release any resources tied to this geometry shader, notably compute buffers
            used to manage shader variants. This is called once upon exiting the game, and will be called
            not before <see cref="M:Arterra.Configuration.Quality.GeoShader.PresetData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> is called again. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arterra.Configuration.Quality.GeoShader.ProcessGeoShader(Arterra.Configuration.Quality.MemoryBufferHandler,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Arterra.Configuration.Quality.GeoShader.GetRegistry">
            <summary> Retrieves the registry of shader variants. If this geoshader
            does not define shader variants, returns null. Note that this is returned
            by value, so to write to it one should call <see cref="M:Arterra.Configuration.Quality.GeoShader.SetRegistry(IRegister)"/>
            </summary> <returns>The registry of shader variants</returns>
        </member>
        <member name="M:Arterra.Configuration.Quality.GeoShader.SetRegistry(IRegister)">
            <summary> Sets the shader's registry of shader variants. Because a registry
            is returned by value, one should call this when updating a shader's 
            variant registry to validate the changes. </summary>
            <param name="reg">The registry of shader variants that has been updated </param>
        </member>
        <member name="T:Arterra.Configuration.Quality.GeoShaderSettings">
            <summary>  Settings controlling how geoshaders are managed in the world. Note: Geoshaders do not 
            refer to the traditional geoshader pass in the render pipeline but a seperate compute
            shader based system for generating non-ephemeral geometry. See <see cref="T:Arterra.Configuration.Quality.GeoShader"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.GeoShaderSettings.Categories">
            <summary>
            Contains all geoshader variants. Each entry should contain a unique geometry generation pattern. The number
            of entries is equal to the number of batches sorted and processed within <seealso cref="!:ShaderGenerator"/>. 
            Hence, it is recommended to not define a new variant if the generation pattern can be reused from another variant. 
            <seealso href="https://blackmagic919.github.io/AboutMe/2024/11/03/GeoShaders/">More Info</seealso>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.GeoShaderSettings.MaxGeoShaderDepth">
            <summary> The maximum depth within the terrain octree of chunks that will be attempted to be geoshaded. </summary>
            <remarks> There is a large fixed cost with rendering geoshaded geometry which makes it not feasible to render it for all chunks. 
            Moreover, these aesthetic effects become less noticable farther away. </remarks>
        </member>
        <member name="F:Arterra.Configuration.Quality.GeoShaderSettings.SubchunkUpdateThresh">
            <summary> The minimum distance the player must move to update 
            the persisted geoshader subchunks in the world. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.GeoShaderSettings.levels">
            <summary> Settings controlling different levels of details of geoshaders within a chunk
            (subchunk level of detail). See <see cref="T:Arterra.Configuration.Quality.GeoShaderSettings.DetailLevel"/> for more information </summary>
        </member>
        <member name="T:Arterra.Configuration.Quality.GeoShaderSettings.DetailLevel">
            <summary> A single subchunk detail level within a chunk. 
            A detail level indicates the amount of geometry geoshaders
            will expend in a designated region from the player. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.GeoShaderSettings.DetailLevel.Level">
            <summary> The amount of detail(0 being highest) geoshaders are hinted to generate.
            Generally geoshaders will reduce geometry by 50% for each increase in level. </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.GeoShaderSettings.DetailLevel.Distance">
            <summary>
            The additive distance in grid space up until which the detail level will render.
            This is calculated by summing the previous distances before it in <see cref="F:Arterra.Configuration.Quality.GeoShaderSettings.levels"/>
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.GeoShaderSettings.DetailLevel.IncreaseSize">
            <summary> Whether or not this detail level is of a higher depth (twice the size) from the 
            previous level before it in <see cref="F:Arterra.Configuration.Quality.GeoShaderSettings.levels"/>. Larger subchunks reduce synchronization barriers
            and expedite generation and rendering. </summary>
            <remarks>The minimum subchunk size is decided by the number of times size is increased 
            in <see cref="F:Arterra.Configuration.Quality.GeoShaderSettings.levels"/>. (<see cref="F:Arterra.Configuration.Quality.Terrain.mapChunkSize"/>/(2 ^ N))</remarks>
        </member>
        <member name="T:Arterra.Configuration.Quality.LightBaker">
            <summary>
            Settings for the light baker, responsible for dynamically baking
            lighting in the world as the world changes. Light-baking is based off
            a procedurally rebaking system that propogates light divided into sub-chunks
            within a terrain chunk of the world.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.LightBaker.SubChunkDivisions">
            <summary>
            The size of lighting sub-chunks relative to the size of the chunk.
            = <see cref="F:Arterra.Configuration.Quality.Terrain.mapChunkSize"/> / SubChunkSize
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.LightBaker.MaxObjectSubChunkUpdatesPerTick">
            <summary> The maximum number of object light
            sub-chunks that can be updated in a single tick.
            Constrains both time and memory usage of the light baker. 
            Recommended less than 2k </summary>
        </member>
        <member name="F:Arterra.Configuration.Quality.LightBaker.MaxShadowSubChunkUpdatesPerTick">
            <summary> The maximum number of shadow sub-chunks
            that can be updated in a single tick.
            Constrains both time and memory usage of the light baker.
            Recommended less than 15k </summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Inventory">
            <summary> Settings controlling the size and apperance of the inventory,
            a system allowing the player to hold and use 
            <see cref="N:Arterra.Configuration.Generation.Item"> items </see>. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Inventory.PrimarySlotCount">
            <summary> The amount of slots in the primary inventory, the hotbar. This is
            equivalent to the maximum amount of items that can be held in the hotbar.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Inventory.SecondarySlotCount">
            <summary> The amount of slots in the secondary inventory, the hidden inventory. This is
            equivalent to the maximum amount of items that can be held in the hidden inventory. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Inventory.SelectedColor">
            <summary>
            The color of the selected slot in the <see cref="F:InventoryController.Primary">Primary Inventory</see>, or
            the hotbar. This color is used to indicate which item currently has the status of being <see cref="P:InventoryController.Selected">
            selected. </see> 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Inventory.BaseColor">
            <summary> The color of the base slot in the Inventory. The color 
            of the slot when it is empty (the item held by the slot is null). </summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Player.Settings">
            <summary>
            Settings pertinent to the player object itself, and how the user experiences the world.
            All settings collected here are volatile during gameplay and the developer should be aware
            of this when accessing these settings.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Settings.movement">
            <summary> Settings describing how the player moves. See <see cref="T:Arterra.Configuration.Gameplay.Player.Movement"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Settings.Camera">
            <summary> Settings controlling how the inputs get translated into camera rotations. See <see cref="T:Arterra.Configuration.Gameplay.Player.Camera"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Settings.Interaction">
            <summary> Settings controlling how the player interacts with the world. See <see cref="T:Arterra.Configuration.Gameplay.Player.Interaction"/> for more information.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Settings.Physicality">
            <summary>Settings controlling the player's physical statistics. See <see cref="F:Arterra.Configuration.Gameplay.Player.Settings.Physicality"/> for more info.</summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Settings.ShowCrosshair">
            <summary> Whether or not the player's cursor is shown. </summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Player.Movement">
            <summary>
            A collection of settings that describe how the player moves.
            Movement settings may change during gameplay.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Movement.walkSpeed">
            <summary> The maximum speed the player can walk at, in terms of world space. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Movement.runSpeed">
            <summary> The maximum speed the player can run at, in terms of world space. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Movement.jumpForce">
            <summary>  How much force is applied to the player when they jump, in terms of world space. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Movement.acceleration">
            <summary> How much speed the user gains when moving, in terms of world space. The acceleration is added onto velocity
            meaning the comparative strength of friction increases with velocity. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Movement.groundStickDist">
            <summary> How far below the player the ground needs to be for the player to be 'on the ground'. 
            Being on the ground may affect their ability to jump and the friction they experience. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Movement.flightSpeedMultiplier">
            <summary> A multiplier applied to all movement limits when the player is flying. For example, a multiplier of 2
            will mean the player will fly twice as fast as they can run </summary>
        </member>
        <member name="M:Arterra.Configuration.Gameplay.Player.Movement.Clone">
            <summary> Creates a new instance of the movement settings, 
            copying the values from this instance. </summary>
            <returns>The new instance</returns>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Player.Physicality">
            <summary> Settings describing the player's vitaltiy, or the 
            combat ability and/or physical statistics of the player. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.AttackDamage">
            <summary>The base damage the player deals when attacking entities without using any items. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.AttackFrequency">
            <summary>The amount of time in seconds between successive attacks from the player that will be processed.</summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.KnockBackStrength">
            <summary> The strength by entities are knocked back when hit by the player.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.InvincTime">
            <summary> The amount of time the player is invincible after taking damage. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.HoldBreathTime">
            <summary> The amount of time the player can stay underwater before they start suffocating.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.MaxHealth">
            <summary> The maximum health of the player.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.NaturalRegen">
            <summary> How much player's health will change per second. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.DecompositionTime">
            <summary> The amount of time after the player dies until its body dissapears.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Physicality.weight">
            <summary> The weight of the player </summary>
        </member>
        <member name="M:Arterra.Configuration.Gameplay.Player.Physicality.Clone">
            <summary> Clones the settings </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Player.Interaction">
            <summary>
            Settings governing the user's ability to interact with the world.
            This includes Terraforming, the act of changing the terrain map's information,
            and interaction with entities and more.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Interaction.TerraformRadius">
            <summary> The radius, in grid space, of the spherical region around the user's
            cursor that will be modified when the user terraforms the terrain. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Interaction.DefaultTerraform">
            <summary>  The default information used for terrain terraforming if no tag is applied.
            See <see cref="T:ToolTag"/> for more information </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Interaction.ReachDistance">
            <summary> The maximum distance, in grid space, that the user can terraform the terrain from.
            That is, the maximum distance the cursor can be from the user's camera for the user
            to be able to terraform around the cursor.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Interaction.CylinderRadius">
            <summary> The radius around the view vector which will be searched when ray casting to determine
            where the view ray intersects the ground.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Interaction.PickupRate">
            <summary> When picking up items, the speed at which resources from 
            <see cref="T:IAttackable"> entities that can be collected from </see> are collected. </summary>
        </member>
        <member name="M:Arterra.Configuration.Gameplay.Player.Interaction.Clone">
            <summary> Clones the terraform settings. 
            Is necessary for modification through the
            <see cref="T:Arterra.Configuration.Option`1"/> lazy config system. </summary>
            <returns>The duplicated terraform settings. </returns>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Player.Camera">
            <summary> Controls how the camera rotates and responds to player input. Notably
            settings controlling the camera's responsiveness, sensitivity, and limits to 
            its rotation are contained here.  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Camera.Sensitivity">
            <summary> How sensitive the camera is to mouse movements. A higher number will require smaller
            movements for larger rotations </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Camera.clampVerticalRotation">
            <summary>Whether or not camera rotations are clamped around the x-axis</summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Camera.MinimumX">
            <summary>The minimum x-axis angle that the camera can rotate; the farthest the player can look down</summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Camera.MaximumX">
            <summary>The maximum x-axis angle that the camera can rotate; the farthest the player can look up</summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Camera.smooth">
            <summary>Whether rotations should slowly follow player inputs. If false, rotations will jump to the forward axis, 
            possibly making the rotation seem rough and jittery </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Player.Camera.smoothTime">
            <summary>If <see cref="F:Arterra.Configuration.Gameplay.Player.Camera.smooth"/>, the time, in seconds to rotate to a new orientation.</summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Gamemodes">
            <summary>
            Settings describing different game settings the player can play with.
            These settings may drastically change the game's difficulty and
            can drastically change the player's experience.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Gamemodes.Flight">
            <summary> Whether the player can toggle flight; whether the player can fly </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Gamemodes.Invulnerability">
            <summary> Whether the player can recieve damage or die. Whether health is a concept for the player. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Gamemodes.Intangiblity">
            <summary> Whether the player will collide with solid objects and be subject to in-game forces.</summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Gamemodes.KeepInventory">
            <summary> Whether the player can keep their inventory on death </summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Environment">
            <summary> Settings controlling environment constants of the world. Or aspects of 
            the world that cannot be directly influenced within the game's narrative.
            We try to reduce the amount of non-narrative environment settings to keep the 
            game as immersive and open as possible. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.timeMultiplier">
            <summary> How fast time progresses in the game world relative to real time. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.startHour">
            <summary> The time of day that the world starts at. The time in hours since midnight that
            the player starts at when they first enter the world. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.sunriseHour">
            <summary> The time of day that the day starts at. The time in hours since midnight of the sunrise,
            or the time when the sun is parallel to the horizon on its upper arc. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.sunsetHour">
            <summary> The time of day that the day ends at. The time in hours since midnight of the sunset,
            or the time when the sun is parallel to the horizon on its lower arc. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.maxSunIntensity">
            <summary>  The maximum intensity of the sun light. This is the intensity of the light when the sun is at its peak. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.maxMoonIntensity">
            <summary> The maximum intensity of the moon light. This is the intensity of the light when the moon is at its peak. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.sunIntensityCurve">
            <summary> How the intensity of the sun's light changes over the course of the day. The x axis is the percentage through the day, with 0 and 1
            being <see cref="F:Arterra.Configuration.Gameplay.Environment.sunriseHour"/> exactly a day apart. The y axis is the intensity of the sun's light as a percentage of <see cref="F:Arterra.Configuration.Gameplay.Environment.maxSunIntensity"/>.</summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Environment.moonIntensityCurve">
            <summary> How the intensity of the moon's light changes over the course of the day. The x axis is the percentage through the day, with 0 and 1
            being <see cref="F:Arterra.Configuration.Gameplay.Environment.sunriseHour"/> exactly a day apart. The y axis is the intensity of the moon's light as a percentage of <see cref="F:Arterra.Configuration.Gameplay.Environment.maxMoonIntensity"/>.</summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.KeyBind">
            <summary> A list of conditions that is assigned a name. During gameplay, a system
            may bind an action to this list through its name which will be triggered
            when the conditions are met. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.bindings">
            <summary> A list of conditions that must be met for the action to be triggered.
            See <see cref="T:Arterra.Configuration.Gameplay.KeyBind.Binding"/> for more information. </summary>
        </member>
        <member name="P:Arterra.Configuration.Gameplay.KeyBind.Bindings">
            <summary> Accessor to unwrap the binding from the option  </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.AdditionalTriggerCount">
            <summary> An additional number of times the keybind must be triggered to activate. (Ex. double click) </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.AxisMappings">
            <summary> If <see cref="T:Arterra.Configuration.Gameplay.KeyBind.BindPoll"/> is <see cref="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Axis"/>, the 
            translation of <see cref="T:UnityEngine.KeyCode"/> to the axis name that is being polled. </summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.KeyBind.Binding">
            <summary> A single condition polling a singular type of input from the user. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.Binding.Key">
            <summary> The keycode of the input that is being polled. If <see cref="T:Arterra.Configuration.Gameplay.KeyBind.BindPoll"/> is <see cref="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Axis"/>,
            this is the alias for the axis that is being polled. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.Binding.PollType">
            <summary> The type of polling that is being done on the input. See <see cref="T:Arterra.Configuration.Gameplay.KeyBind.BindPoll"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.Binding.IsAlias">
            <summary> Whether the binding is an alias for another binding. If true, the binding is an alias for the 
            first binding before it in the <see cref="F:Arterra.Configuration.Gameplay.KeyBind.bindings"/> list that isn't an alias. All alias directly 
            proceeding a non-alias binding will allow the binding to evaluate as true if any of the aliases are true. </summary>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.KeyBind.BindPoll">
            <summary> The type of polling that is being done on the input. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Axis">
            <summary>
            If the poll type is axis, uses unity's <see cref="M:UnityEngine.Input.GetAxis(System.String)"/> which returns an analog-like
            value between -1 and 1 for the requested axis. The axis is determined by the <see cref="T:UnityEngine.KeyCode"/> of the binding
            transformed through <see cref="F:Arterra.Configuration.Gameplay.KeyBind.AxisMappings"/>.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Exclude">
            <summary> If the poll type is exclude, the binding will only evaluate as true if the input is not being being held. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Hold">
            <summary> If the poll type is hold, the binding will only evaluate as true if the input is being held. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Down">
            <summary> If the poll type is down, the binding will only evaluate as true on the frame the input is pressed. 
            That is the frame where the input is held where it wasn't held in the previous frame. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Up">
            <summary> If the poll type is up, the binding will only evaluate as true on the frame the input is released.
            That is the frame where the input is not held where it was held in the previous frame. </summary>
        </member>
        <member name="M:Arterra.Configuration.Gameplay.KeyBind.IsTriggered(System.Func{UnityEngine.KeyCode,System.Boolean},System.Single@)">
            <summary>
            Determines whether or not the KeyBind is triggered. Evaluates all conditions
            in <see cref="F:Arterra.Configuration.Gameplay.KeyBind.bindings"/> to determine whether the associated action should be triggered.
            </summary>
            <param name="axis">If the <see cref="F:Arterra.Configuration.Gameplay.KeyBind.bindings"/> contains an <see cref="F:Arterra.Configuration.Gameplay.KeyBind.BindPoll.Axis">axis</see>, the axis
            value of the last axis poll in the list. </param>
            <returns>Whether or not the KeyBind has been triggered. </returns>
        </member>
        <member name="M:Arterra.Configuration.Gameplay.KeyBind.ConsumeKeys(System.Collections.Generic.HashSet{UnityEngine.KeyCode})">
            <summary> Consumes all pressed keys by adding them to the exclusion set. </summary>
            <param name="BlockedExclusion">The exclusion set pressed keys will be added to</param>
        </member>
        <member name="T:Arterra.Configuration.Gameplay.Statistics">
            <summary> A collection of settings describing optional statistics that can be displayed in the game.
            These statistics are optional and can be toggled on or off; viewing certain statistics may
            break immersion or provide an unfair advantage. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Statistics.DisplayEntityStats">
            <summary> Whether to display the entity's statistics like health, hunger, etc. in the game.
            Whether an entity displays is able to display its statistics is up to the entity's implementation. </summary>
        </member>
        <member name="F:Arterra.Configuration.Gameplay.Statistics.DisplayEntityDamage">
            <summary> Whether to display the pop-up damage dealt to an entity in the game. </summary>
        </member>
        <member name="T:Arterra.Configuration.Config">
            <summary>
            Config is the root class anchoring a settings tree which contains
            all settings for the game. Any trivial constants not inherent to the functionality
            of an algorithm should be sourcable from this tree. Configs are unique
            to each world and a different config object, rooting a unique settings tree,
            will be loaded before loading each world. 
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Config.CURRENT">
            <summary>
            A singleton instance rooting the settings tree for the currently selected world.
            Note, this does not guarantee that each reference type is a unique instance
            as is described in <see cref="T:Arterra.Configuration.Option`1"/>. If a reference type's subtree is unchanged
            it is likely the same instance as the <see cref="P:Arterra.Configuration.Config.TEMPLATE"/>. It only means that the tree 
            sufficiently describes all settings for the world.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.Config.TEMPLATE">
            <summary>
            A singleton instance rooting the template(default) settings of a world. This should not be
            used to acquire settings for a world, but primarily for creating new settings trees. Due to the lazy
            nature of the tree <seealso cref="T:Arterra.Configuration.Option`1"/>, some portions of <see cref="P:Arterra.Configuration.Config.CURRENT"/> may be subsets of this tree, 
            but it should not be assumed that the two are the same.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.Seed">
            <summary>
            The seed used to create unique generation for each world. Any generation algorithm should source its
            noise from a function that considers this seed as a factor. The same world should be generated
            given the same seed. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config._Quality">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Config._Generation">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Config._GamePlay">
            <exclude />
        </member>
        <member name="F:Arterra.Configuration.Config._System">
            <exclude />
        </member>
        <member name="P:Arterra.Configuration.Config.Quality">
            <summary> <see cref="T:Arterra.Configuration.Config.QualitySettings"/>  </summary>
        </member>
        <member name="P:Arterra.Configuration.Config.Generation">
            <summary> <see cref="T:Arterra.Configuration.Config.GenerationSettings"/>  </summary>
        </member>
        <member name="P:Arterra.Configuration.Config.GamePlay">
            <summary> <see cref="T:Arterra.Configuration.Config.GamePlaySettings"/>  </summary>
        </member>
        <member name="P:Arterra.Configuration.Config.System">
            <summary> <see cref="T:Arterra.Configuration.Config.SystemSettings"/>  </summary>
        </member>
        <member name="T:Arterra.Configuration.Config.QualitySettings">
            <summary>
            The settings describing factors controlling the quality of the world. Increasing quality
            will commonly decrease performance. Certain settings may also require expensive resources
            which the user may not have. Currently, it is the user's responsibility to know the limitations
            of their device. Quality settings cannot be changed during gameplay (once a world is loaded).
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.QualitySettings.Atmosphere">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Quality.Atmosphere"/>  </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.QualitySettings.Lighting">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Quality.LightBaker"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.QualitySettings.Terrain">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Quality.Terrain"/>  </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.QualitySettings.GeoShaders">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Quality.GeoShaderSettings"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.QualitySettings.Memory">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Quality.Memory"/>  </summary>
        </member>
        <member name="T:Arterra.Configuration.Config.TooltipSettings">
            <summary>
            The settings controlling the tooltip system used in the game.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.TooltipSettings.EnableTooltips">
            <summary>
            Whether tooltips are enabled.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.TooltipSettings.MaxPopups">
            <summary>
            Maximum number of tooltips to display simultaneously.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.TooltipSettings.MinDisplayTimeInSeconds">
            <summary>
            Minimum display time for each tooltip in seconds.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.TooltipSettings.TooltipEvents">
            <summary>
            The events that can trigger tooltips.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.TooltipSettings.TooltipDismissorEvents">
            <summary>
            The events that can dismiss tooltips.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.Config.GenerationSettings">
            <summary>
            The settings describing factors controlling the generation of the world. This is exposed
            enabling consumer modification of the world's generation. However it is the user's responsibility
            to understand what each setting does and improperly modified settings may cause the world to 
            fail to generate or be corrupted. Generation settings cannot be changed during gameplay (once a world is loaded).
            </summary>
            <remarks> 
            Though generation settings may be changed at any time in the <see cref="T:MenuHandler"/>, modification after the world
            is loaded may result in corruption of the world or the world changing around the player, potentially causing the player
            to be trapped within the terrain. It is recommended to adjust these settings only before first loading a world.
            </remarks>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Noise">
            <summary> The registry containing settings for all noise functions used in the world's generation. 
            The number of noise functions available to be sample is limited to whatever is in this registry. 
            See <see cref="T:Arterra.Configuration.Generation.Noise"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Terrain">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Generation.Map"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Surface">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Generation.Surface"/>  </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Biomes">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Generation.Biome.Generation"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Structures">
            <summary> See here for more information: <see cref="T:Arterra.Configuration.Generation.Structure.Generation"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Materials">
            <summary> The registry containing settings for all materials used in the world's generation. 
            Any material not in this registry will not be recognized by the game and usage/deserialization of it may 
            result in undefined behavior. See here for more information: <see cref="T:Arterra.Configuration.Generation.Material.Generation"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Items">
            <summary> The registry containing all items referencable in any way throughout the game. Any item
            not in this registry will not be recognized by the game and usage/deserialization of it may 
            result in undefined behavior. See here for more information: <see cref="T:Arterra.Configuration.Generation.Item.Authoring"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Entities">
            <summary>The registry containing all entities referencable in any way throughout the game. Any entity
            not in this registry will not be recognized by the game and usage/deserialization of it may 
            result in undefined behavior. See here for more information: <see cref="T:Arterra.Configuration.Generation.Entity.Authoring"/> </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GenerationSettings.Textures">
            <summary> A registry containing all textures used within the game. Similar to a texture 
            atlas, this registry is copied to the GPU and to be referenced by shaders. </summary>
        </member>
        <member name="T:Arterra.Configuration.Config.GamePlaySettings">
            <summary>
            The settings describing factors controlling the user's gameplay experience. Some factors
            may result in varying difficulty but it is up to the user to decide. These settings are <b>volatile</b>
            during gameplay meaning they can be changed at any time (primarily through the <see cref="T:PauseHandler"/>).
            Thus, systems referencing them should be prepared for changes at any time during runtime.
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GamePlaySettings.Input">
            <summary> The registry of all keybinds that are used to bind player input to actions within the game.
            See <see cref="T:Arterra.Configuration.Gameplay.KeyBind"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GamePlaySettings.Player">
            <summary> Controls how the player moves through the world. See <see cref="!:Gameplay.Movement"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GamePlaySettings.Gamemodes">
            <summary> Controls how the player experiences the world. See <see cref="!:Gameplay.Interaction"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GamePlaySettings.Inventory">
            <summary> Controls the players inventory. See <see cref="T:Arterra.Configuration.Gameplay.Inventory"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GamePlaySettings.Time">
            <summary> Settings controlling environment constants of the world. See <see cref="T:Arterra.Configuration.Gameplay.Environment"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.GamePlaySettings.Statistics">
            <summary> Settings controlling the optional visual statistics displayed to the player. See <see cref="T:Arterra.Configuration.Gameplay.Statistics"/> for more information. </summary>
        </member>
        <member name="T:Arterra.Configuration.Config.SystemSettings">
            <summary>
            Settings imperative to the function of the game. These are hidden from the user by default as they are
            somewhat inherent to the game's function. However, this exists to organize advanced settings 
            future for advanced users and developers to modify. 
            </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.SystemSettings.Crafting">
            <summary> Controls how the player can create items. See <see cref="!:Gameplay.Crafting"/> for more information. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arterra.Configuration.Config.SystemSettings.FurnaceFormulas" -->
        <!-- Badly formed XML comment ignored for member "F:Arterra.Configuration.Config.SystemSettings.MortarFormulas" -->
        <member name="F:Arterra.Configuration.Config.SystemSettings.Armor">
            <summary> Controls how the player's armor is displayed. See <see cref="!:Gameplay.Armor"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.SystemSettings.TerrainUpdation">
            <summary> Controls how the terrain is updated. See <see cref="T:Arterra.Configuration.Intrinsic.TerrainUpdation"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.SystemSettings.WorldApperance">
            <summary> Controls how the world looks in the main menu. See <see cref="T:Arterra.Configuration.Intrinsic.WorldApperance"/> for mor information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.SystemSettings.ReadBack">
            <summary> The settings for the readback system. See <see cref="T:Arterra.Configuration.Intrinsic.Readback"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Configuration.Config.SystemSettings.GameplayModifyHooks">
            <summary>
            Registry for hooks that are called when a certain setting is modified. This registry is generated
            during runtime and is not customizable by the user. If a certain member has a UIModifiable attribute
            defined, the gameplay menu will trigger a hook associated with that name if it or any sub-member is changed.
            </summary>
        </member>
        <member name="M:Arterra.Configuration.Config.Create">
            <summary>
            Creates a new instance of the <see cref="T:Arterra.Configuration.Config"/> object by instantiating
            the <see cref="P:Arterra.Configuration.Config.TEMPLATE"/> and setting the seed to a random value.
            </summary> <returns>The newly created<see cref="T:Arterra.Configuration.Config"/> object.</returns>
        </member>
        <member name="T:Arterra.Configuration.IOption">
            <summary>
            The interface for an Option template. Specifies
            basic functionality necessary for modification and storage
            of <see cref="T:Arterra.Configuration.Option`1"/> objects within the <see cref="T:Arterra.Configuration.Config"/> tree.
            </summary>
        </member>
        <member name="P:Arterra.Configuration.IOption.IsDirty">
            <summary> Returns whether the object has been modified. An option
            is dirty if its subtree is not the same as the template.  </summary>
        </member>
        <member name="M:Arterra.Configuration.IOption.Clone">
            <summary> Clones the object. If the object is a reference type, it will be cloned.
            Value types are clones by default. THis also sets the object as dirty. </summary>
        </member>
        <member name="T:Arterra.Configuration.Option`1">
            <summary>
            A wrapper representing a logical node within the <see cref="T:Arterra.Configuration.Config"/> tree. An option consistutes
            the atomic unit within our lazy storage system, meaning that if an option is dirty only the immediate
            subtree up until another option is encountered will be stored. By the same token, a higher density of
            options within the tree will result in finer granularity of what can be lazily ignored and vice versa. 
            </summary>
            <remarks> 
            Upon modification, all options along the path to the root will be cloned and marked as dirty before any setting
            is modified. When this happens, only options along this path will be different from the template while the 
            rest of the tree will point to subsections of the template. 
            
            Consequently, there are several rules one must adhere to when building or adding onto the <see cref="T:Arterra.Configuration.Config"/> tree.
            <list type="bullet">
            <item> 
                <term><b>Non-Option containers can hold value types and options only.</b></term> 
                <description> 
                If a non-option type holds a reference type when the non-option type is cloned (a shallow copy),
                the reference type will not be cloned. The system is not capable of identifying this and thus this
                will result in the reference type being shared between the two instances.
                </description>
             </item>
            <item> 
                <term> <b>Options can hold class or value types only.</b></term> 
                <description> 
                 Options are the logical unit within the tree and are capable of holding any type 
                 as it tracks whether or not it is a clone and how to clone it. 
                </description>
            </item>
            <item> 
                <term> <b>Primitives are treated the same as value types.</b></term>
                <description>
                Primitives include all <see href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types">
                C# built-in types</see>, strings, and enums.
                </description>
            </item>
            </list>
            </remarks>
            <typeparam name="T"> The type of the object to be stored within the option.  </typeparam>
        </member>
        <member name="F:Arterra.Configuration.Option`1.value">
            <summary> The instance stored within the option wrapper. </summary>
        </member>
        <member name="M:Arterra.Configuration.Option`1.op_Implicit(Arterra.Configuration.Option{`0})~`0">
            <summary> Implicitly converts the option to the value it holds. This is useful for obtaining the value</summary>
            <param name="option"> The option itself </param>
        </member>
        <member name="M:Arterra.Configuration.Option`1.op_Implicit(`0)~Arterra.Configuration.Option{`0}">
            <summary> Implicitly converts the value to an option. This is useful for setting the value  </summary>
            <param name="val">The value which we want to set to <see cref="F:Arterra.Configuration.Option`1.value"/></param>
        </member>
        <member name="M:Arterra.Configuration.Option`1.ShouldSerializevalue">
            <summary>
            Returns whether one should serialize(save) this field (i.e. the type it holds).
            An option should be serialized if it <see cref="F:Arterra.Configuration.Option`1.isDirty"/>. 
            Used by <see cref="N:Newtonsoft.Json"/> to determine if the field needs to be saved.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Arterra.Configuration.Option`1.IsDirty">
            <summary> Whether or not the option has been modified (i.e. different from the template) </summary>
        </member>
        <member name="M:Arterra.Configuration.Option`1.Clone">
            <summary>
            Clones the object. If it is a value type, it will be cloned by default. 
            If it is a reference type, it will be cloned if it implements <see cref="T:System.ICloneable"/>,
            ILists are cloned by default by creating a new instance of the list and copying the elements.
            </summary>
        </member>
        <member name="T:Arterra.Configuration.ReferenceOption`1">
            <summary> Similar to <see cref="T:Arterra.Configuration.Option`1"/> except that it is serialized by reference
            instead of value by Unity(into a .asset file). This may be a requirement for
            serializing abstract types/interfaces to Unity's inspector. 
            <see cref="T:UnityEngine.SerializeReference"/> for more information. </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Arterra.Configuration.ReferenceOption`1.value">
            <summary> The instance stored within the option wrapper. </summary>
        </member>
        <member name="M:Arterra.Configuration.ReferenceOption`1.op_Implicit(Arterra.Configuration.ReferenceOption{`0})~`0">
            <summary> Implicitly converts the option to the value it holds. This is useful for obtaining the value</summary>
            <param name="option"> The option itself </param>
        </member>
        <member name="M:Arterra.Configuration.ReferenceOption`1.op_Implicit(`0)~Arterra.Configuration.ReferenceOption{`0}">
            <summary> Implicitly converts the value to an option. This is useful for setting the value  </summary>
            <param name="val">The value which we want to set to <see cref="F:Arterra.Configuration.ReferenceOption`1.value"/></param>
        </member>
        <member name="M:Arterra.Configuration.ReferenceOption`1.ShouldSerializevalue">
            <summary>
            Returns whether one should serialize(save) this field (i.e. the type it holds).
            An option should be serialized if it <see cref="F:Arterra.Configuration.ReferenceOption`1.isDirty"/>. 
            Used by <see cref="N:Newtonsoft.Json"/> to determine if the field needs to be saved.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Arterra.Configuration.ReferenceOption`1.IsDirty">
            <summary> Whether or not the option has been modified (i.e. different from the template) </summary>
        </member>
        <member name="M:Arterra.Configuration.ReferenceOption`1.Clone">
            <summary>
            Clones the object. If it is a value type, it will be cloned by default. 
            If it is a reference type, it will be cloned if it implements <see cref="T:System.ICloneable"/>,
            ILists are cloned by default by creating a new instance of the list and copying the elements.
            </summary>
        </member>
        <member name="T:Arterra.UI.ToolTips.TooltipSystem">
            <summary>
            Tooltip System managing all tooltips used in the game.
            </summary>
        </member>
        <member name="M:Arterra.UI.ToolTips.TooltipSystem.Initialize">
            <summary>
            Initializes the tooltip system. 
            
            Hooks into necessary events to snoop for tooltip.
            Read configuration data for tooltip display settings. 
            </summary>
        </member>
        <member name="T:Arterra.UI.ToolTips.TooltipPipeline">
            <summary>
            Tooltip Pipeline handling the flow of tooltip data and rendering.
            </summary>
        </member>
        <member name="T:Arterra.Core.Player.PlayerStreamer">
            <summary> The entity instance of the player holding all data specific
            to a single instance of the player. Note, multiple PlayerStreamers can 
            exist at the same time. </summary>
            <remarks>Using the analogy that <see cref="T:Arterra.Core.Player.PlayerHandler"/> is the soul of the player, 
            <see cref="T:Arterra.Core.Player.PlayerStreamer"/> would be a singular corpreal body of the player. </remarks> 
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer._Setting">
            <summary>Reference to the player's entity settings. See <see cref="T:Arterra.Core.Player.PlayerStreamer.PlayerSettings"/></summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerStreamer.Entity">
            <summary> Obtains a new instance of the player streamer </summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerStreamer.Setting">
            <summary> Retrieves the player's entity settings. </summary>
        </member>
        <member name="T:Arterra.Core.Player.PlayerStreamer.PlayerSettings">
            <summary>The settings controlling the entity properties of the player. </summary>
        </member>
        <member name="T:Arterra.Core.Player.PlayerStreamer.Player">
            <summary>The entity representing a player instance. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.settings">
            <summary> The <see cref="T:Arterra.Core.Player.PlayerStreamer.PlayerSettings">entity settings
            </see> of this player instance </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.player">
            <summary>The root UnityGameObject tied to this player instance. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.camera">
            <summary> The <see cref="T:Arterra.Core.Player.PlayerStreamer.PlayerSettings"/> managing the camera's
            movement if this player instance is currently streaming. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.PrimaryI">
            <summary> The primary inventory/hotbar tied to this player.</summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.SecondaryI">
            <summary> The secondary inventory tied to this player. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.ArmorI">
            <summary> The armor inventory tied to this player. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.vitality">
            <summary>This player's health and attack patterns. See <see cref="T:Arterra.Core.Player.PlayerVitality"/> </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.collider">
            <summary>This player's terrain collider. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.status">
            <summary> This player instance's relation to the actual 
            user's input and what they see. See <see cref="T:Arterra.Core.Player.PlayerStreamer.Player.StreamingStatus"/> </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerStreamer.Player.Effects">
            <summary> The Controller responsible for abstracting the player's
            animations as effects. See <see cref="T:PlayerActionEffects"/> for more info. </summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerStreamer.Player.transform">
            <summary>Getter for the <see cref="F:Arterra.Core.Player.PlayerStreamer.Player.collider">Player Collider's</see> transform.</summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerStreamer.Player.Facing">
            <summary> The quaternion for the direction the player instance is facing. </summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerStreamer.Player.head">
            <summary>The location of the player's head/camera in grid space.</summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerStreamer.Player.positionWS">
            <summary>The location of the player's <see cref="P:Arterra.Configuration.Generation.Entity.Entity.position"/> in world space. </summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerStreamer.Player.IsDead">
            <summary> Whether or not the player is dead. <see cref="P:IAttackable.IsDead"/> </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.Interact(Arterra.Configuration.Generation.Entity.Entity)">
            <summary>Interacts with the Player Instance. See <see cref="M:IAttackable.Interact(Arterra.Configuration.Generation.Entity.Entity)"/></summary>            
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.Collect(Arterra.Configuration.Generation.Entity.Entity,System.Single)">
            <summary> Collects items from the dead player instance
            if it contains items in its inventories, causing
            it to slowly decay. <see cref="M:IAttackable.Collect(Arterra.Configuration.Generation.Entity.Entity,System.Single)"/> </summary>
            <param name="target"> The entity collecting the item(or null) </param>
            <param name="amount">The speed at which items are removed</param>
            <returns>The collected item, or null.</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.TakeDamage(System.Single,Unity.Mathematics.float3,Arterra.Configuration.Generation.Entity.Entity)">
            <summary>Attempts to apply a specific amount of damage and knockback
            to the player. Success depends on player's defense systems such as
            <see cref="F:Arterra.Configuration.Gameplay.Player.Physicality.InvincTime">invincibility </see>  </summary>
            <param name="damage">The attempted damage to deal to the player</param>
            <param name="knockback">The attempted knockback to deal to the player</param>
            <param name="attacker">If the damage was dealt by an entity, the attacker instance.
            Otherwise, this field can be omitted. </param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.OnMounted(IRidable)">
            <summary>Handler that's called when the player mounts an entity <see cref="T:IRider"/></summary>
            <param name="mount">The mount the player is riding</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.OnDismounted(IRidable)">
            <summary>Handler that's called when the player dismounts an entity <see cref="T:IRider"/></summary>
            <param name="mount">The mount the player is no longer riding</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.Build">
            <summary> Constructs a fresh clean player instance. With 
            the appropriate settings based off the
            /// <see cref="P:Arterra.Configuration.Config.CURRENT">current world</see> </summary>
            <returns>The newly instantiated player instance.</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.Initialize(Arterra.Configuration.Generation.Entity.EntitySetting,UnityEngine.GameObject,Unity.Mathematics.float3)">
            <summary>Initializes the player entity with its entity settings.
            See <see cref="M:EntityManager.InitializeE(Arterra.Configuration.Generation.Entity.Entity,Unity.Mathematics.float3,System.UInt32)"/> </summary>
            <param name="setting">The settings of the player entity</param>
            <param name="Controller">The root Unity Gameobject of the player</param>
            <param name="GCoord">The coordinate in grid space of the player</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.Deserialize(Arterra.Configuration.Generation.Entity.EntitySetting,UnityEngine.GameObject,Unity.Mathematics.int3@)">
            <summary>Deserializes the player entity after it has been serialized for storage.
            The player entity may be saved by the EntitySystem or in a seperate file depending on 
            whether it is streaming, but in either case, this function must be called. </summary>
            <param name="setting">The settings of the player entity</param>
            <param name="Controller">The root Unity Gameobject of the player</param>
            <param name="GCoord">Retrievs the saved coordinate in grid space of the player</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.Update">
            <summary> Updates the player instance via the Entity system.
            This function should and will not be called if the player
            is the current active player tied to the user. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.Disable">
            <summary>Disables the player instance, releasing all resources tied to it. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerStreamer.Player.OnDrawGizmos">
            <summary>Draws Gizmos overlays for the player (Unity Editor Only).</summary>
        </member>
        <member name="T:Arterra.Core.Player.PlayerHandler">
            <summary> The root handler of the currently active player.  </summary>
            <remarks> If <see cref="T:Arterra.Core.Player.PlayerStreamer"/> were analogous to the 
            player's current body, this class would be the player's soul </remarks>///  
        </member>
        <member name="F:Arterra.Core.Player.PlayerHandler.data">
            <summary>The current active <see cref="T:Arterra.Core.Player.PlayerStreamer.Player"> streamer </see>
            or instance of the player. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerHandler.Viewer">
            <summary> The transform of the Unity gameobject representing the viewer </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerHandler.Camera">
            <summary> The transform of the current Unity MainCamera  </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerHandler.active">
            <summary> Whether or not the player is active; whether or not
            the user has control of the player instance  </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerHandler.Initialize">
            <summary> Initializes the player and retrieves/creates
            a new <see cref="T:Arterra.Core.Player.PlayerStreamer.Player">Player Instance</see>
            for it. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerHandler.Release">
            <summary>Releases the player handler and all resources tied to handling the player. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerHandler.RespawnPlayer(System.Action)">
            <summary> Respawns the player initiating the respawn process.
            This process will create a new  <see cref="T:Arterra.Core.Player.PlayerStreamer.Player">Player Instance</see>
            at a set respawn location, abandoning the current active instance. </summary>
            <param name="cb">The option action to perform once respawned</param>
        </member>
        <member name="T:Arterra.Core.Player.PlayerMovement">
            <summary>The Manager responsible for handling all types of player movement
            and switching between them depending on the situation.  </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerMovement.IsSprinting">
            <summary>Whether or not the player is currently sprinting.</summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerMovement.InputDir">
            <summary>The xz direction the player desires to move </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerMovement.Initialize">
            <summary>Initializes the players movements and binds the keybind entrypoints to the system. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerMovement.Update">
            <summary> Updates the player's movement. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerMovement.GetSpeed2D(Unity.Mathematics.float3)">
            <summary>Gets the 2D velocity as a 3D vector normalized over the player's maximum movement speed. </summary>
            <param name="velocity">The vector whose speed is returned</param>
            <returns>The maxspeed normalized 3D vector</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerMovement.GetSpeed3D(Unity.Mathematics.float3)">
            <summary>Gets the 3D velocity as a 3D vector normalized over the player's maximum movement speed. </summary>
            <param name="velocity">The vector whose speed is returned</param>
            <returns>The maxspeed normalized 3D vector</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerMovement.AddVelocity2D(Unity.Mathematics.float2,System.Single)">
            <summary>Adds the 2D delta velocity to the player's xz velocity whilst
            respecting the player's current and maximum movement speeds. </summary>
            <param name="delta">The change to the player's xz velocity</param>
            <param name="maxSpeed">The maximum movement speed of the player</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerMovement.AddVelocity3D(Unity.Mathematics.float3,System.Single)">
            <summary>Adds the 3D delta velocity to the player's velocity whilst
            respecting the player's current and maximum movement speeds. </summary>
            <param name="delta">The change to the player's 3D velocity</param>
            <param name="maxSpeed">The maximum movement speed of the player</param>
        </member>
        <member name="T:Arterra.Core.Player.SurfaceMovement">
            <summary> Controls the player's normal movement on the terrain surface. </summary>
        </member>
        <member name="M:Arterra.Core.Player.SurfaceMovement.Initialize">
            <summary>Initializes the player's surface movement pattern, and enables it</summary>
        </member>
        <member name="T:Arterra.Core.Player.SwimMovement">
            <summary> Controls the player's underwater movement including swimming or wading </summary>
        </member>
        <member name="M:Arterra.Core.Player.SwimMovement.Initialize">
            <summary> Initializes the swimming system. </summary>
        </member>
        <member name="M:Arterra.Core.Player.SwimMovement.StartSwim(System.Object,System.Object,System.Object)">
            <summary>=Enables underwater movement as the player's current movement pattern</summary>
            <param name="_"></param>
        </member>
        <member name="M:Arterra.Core.Player.SwimMovement.StopSwim(System.Object,System.Object,System.Object)">
            <summary>=Disables underwater movement and returns player to original movement pattern</summary>
        </member>
        <member name="T:Arterra.Core.Player.FlightMovement">
            <summary> The Manager responsible for controlling the player's movement when they fly.
            See <see cref="F:Arterra.Configuration.Gameplay.Gamemodes.Flight"/>.  </summary>
        </member>
        <member name="M:Arterra.Core.Player.FlightMovement.Initialize">
            <summary> Initializes the player's flight movement and 
            sets up to the triggers to enable it. </summary>
        </member>
        <member name="T:Arterra.Core.Player.RideMovement">
            <summary> The Manager responsible for translating the player's movement when they are riding something.
            See <see cref="T:IRidable"/> for more info. </summary>
        </member>
        <member name="M:Arterra.Core.Player.RideMovement.Initialize">
            <summary>Initializes the rider movement system.</summary>
        </member>
        <member name="M:Arterra.Core.Player.RideMovement.AddHandles(IRidable)">
            <summary>Enables the Rider Movement pattern as the player's current movement pattern.</summary>
            <param name="mount"></param>
        </member>
        <member name="M:Arterra.Core.Player.RideMovement.RemoveHandles">
            <summary>Disables the Rider Movement Pattern returning the player to their original movement pattern.</summary>
        </member>
        <member name="T:Arterra.Core.Player.PlayerVitality">
            <summary> Manager controlling the player's health, regenertion
            and base attack functionalities.  </summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerVitality.settings">
            <summary> The player's physicality settings. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerVitality.AttackCooldown">
            <summary>The time in seconds before the player can initiate attacking.</summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerVitality.Invincibility">
            <summary>The time in seconds before the player can recieve damage again. </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerVitality.health">
            <summary> The player's current health.</summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerVitality.healthPercent">
            <summary>The player's health normalized over their <see cref="F:Arterra.Configuration.Gameplay.Player.Physicality.MaxHealth">maximum health</see> </summary>
        </member>
        <member name="F:Arterra.Core.Player.PlayerVitality.breath">
            <summary>The time in seconds before the player will start drowning.</summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerVitality.breathPercent">
            <summary> The amount of remaining time the player can hold their breath 
            normalized over the <see cref="F:Arterra.Configuration.Gameplay.Player.Physicality.HoldBreathTime">maximum time</see>
            the player can hold their breath. </summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerVitality.IsDead">
            <summary> Whether or not the player is dead. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerVitality.#ctor">
            <summary>Creates a new instance of the player's
            vitality. Attaches keybinds for player attack. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerVitality.Update">
            <summary> Updates the player's vitality controller including
            any relevant cooldown timers.  </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerVitality.Damage(System.Single)">
            <summary>Requests that the player recieves damage.</summary>
            <param name="delta">The amount of damage to recieve</param>
            <returns>Whether or not damage was dealt based on
            the player's defenses/invincibility.</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerVitality.Heal(System.Single,System.Boolean)">
            <summary> Attempts to give the player health. </summary>
            <param name="delta">The amount of health to give the player </param>
            <param name="force">Whether to force giving the player the requested health,
            potentially exceeding their maximum health or reviving them. </param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerVitality.ProcessEntityInSolid(Arterra.Configuration.Generation.Entity.Entity,System.Single)">
            <summary>Processes damaging the player
            whose head being trapped in the terrain.</summary>
            <param name="self">The player entity</param>
            <param name="density">The density of the terrain around the player's head.
            The amount of damage to apply to the player</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerVitality.ProcessInGas(Arterra.Configuration.Generation.Entity.Entity,System.Single)">
            <summary>Processes what happens when the player's
            head is neither underwater or underground. </summary>
            <param name="density">The density of the gas surrounding the player's head</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerVitality.ProcessInLiquid(Arterra.Configuration.Generation.Entity.Entity,System.Single)">
            <summary>Processes drowning the player whose head
            is under a liquid material. </summary>
            <param name="self">The player entity</param>
            <param name="density">The density of the liquid surrounding the player's head</param>
        </member>
        <member name="T:Arterra.Core.Player.PlayerInteraction">
            <summary>The manager responsible for controlling all player interactions with the world </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.Initialize">
            <summary> Initializes the player's interactions by tying
            keybinds into the system. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.RayTestSolid(Unity.Mathematics.float3@)">
            <summary> Determines where the player's view vector intersects with the solid terrain if 
            under <see cref="F:Arterra.Configuration.Gameplay.Player.Interaction.ReachDistance"/>  away. See <see cref="M:MinimalRecognition.RayTestSolid``1(``0,System.Single,Unity.Mathematics.float3@)"/>
            for mode info. </summary>
            <param name="hitPt">If it does intersect, the first point it intersects in grid space</param>
            <returns>Whether or not the view ray intersects solid terrain</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.CylinderTestSolid(Unity.Mathematics.float3@)">
            <summary> Determines where a cylinder of radius <see cref="F:Arterra.Configuration.Gameplay.Player.Interaction.CylinderRadius"/> around the player's view vector
            intersects with the solid terrain if under <see cref="F:Arterra.Configuration.Gameplay.Player.Interaction.ReachDistance"/> away. See <see cref="M:MinimalRecognition.CylinderTestSolid``1(``0,System.Single,System.Single,Unity.Mathematics.float3@)"/>
            for mode info. </summary>
            <param name="hitPt">If it does intersect, the first point it intersects in grid space</param>
            <returns>Whether or not the view ray intersects solid terrain</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.RayTestLiquid(Unity.Mathematics.float3@)">
            <summary> Determines where the player's view vector intersects with the liquid/solid terrain if 
            under <see cref="F:Arterra.Configuration.Gameplay.Player.Interaction.ReachDistance"/>  away. See <see cref="M:MinimalRecognition.RayTestLiquid``1(``0,System.Single,Unity.Mathematics.float3@)"/>
            for mode info. </summary>
            <param name="hitPt">If it does intersect, the first point it intersects in grid space</param>
            <returns>Whether or not the view ray intersects liquid/solid terrain</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.CallOnMapPlacing(Unity.Mathematics.int3)">
            <summary> Calls the default <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnPlacing(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)"/> handle
            for the material being placed on behalf of the player and halts all terraforming 
            if an error occurs. </summary>
            <param name="GCoord">The coordinate in grid space of the material being placed</param>
            <returns>Whether or not to halt the current terraform process</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.CallOnMapRemoving(Unity.Mathematics.int3)">
            <summary> Calls the default <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.OnRemoving(Unity.Mathematics.int3,Arterra.Configuration.Generation.Entity.Entity)"/> handle
            for the material being removed on behalf of the player and halts all terraforming 
            if an error occurs. </summary>
            <param name="GCoord">The coordinate in grid space of the material being removed</param>
            <returns>Whether or not to halt the current terraform process</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.HandleAddSolid(Arterra.Configuration.Generation.Item.IItem,Unity.Mathematics.int3,System.Single,Arterra.Core.Storage.MapData@)">
            <summary> Adds the solid material translation of an item to a specific position in the map
            if the item has a solid material translation, and that solid material can be placed 
            at the position conservatively.  </summary>
            <remarks> This method resolves all material handles relevant to this operation</remarks>
            <param name="matItem">The item which has a solid material translation</param>
            <param name="GCoord">The coordinate in grid space to place the material</param>
            <param name="brushStrength">The speed at which material will be placed</param>
            <param name="pointInfo">The existing map information at this location <see cref="M:Arterra.Core.Storage.CPUMapManager.SampleMap(Unity.Mathematics.int3)"/> </param>
            <returns>Whether or not <b>any</b>(not necessarily all) new material was successfully placed here as a result of this operation.</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.HandleAddLiquid(Arterra.Configuration.Generation.Item.IItem,Unity.Mathematics.int3,System.Single,Arterra.Core.Storage.MapData@)">
            <summary> Adds the liquid material translation of an item to a specific position in the map
            if the item has a liquid material translation, and that liquid material can be placed 
            at the position conservatively.  </summary>
            <remarks> This method resolves all material handles relevant to this operation</remarks>
            <param name="matItem">The item which has a liquid material translation</param>
            <param name="GCoord">The coordinate in grid space to place the material</param>
            <param name="brushStrength">The speed at which material will be placed</param>
            <param name="pointInfo">The existing map information at this location <see cref="M:Arterra.Core.Storage.CPUMapManager.SampleMap(Unity.Mathematics.int3)"/> </param>
            <returns>Whether or not <b>any</b>(not necessarily all) new material was successfully placed here as a result of this operation.</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.HandleRemoveSolid(Arterra.Core.Storage.MapData@,Unity.Mathematics.int3,System.Single,System.Boolean)">
            <summary>Removes a specific amount of solid material from a certain position in the map. </summary>
            <param name="pointInfo">The existing map information at this location <see cref="M:Arterra.Core.Storage.CPUMapManager.SampleMap(Unity.Mathematics.int3)"/> </param>
            <param name="GCoord">The coordinate in grid space to remove materia</param>
            <param name="brushStrength">The speed at which material will be removed</param>
            <param name="ObtainMat">Whether or not the item translation of the solid material will attempt to be 
            added to the Player's Inventory. </param>
            <returns>Whether or not <b>any</b>(Not necessarily all) material was removed.</returns>
        </member>
        <member name="M:Arterra.Core.Player.PlayerInteraction.HandleRemoveLiquid(Arterra.Core.Storage.MapData@,Unity.Mathematics.int3,System.Single,System.Boolean)">
            <summary>Removes a specific amount of liquid material from a certain position in the map. </summary>
            <param name="pointInfo">The existing map information at this location <see cref="M:Arterra.Core.Storage.CPUMapManager.SampleMap(Unity.Mathematics.int3)"/> </param>
            <param name="GCoord">The coordinate in grid space to remove materia</param>
            <param name="brushStrength">The speed at which material will be removed</param>
            <param name="ObtainMat">Whether or not the item translation of the liquid material will attempt to be 
            added to the Player's Inventory. </param>
            <returns>Whether or not <b>any</b>(Not necessarily all) material was removed.</returns>
        </member>
        <member name="T:Arterra.Core.Player.PlayerCamera">
            <summary> Responsible for managing the player's camera
            and its movement and angles within the game.  </summary>
        </member>
        <member name="P:Arterra.Core.Player.PlayerCamera.Facing">
            <summary> The quarternion representing the direction the player's camera is facing </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerCamera.#ctor">
            <summary> Default Constructor </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerCamera.Deserailize(Arterra.Core.Player.PlayerStreamer.Player)">
            <summary> Deserializes the player's camera, called after it's been deserialized.
            Reattaches to the player instance and reverts the camera state to the default camera </summary>
            <param name="context">The instance of the currently streaming player</param>
        </member>
        <member name="M:Arterra.Core.Player.PlayerCamera.Initialize">
            <summary> Initializes this object as the current active player camera instance by 
            tying the keybinds relevant to handling the camera. </summary>
        </member>
        <member name="M:Arterra.Core.Player.PlayerCamera.Update(UnityEngine.Transform)">
            <summary>Updates the player's camera movement and properties.</summary>
            <param name="CamTsf">The transform of the physical Unity Camera object</param>
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.AsyncMeshReadback">
            <summary>
            The readback system is responsible for reading back meshes from the GPU and 
            intermediately rendering the meshes directly from the GPU while this is happening.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.AsyncMeshReadback.triHandles">
            <summary> The <see cref="T:Arterra.Core.Terrain.Readback.GeometryHandle">geometry handles</see> for all the unqiue materials that are used to render the chunk. Each
            chunk will have a unique handle for each material in <see cref="!:Intrinsic.Readback.indirectTerrainMats"/>
            regardless of whether any geometry in the chunk uses that material. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.AsyncMeshReadback.vertexHandle">
            <summary> The <see cref="T:Arterra.Core.Terrain.Readback.GeometryHandle">geometry handles</see> for the shared vertices of the chunk. This
            holds all the vertex information used by geometry linked through <see cref="F:Arterra.Core.Terrain.Readback.AsyncMeshReadback.triHandles"/> in the chunk. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.#ctor(UnityEngine.Transform,UnityEngine.Bounds)">
            <summary> Creates an instance of the readback system specific for a chunk. Each readback 
            instance is responsible for managing a single chunk and its associated geometry. </summary>
            <param name="transform">The orientation of the chunk. Used for rendering the chunk indirectly</param>
            <param name="boundsOS">The bounds in the chunk's Object Space(local space) of the extents of the geometry. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.PresetData">
            <summary> Presets static data shared by the readback system. This should be called before any 
            instances of the readback system are used. Referenced in <see cref="M:Arterra.Core.Terrain.SystemProtocol.Startup"/>.  </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.Release">
            <summary> Releases all static data shared by the readback system. This should be called when the 
            readback system is no longer needed (when the world is closed). Referenced in <see cref="M:Arterra.Core.Terrain.SystemProtocol.Shutdown"/>. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.ReleaseAllGeometry">
            <summary> Releases all <see cref="T:Arterra.Core.Terrain.Readback.GeometryHandle">geometry handles</see> associated with the specific chunk's readback.
            This should be called to ensure a chunk is not holding onto any GPU memory upon being unloaded. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.OffloadVerticesToGPU(System.Int32)">
            <summary> Offloads(copies) vertices to long term GPU storage. This can be used to store vertices for rendering or to hold onto them
            until instructions are flushed so it may be read back to the CPU. A Handle to the stored vertices will be 
            saved in <see cref="F:Arterra.Core.Terrain.Readback.AsyncMeshReadback.vertexHandle"/>, with any possible previous handles being released. </summary>
            <param name="vertexCounter">The location within the <see cref="F:UtilityBuffers.GenerationBuffer">working buffer</see> 
            storing the amount of vertices to be copied. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.OffloadTrisToGPU(System.Int32,System.Int32,System.Int32)">
            <summary> Offloads(copies) triangles(index buffer) to long term GPU storage. This can be used to store triangles for 
            rendering or to hold onto them until instructions are flushed so it may be read back to the CPU. A Handle to the 
            stored triangles will be saved in <see cref="F:Arterra.Core.Terrain.Readback.AsyncMeshReadback.triHandles"/>, with any possible previous handles being released. </summary>
            <param name="triCounter">The location within the <see cref="F:UtilityBuffers.GenerationBuffer">working buffer</see> 
            storing the amount of triangles to be copied. </param>
            <param name="triStart">The location within the <see cref="F:UtilityBuffers.GenerationBuffer">working buffer</see> 
            of the start of the triangles(index buffer).</param>
            <param name="matIndex">The index within <see cref="!:Intrinsic.Readback.indirectTerrainMats"/> of the material to use
            for geometry referenced by these triangles if it is to be indirectly rendered. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.OffloadTrisToGPUNoRender(System.Int32,System.Int32,System.Int32)">
            <summary> Offloads(copies) triangles(index buffer) to long term GPU storage. Unlike
            <see cref="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.OffloadTrisToGPU(System.Int32,System.Int32,System.Int32)"/> this method does not immediately try to render the geometry indirectly.  </summary>
            <param name="triCounter">The location within the <see cref="F:UtilityBuffers.GenerationBuffer">working buffer</see> 
            storing the amount of triangles to be copied. </param>
            <param name="triStart">The location within the <see cref="F:UtilityBuffers.GenerationBuffer">working buffer</see> 
            of the start of the triangles(index buffer).</param>
            <param name="matIndex">The index within <see cref="!:Intrinsic.Readback.indirectTerrainMats"/> of the material to use
            for geometry referenced by these triangles if it is to be indirectly rendered. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.AsyncMeshReadback.BeginMeshReadback(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo})">
            <summary> Creates a request to readback all geometry referenced by <see cref="T:Arterra.Core.Terrain.Readback.GeometryHandle"/>s of the chunk's instance
            to a <see cref="T:Arterra.Core.Terrain.Readback.ReadbackTask`1"> CPU mesh object </see>. This is an asynchronous task that retrieves the data once
            the CPU and GPU states are synchronized. </summary>
            <param name="callback"> The callback to be called once the readback is complete. The callback will be provided the readback <see cref="T:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo"/> </param>
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.ReadbackMaterial">
            <summary> The types of materials that can be read back from the GPU. Associates
            a name to the materials defined in <see cref="!:Intrinsic.Readback.indirectTerrainMats"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.ReadbackMaterial.terrain">
            <summary> The index of the material used for terrain geometry. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.ReadbackMaterial.water">
            <summary> The index of the material used for liquid geometry. </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.GeometryHandle">
            <summary> A handle to geometry that is stored in <see cref="!:GenerationPreset.MemoryHandle._GPUMemorySource"> long term GPU storage </see>. 
            If the geometry is triangles(an index buffer), the handle will also store information for rendering the geometry indirectly,
            by using vertex information stored in a <see cref="F:Arterra.Core.Terrain.Readback.AsyncMeshReadback.vertexHandle"> seperate geometry handle </see>.  </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.GeometryHandle.rp">
            <summary> The <see cref="T:UnityEngine.RenderParams"/> describing how the geometry should be rendered indirectly if it is to be rendered. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.GeometryHandle.memory">
            <summary> The memory handle of the buffer where the geometry is stored. Specifically, the geometry will be stored in 
            <see cref="!:GenerationPreset.MemoryHandle._GPUMemorySource"/> of this memory handle. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.GeometryHandle.matIndex">
            <summary> The index of the material used for rendering the geometry indirectly. This index is used to reference the material in
            <see cref="!:Intrinsic.Readback.indirectTerrainMats"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.GeometryHandle.addressIndex">
            <summary> The address of the geometry within the <see cref="!:GenerationPreset.MemoryHandle.Address"> address buffer </see> of the <see cref="F:Arterra.Core.Terrain.Readback.GeometryHandle.memory"> memory handle </see>
            of the location that stores the real address of the geometry in <see cref="!:GenerationPreset.MemoryHandle._GPUMemorySource"/>. See <see cref="!:GenerationPreset.MemoryHandle.Address"/> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.GeometryHandle.argsAddress">
            <summary> If the geometry is to be rendered indirectly, the address of the <see cref="T:UnityEngine.GraphicsBuffer.IndirectDrawArgs"> draw arguments </see> used 
            to render the geometry. This is used to reference the draw arguments in <see cref="!:UtilityBuffers.ArgumentBuffer"/>.  </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.GeometryHandle.#ctor(UnityEngine.RenderParams,Arterra.Configuration.Quality.MemoryBufferHandler,System.UInt32,System.UInt32,System.Int32)">
            <summary> Creates a geometry handle for triangle geometry(index buffer) that will be rendered indirectly. As such, 
            it needs to specify information on how to render it beyond just the location of the geometry itself. </summary>
            <param name="rp">The <see cref="F:Arterra.Core.Terrain.Readback.GeometryHandle.rp">Render Parameters</see> describing how the geometry should be rendered </param>
            <param name="memory">The <see cref="F:Arterra.Core.Terrain.Readback.GeometryHandle.memory">Memory Handle</see> of the buffer that holds the copied geometry.</param>
            <param name="addressIndex">The <see cref="F:Arterra.Core.Terrain.Readback.GeometryHandle.addressIndex">><b>indirect</b> address</see> of the geometry within the memory handle.</param>
            <param name="argsAddress">The <see cref="F:Arterra.Core.Terrain.Readback.GeometryHandle.argsAddress">location</see> of the rendering arguments to render the geometry. </param>
            <param name="matIndex">The material index of the material used to render the geometry, See <see cref="F:Arterra.Core.Terrain.Readback.GeometryHandle.matIndex"/> for more info. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.GeometryHandle.#ctor">
            <summary> Creates a geometry handle for storing geometry. The geometry will not be rendered indirectly
            and thus does not need to specify any rendering parameters. Useful for vertex buffers which 
            are only rendered through being referenced by triangles. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.GeometryHandle.Finalize">
            <summary> Destructor Releases GeoHandle to prevent memory leaks </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.GeometryHandle.Release">
            <summary> Releases the geometry handle, freeing any memory blocks it holds in <see cref="F:Arterra.Core.Terrain.Readback.GeometryHandle.memory"> the memory handle</see>. 
            This should be called when the geometry is no longer needed to ensure that the GPU memory is released. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.GeometryHandle.Update(UnityEngine.MonoBehaviour)">
            <summary> Updates the geometry handle to pass any indirect render commands it may have.
            If the geometry handle renders indirectly, the command to do so will be issued here.
            This done every frame through unity's update loop through <see cref="F:Arterra.Core.Terrain.OctreeTerrain.MainLoopUpdateTasks"/>.
            See <see cref="!:UpdateTask"/> for more information. </summary>
            <param name="mono">See <see cref="!:UpdateTask.Update(MonoBehaviour)"/> for more info. </param>
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.IVertFormat">
            <summary> Interface for formats of vertices that are read back from the GPU. If a vertex format, the 
            layout of a vertex's data, is to be read back into a <see cref="T:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo"/>, 
            the vertex being readback should implement this interface to ensure proper initialization of
            the mesh destination. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.IVertFormat.SetVertexBufferParams(UnityEngine.Mesh,System.Int32)">
            <summary> Sets the vertex buffer parameters of a mesh to match the format of the vertex data being read back.</summary>
            <param name="mesh"> The mesh whose vertex format information is set. See <see cref="T:UnityEngine.Rendering.VertexAttributeDescriptor"/> for more info. </param>
            <param name="count"> The amount of vertices in the mesh expected to use the specified mesh format. </param>
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.IVertFormat.TVert">
            <summary> The vertex format for terrain geometry created during the games 
            terrain generation. See <see cref="T:Arterra.Core.Terrain.Readback.IVertFormat"/> for more information.  </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.IVertFormat.TVert.SetVertexBufferParams(UnityEngine.Mesh,System.Int32)">
            <exclude />
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.IVertFormat.SVert">
            <summary> The vertex format for sprite geometry created in <see cref="T:SpriteExtruder"> sprite extrusion </see>
            extruding images to 3D models. See <see cref="T:Arterra.Core.Terrain.Readback.IVertFormat"/> for more information.  </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.IVertFormat.SVert.SetVertexBufferParams(UnityEngine.Mesh,System.Int32)">
            <exclude />
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.ReadbackTask`1">
            <summary>
            A readback task responsible for copying <b>all</b> of a mesh's data from the GPU to the CPU when both processers are
            synchronized. If data is dispersed between multiple locations(e.g. vertex buffer, index buffer), it will only 
            provide the combined mesh once all data is read back. This is to prevent the possibility of incomplete meshes 
            replacing indirect rendering, possibly causing a gap to appear in the terrain.
            </summary>
            <typeparam name="Vert">The <see cref="T:Arterra.Core.Terrain.Readback.IVertFormat">type of vertex</see>, of the mesh being read back. </typeparam>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.ReadbackTask`1.RBMesh">
            <summary> The mesh data that is read back from the GPU. This is the destination 
            of the readback task and will contain the mesh data once complete. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.#ctor(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{`0}.SharedMeshInfo},System.Int32)">
            <summary> Creates a readback task for reading back mesh data from the GPU. </summary>
            <param name="RBMeshCallback">The callback that will be answered when the full mesh has been readback. </param>
            <param name="numMeshes">The number of unique submeshes to be created in the final mesh. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.AddTask">
            <summary> Adds a task that needs to be completed before the mesh is considered fully read back.
            This effectively subscribes a handle capable of stalling the readback completion 
            until the subscribed task is complete. Used to ensure multiple independent
            tasks are all completed before the mesh is read back. <seealso cref="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.OnRBRecieved"/>. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.OnRBRecieved">
            <summary> Called when a task is completed. If all tasks are completed, the mesh is considered fully read back and
            no further tasks will be considered. A <see cref="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.AddTask">subscribed task</see> may call this function
            to unsubscribe itself from stalling the readback process once it has injected its information. </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo">
            <summary> The shared mesh data that is read back from the GPU. This is the destination
            of the readback task and will contain the mesh data once complete. </summary>
            <remarks> As data is read from the buffer this way, reading to native array is significantly faster </remarks>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.IndexBuffer">
            <summary> The index buffer of all submeshes in the mesh. Each submesh is stored in a separate array. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.VertexBuffer">
            <summary> The vertex buffer of the mesh. This is shared between all submeshes in the mesh. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.#ctor(System.Int32)">
            <summary> Creates a destination for mesh data with the specified amount
            of submeshes to be readback independently. </summary>
            <param name="numSubMeshes">The number of submeshes to support reading back. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.Finalize">
            <summary> Destructor to release all buffers, see <see cref="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.Release"/> for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.Release">
            <summary> Releases all buffers used by the shared mesh info. This should be called 
            when the mesh is no longer needed to ensure any intermediate readback buffers are recovered. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.GenerateMesh(UnityEngine.Rendering.IndexFormat)">
            <summary> Generates a <see cref="T:UnityEngine.Mesh"/> using the readback 
            information stored in this object.  </summary>
            <param name="meshIndexFormat"> The <see cref="T:UnityEngine.Rendering.IndexFormat">index format</see> used in 
            the mesh's index buffer, either 16-bit or 32-bit indices. </param>
            <returns>The generated <see cref="T:UnityEngine.Mesh"/> based off the <see cref="T:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo"/>'s information. </returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.GetSubmesh(System.Int32,UnityEngine.Rendering.IndexFormat)">
            <summary> Generates a submesh from the readback information stored in this object. This
            will obtain a mesh using only one of the submeshes listed in <see cref="F:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.IndexBuffer"/>. </summary>
            <remarks> This would still require reobtaining all vertex information from the entire <see cref="F:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.VertexBuffer"/>
            as the vertices belonging to only the submesh is not stored seperately. </remarks>
            <param name="submeshIndex">The index within the <see cref="F:Arterra.Core.Terrain.Readback.ReadbackTask`1.SharedMeshInfo.IndexBuffer"/> of the triangles belonging to the desired submesh, </param>
            <param name="meshIndexFormat"> The <see cref="T:UnityEngine.Rendering.IndexFormat">index format</see> used in 
            the mesh's index buffer, either 16-bit or 32-bit indices. </param>
            <returns></returns>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.AsyncGenInfoReadback.CREATE_ENTITIES">
            <summary> Flag to create entities from structure meta </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Readback.AsyncGenInfoReadback.CREATE_META">
            <summary> Flag to create entities from structure meta </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.SystemProtocol">
            <summary>  The factory protocol for the collective game system. This
            protocol tracks the proper process to facilitate large 
            context switches within the game. Any new systems should
            be added to this protocol with awareness of its dependencies. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.SystemProtocol.Reset">
            <summary> Resets the system state </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.SystemProtocol.Startup">
            <summary> Performs the proper startup protocol when the <b>world</b> is initialized
            (this excludes when the main menu is displayed). This is a static factory protocol and only 
            changes when modifying the system's functionality through its source code. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.SystemProtocol.MinimalStartup">
            <summary>  Sets up the minimal amount of information to operate and use
            limited systems without initializing the full capabilities of the game </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.SystemProtocol.Shutdown">
            <summary> Performs the proper shutdown protocol depending on what system state the game is in
            returning the system to a clean uninitialized state. This is a static factory protocol and 
            only changes when modifying the system's functionality through its source code. </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.GenerationPreset">
            <summary>
            By default,information may be stored in settings or on storage where it is
            likely serialized to be version independent. This class is responsible for acquiring
            and deserializing all information pertinent to terrain generation from these locations 
            and copying the necessary information to the GPU for use in the terrain generation, shaders
            and other systems primarily on the GPU.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.GenerationPreset.entityHandle">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.GenerationPreset.memoryHandle">
            <summary> Holds a reference to a long-term storage GPU buffer used in the terrain generation process. <seealso cref="T:Arterra.Configuration.Quality.MemoryOccupancyBalancer"/> </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.Initialize">
            <summary>
            Initializes the GenerationPreset. Must be called before any generation is done.
            This process loads all necessary information from the settings and copies it to the GPU.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.MinimalInitialize">
            <summary>
            Initializes the minimum amount of resources to 
            display materials and process compute geometry in the same way 
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.MinimalRelease">
            <summary> Releases the minimum amount of resources to display
            materials and process compute geometry in the same way </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.Release">
            <summary>
            Releases all generation information that has been allocated on the GPU and 
            elsewhere. Call this method before the program exits to prevent memory leaks.
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.GenerationPreset.MaterialHandle">
            <summary>Responsible for deserializing all material display information as well as copying all textures to the GPU.
            Material display information includes information on each material's visual representation as a solid, liquid, 
            and gas <seealso cref="T:Arterra.Configuration.Generation.Material.MaterialData"/>. Textures are copied from the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Textures"/>
            registry and should be referenced in the GPU by their index in that registry. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.MaterialHandle.Initialize">
            <summary> Initializes the <see cref="T:Arterra.Core.Terrain.GenerationPreset.MaterialHandle" />. Deserializes and copies all information to 
            the GPU for use in the terrain generation process. Information is stored in global GPU buffers 
            <c>_MatTerrainData</c>, <c>_MatAtmosphericData</c>, <c>_MatLiquidData</c>, and <c>_Textures</c>. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.MaterialHandle.Release">
            <summary> Releases all buffers and textures used by the MaterialHandle. 
            Call this method before the program exits to prevent memory leaks. </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.GenerationPreset.NoiseHandle">
            <summary>
            Responsible for deserializing all noise generation settings and copying it to the GPU 
            for use in the terrain generation process. <seealso cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/>. 
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.NoiseHandle.Initialize">
            <summary>
            Initializes the <see cref="T:Arterra.Core.Terrain.GenerationPreset.NoiseHandle"/> . Deserializes and copies all information
            contained by <see cref="F:Arterra.Configuration.Config.GenerationSettings.Noise"/> to the GPU. 
            Information is stored in global GPU buffers <c>_NoiseIndexes</c>, <c>_NoiseSettings</c>, 
            <c>_NoiseOffsets</c> and <c>_NoiseSplinePoints</c>.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.NoiseHandle.Release">
            <summary>
            Releases all buffers used by the NoiseHandle. 
            Call this method before the program exits to prevent memory leaks.
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.GenerationPreset.BiomeHandle">
            <summary>
            Responsible for deserializing all biome generation settings and copying it to the GPU for use
            in the terrain generation process. <seealso cref="F:Arterra.Configuration.Config.GenerationSettings.Biomes"/>.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.BiomeHandle.Initialize">
            <summary>
            Initializes the <see cref="T:Arterra.Core.Terrain.GenerationPreset.BiomeHandle"/>. Deserializes and copies all information
            contained by <see cref="F:Arterra.Configuration.Config.GenerationSettings.Biomes"/> to the GPU. Deserializing
            the registry involves constructing an R-Tree LUT which is then copied to the GPU. Information 
            about this LUT is stored in global GPU buffers <c>_BiomeSurfTree</c>, <c>_BiomeCaveTree</c>,
            while information on what each biome contains is stored in <c>_BiomeMaterials</c>, <c>_BiomeStructureData</c>, 
            and <c>_BiomeEntities</c>, referencable through the <c>_BiomePrefCount</c> prefix sum buffer.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.BiomeHandle.Release">
            <summary>
            Releases all buffers used by the BiomeHandle.
            Call this method before the program exits to prevent memory leaks.
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.GenerationPreset.StructHandle">
            <summary>
            Responsible for deserializing all structure generation settings and copying it to the GPU 
            for use in the terrain generation process. <seealso cref="F:Arterra.Configuration.Config.GenerationSettings.Structures"/>.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.StructHandle.Initialize">
            <summary>
            Initializes the <see cref="T:Arterra.Core.Terrain.GenerationPreset.StructHandle"/>. Deserializes and copies all information contained by
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Structures"/> to the GPU. Information about a structure's in 
            generation is stored in global GPU buffers <c>_StructureIndexes</c>, <c>_StructureChecks</c>, and  <c>_StructureSettings</c>.
             <c>_StructureSettings</c> also includes information on each structure's start and length of information in the other buffers, 
             including the raw point data in <c>_StructureMap</c>.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.StructHandle.Release">
            <summary>
            Releases all buffers used by the StructHandle.
            Call this method before the program exits to prevent memory leaks.
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.GenerationPreset.EntityHandle">
            <summary>
            Responsible for deserializing all entity generation settings and copying it to the GPU 
            for use in the terrain generation process. Note that <b>only information
            relevant to each entity's placement is copied</b>. 
            <seealso cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"/>.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.GenerationPreset.EntityHandle.entityProfileArray">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.EntityHandle.Initialize">
            <summary>
            Initializes the <see cref="T:Arterra.Core.Terrain.GenerationPreset.EntityHandle"/>. Deserializes and copies all information contained by
            <see cref="F:Arterra.Configuration.Config.GenerationSettings.Entities"/> relavent to an entity's placement to the GPU. 
            This includes information on each entity's size, and <see cref="T:Arterra.Configuration.Generation.Entity.ProfileE" />. 
            Information is stored in global GPU buffers <c>_EntityInfo</c> and <c>_EntityProfile</c>.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.GenerationPreset.EntityHandle.Release">
            <summary>
            Releases all buffers used by the EntityHandle.
            Call this method before the program exits to prevent memory leaks.s
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.Surface.Creator">
            <summary>
            A manager unique for every terrain chunk responsible for creating and holding onto
            intermediate surface information required by the chunk during the terrain
            generation process.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Surface.Creator.SurfaceMapAddress">
            <summary>
            The address of the generated surface map for this chunk. The location within 
            <see cref="!:GenerationPreset.MemoryHandle.Address"/> of the address within <see cref="!:GenerationPreset.MemoryHandle.Storage"/> 
            of the beginning of the surface map information cached for this chunk. 
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Surface.Creator.SampleSurfaceMaps(Unity.Mathematics.float2,System.Int32,System.Int32)">
            <summary> Samples the surface information based off the position and size of the chunk
            and saves it in long-term GPU memory, referenced through <see cref="F:Arterra.Core.Terrain.Surface.Creator.SurfaceMapAddress"/>. </summary>
            <param name="offset">The offset in grid space of the origin(bottom left corner) of the chunk. </param>
            <param name="ChunkSize">The resolution of the chunk; how many samples are conducted per axis of the chunk.</param>
            <param name="SkipInc">The distance between consecutive samples in the chunk; the side length of a surface pixel</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Surface.Creator.ReleaseMap">
            <summary>  Releases any intermediate surface maps held by this instance. Call this to ensure
            that no memory is being held by a chunk being disposed. See <seealso cref="F:Arterra.Core.Terrain.Surface.Creator.SurfaceMapAddress"/>. </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.Surface.Generator">
            <summary>
            A static manager responsible for managing loading and access
            of all compute-shaders used within the surface generation process
            of terrain generation. All instructions related to surface
            generation done by the GPU is streamlined from this module. 
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Surface.Generator.PresetData">
            <summary>
            Presets all compute-shaders used in the surface generator by acquiring them and
            binding any constant values(information derived from the world's settings that 
            won't change until the world is unloaded) to them. Referenced by
            <see cref="M:Arterra.Core.Terrain.SystemProtocol.Startup"/> </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Surface.Generator.SampleSurfaceData(UnityEngine.Vector2,System.Int32,System.Int32)">
            <summary> Samples surface terrain information for a chunk based off the position and size of the chunk. 
            The resultant sampled map is stored in a <see cref="F:UtilityBuffers.GenerationBuffer"> working
            memory buffer </see> and will be lost unless transcribed to long term storage through <see cref="M:Arterra.Core.Terrain.Surface.Generator.TranscribeSurfaceMap(UnityEngine.ComputeBuffer,UnityEngine.GraphicsBuffer,System.Int32,System.Int32)"/>. </summary>
            <remarks> 
            The surface map is a 2D map describing 6 values for every pixel. The <see cref="!:Generation.Biome.SurfaceBiome.biome"> surface biome index </see>,
            the <see cref="!:Generation.Surface.MaxTerrainHeight">height of the surface</see>, the <see cref="!:Generation.Surface.SquashNoise"> squash height </see>, the 
            <see cref="!:Generation.Surface.AtmosphereNoise"> falloff intensity of the atmosphere</see>, and the <see cref="!:Generation.Biome.SurfaceBiome.InfluenceStart"> start </see> and 
            <see cref="F:Arterra.Configuration.Generation.Biome.SurfaceBiome.InfluenceEnd"> end </see> of its vertical influence, 
            </remarks>
            <param name="offset">The offset in grid space of the origin to begin sampling. </param>
            <param name="chunkSize">The resolution to sample with; how many samples are conducted per axis. </param>
            <param name="mapSkipInc">The distance between adjacent samples; the side length of a surface pixel</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Surface.Generator.TranscribeSurfaceMap(UnityEngine.ComputeBuffer,UnityEngine.GraphicsBuffer,System.Int32,System.Int32)">
            <summary>  Transcribes the surface information. Copies the generated surface map created through <see cref="M:Arterra.Core.Terrain.Surface.Generator.SampleSurfaceData(UnityEngine.Vector2,System.Int32,System.Int32)"/> from
            <see cref="F:UtilityBuffers.GenerationBuffer"> working memory </see> to a location preallocated for it in
            <see cref="!:TerrainGeneration.GenerationPreset.MemoryHandle.Storage"> long term storage </see> where it won't be 
            overwritten. </summary>
            <param name="memory">The destination buffer that the surface map will be copied to</param>
            <param name="addresses">The buffer containing the direct address to the location within 
            <paramref name="memory"/> where the surface map will be copied to. </param>
            <param name="addressIndex">The indirect index within <paramref name="addresses"/> of the address
            within <paramref name="memory"/> where the surface map will be copied to. </param>
            <param name="numPoints">The <b>total</b> amount of points copied from working memory to the specified location.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Surface.Generator.SimplifyMap(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.Queue{UnityEngine.ComputeBuffer})">
            <summary> Converts a 2D surface map sampled at a <paramref name="sourceSkipInc"> higher resolution </paramref> to one of a 
            <paramref name="destSkipInc"> lower resolution </paramref>. Reducing the resolution reduces the size of the surface map
            by taking every (<paramref name="destSkipInc"/> / <paramref name="sourceSkipInc"/>)th element on every axis of the map. 
            <paramref name="destSkipInc"/> must be an integer multiple of <paramref name="sourceSkipInc"/>. </summary>
            <remarks> This function is deprecated and should no longer be used. </remarks>
            <param name="memory">The source buffer that the surface map will be referenced from</param>
            <param name="addresses">The buffer containing the direct address to the location within 
            <paramref name="memory"/> of the surface map that is to be simplified. </param>
            <param name="addressIndex">The indirect index within <paramref name="addresses"/> of the address
            within <paramref name="memory"/>  of the surface map that is to be simplified. </param>
            <param name="chunkSize">The side length in grid space of the surface map in grid space. </param>
            <param name="sourceSkipInc">The distance between adjacent samples in the saved surface map 
            currently in <paramref name="addresses">long-term storage</paramref>. </param>
            <param name="destSkipInc">The distance between adjacent samples in the resultant simplified surface
            map that will be written to in the returned buffer.</param>
            <param name="bufferHandle">The optional buffer handle that will be given the output buffer to facilitate
            its management and release. </param>
            <returns>A <see cref="T:UnityEngine.ComputeBuffer"/> containing the simplified surface map.</returns>
        </member>
        <member name="T:Arterra.Core.Terrain.Map.Creator">
            <summary> A manager unique for every terrain chunk responsible for creating 
            and grouping and abstracting various types of instructions used to
            create the final 3D terrain map and the visual mesh. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.PopulateBiomes(Unity.Mathematics.float3,System.UInt32,System.Int32,System.Int32)">
            <summary> Populates the final 3D biome map for the chunk. This involves describing the
            biome type associated with each map entry within the chunk. Normally, this process is implicitly 
            done when generating the default map(see <see cref="M:Arterra.Core.Terrain.Map.Creator.GenerateBaseChunk(Unity.Mathematics.float3,System.UInt32,System.Int32,System.Int32,System.Single)"/>), but that
            process does not retain this information. </summary>
            <param name="offset">The offset in grid space of the origin of the chunk.</param>
            <param name="surfaceData">A handle indicating the surface information for the chunk. This
            handle will be used to find the surface data within a <see cref="!:Config.Quality.MemoryBufferHandler.Storage">
            storage buffer</see>. See <see cref="F:Arterra.Core.Terrain.Surface.Creator.SurfaceMapAddress"/> for more info. </param>
            <param name="chunkSize">The size of a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/> in grid space</param>
            <param name="mapSkip">The distance in grid space between two adjacent samples in the biome map. 
            Equivalently the size relative to a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/>.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.GenerateBaseChunk(Unity.Mathematics.float3,System.UInt32,System.Int32,System.Int32,System.Single)">
            <summary> Generates the base terrain map information for a chunk. This is the 3D map defined 
            by noise functions responsible for creating the surface and cave structures of the terrain
            as well as assigning materials to the generated map. </summary>
            <param name="offset"> The offset in grid space of the origin of the chunk.</param>
            <param name="surfaceData">handle indicating the surface information for the chunk. This
            handle will be used to find the surface data within a <see cref="!:Config.Quality.MemoryBufferHandler.Storage">
            storage buffer</see>. See <see cref="F:Arterra.Core.Terrain.Surface.Creator.SurfaceMapAddress"/> for more info. </param>
            <param name="chunkSize">The size of a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/> in grid space</param>
            <param name="mapSkip">The distance in grid space between two adjacent samples in the biome map. 
            Equivalently the size relative to a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/>.</param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="!:Quality.Terrain.IsoLevel"/> for more info.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.CompressMap(System.Int32)">
            <summary> Compresses the map data of the chunk into its compacted form which is actually stored and recognized by
            most systems. During generation, the map data is stored in 12-bytes(4-bytes for each field) as certain atomic 
            operations only operate on this level. However most systems recognize a compacted 4-byte form of the map data. </summary>
            <param name="chunkSize">The axis size of the map to be compressed. The amount of entries to be compressed is (<paramref name="chunkSize"/>^3) </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.SetMapInfo(System.Int32,System.Int32,Arterra.Core.Storage.MapData[])">
            <summary> Copies the map data from a linearly encoded chunk on the CPU to a 
            <see cref="F:UtilityBuffers.TransferBuffer">transfer buffer</see> accessible by GPU-based tasks.  </summary>
            <param name="numPointsAxis">The axis size of the map to be copied, the length of <paramref name="chunkData"/>
            should be greater than or equal to (<i>numPointsAxis</i>^3)</param>
            <param name="offset">The offset within <paramref name="chunkData"/> to begin copying the MapData.</param>
            <param name="chunkData">A managed array containing the linearly encoded map information for a chunk.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.SetMapInfo(System.Int32,System.Int32,Unity.Collections.NativeArray{Arterra.Core.Storage.MapData}@)">
            <summary> Copies the map data from a linearly encoded unmanaged chunk on the CPU to a 
            <see cref="F:UtilityBuffers.TransferBuffer">transfer buffer</see> accessible by GPU-based tasks.</summary>
            <param name="numPointsAxis">The axis size of the map to be copied, the length of <paramref name="chunkData"/>
            should be greater than or equal to (<i>numPointsAxis</i>^3)</param>
            <param name="offset">The offset within <paramref name="chunkData"/> to begin copying the MapData.</param>
            <param name="chunkData">A Unity unamanged array containing the linearly encoded map information for a chunk.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.GenerateRealMesh(Unity.Mathematics.int3,System.Single,System.Int32,System.UInt32)">
            <summary> Generates the mesh for the <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/> at the specified location. Involves retrieving
            the saved map information stored by <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkReal(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/>
            and generating the mesh using the marching cubes algorithm. If an invalid chunk is passed, or one that does not
            have a saved map, the behavior for this function is not defined. </summary>
            <param name="CCoord">The coordinate in chunk space, of the <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/> whose mesh is generated.</param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="!:Quality.Terrain.IsoLevel"/> for more info.</param>
            <param name="chunkSize">The resolution of the mesh generated for the chunk. Equivalent to the amount of entries per axis within the map saved for this chunk</param>
            <param name="neighborDepths">A bitmap describing the potential difference in depth between this chunk and its neighbors,
            used in generating transition information. See <see cref="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetNeighborDepths(System.UInt32)"/> and <see cref="M:Arterra.Core.Terrain.Map.Generator.GenerateTransition(System.UInt32,System.Int32,System.Single)"/>
            for more info. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.GenerateVisualMesh(Unity.Mathematics.int3,System.Int32,System.Single,System.Int32,System.Int32,System.UInt32)">
            <summary> Generates the mesh for a <see cref="T:Arterra.Core.Terrain.TerrainChunk.VisualChunk"><b>normal</b> visual chunk </see> at the specified location. Normal
            visual chunks have stored map information through <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkVisual(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/>, but
            because they can border fake chunks, they must also contain some default out-of-bound information in case they can't find it from 
            their neighbors. </summary>
            <param name="CCoord">The coordinate in chunk space of the origin of the chunk. </param>
            <param name="defAddress">The address within an <see cref="P:Arterra.Core.Storage.GPUMapManager.DirectAddress">indirect address buffer</see> 
            of the address of the base map information for the visual chunk. This includes dirty information belonging to the chunk
            as well as the default map for entries outside its own bounds but needed for mesh generation. </param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="!:Quality.Terrain.IsoLevel"/> for more info.</param>
            <param name="chunkSize">The resolution of the mesh generated for the chunk. Equivalent to the amount of entries per axis within the map saved for this chunk</param>
            <param name="depth">The distance of the chunk from a leaf node within the <see cref="T:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree">chunk octree</see>. Identifies
            the size of the chunk relative to a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"> real chunk </see>. See <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/> for more info.</param>
            <param name="neighborDepths">A bitmap describing the potential difference in depth between this chunk and its neighbors,
            used in generating transition information. See <see cref="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetNeighborDepths(System.UInt32)"/> and <see cref="M:Arterra.Core.Terrain.Map.Generator.GenerateTransition(System.UInt32,System.Int32,System.Single)"/>
            for more info. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Creator.GenerateFakeMesh(System.Single,System.Int32,System.UInt32)">
            <summary>  Generates the mesh for a <see cref="T:Arterra.Core.Terrain.TerrainChunk.VisualChunk"><b>fake</b> visual chunk</see>. Because the map data is 
            not stored with only the default map being recreated on demand, a <i>fake mesh</i> is created in the sense that it is
            not only non-interactable, but also cannot be changed within the context of the game. </summary>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="!:Quality.Terrain.IsoLevel"/> for more info.</param>
            <param name="chunkSize">The resolution of the mesh generated for the chunk. Equivalent to the amount of entries per axis within the map saved for this chunk</param>
            <param name="neighborDepths">A bitmap describing the potential difference in depth between this chunk and its neighbors,
            used in generating transition information. See <see cref="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetNeighborDepths(System.UInt32)"/> and <see cref="M:Arterra.Core.Terrain.Map.Generator.GenerateTransition(System.UInt32,System.Int32,System.Single)"/>
            for more info.</param>
        </member>
        <member name="T:Arterra.Core.Terrain.Map.Generator">
            <summary> A static manager responsible for managing loading and access
            of all compute-shaders used within the map and mesh generation process
            of terrain generation. All instructions related to map/mesh
            generation done by the GPU is streamlined from this module. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.bufferOffsets">
            <summary> The offsets within the <see cref="F:UtilityBuffers.GenerationBuffer"> working buffer </see> of different 
            logical regions used for different tasks during the terrain generation process. See <see cref="T:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets"/>
            for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.PresetData">
            <summary>  Presets all compute-shaders used through map and base mesh generation by acquiring 
            them and binding any constant values(information derived from the world's settings that 
            won't change until the world is unloaded) to them. Referenced by
            <see cref="M:Arterra.Core.Terrain.SystemProtocol.Startup"/> </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.MinimalInitialize">
            <summary>Initializes just the basic buffer offsets within <see cref="F:Arterra.Core.Terrain.Map.Generator.bufferOffsets"/> to support map based mesh generation. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.GenerateBaseData(UnityEngine.Vector3,System.UInt32,System.Int32,System.Int32,System.Single)">
            <summary> See <see cref="M:Arterra.Core.Terrain.Map.Creator.GenerateBaseChunk(Unity.Mathematics.float3,System.UInt32,System.Int32,System.Int32,System.Single)"/> for info. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.GenerateBiomeData(UnityEngine.Vector3,System.UInt32,System.Int32,System.Int32)">
            <summary> See <see cref="M:Arterra.Core.Terrain.Map.Creator.PopulateBiomes(Unity.Mathematics.float3,System.UInt32,System.Int32,System.Int32)"/> for info. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.CompressMapData(System.Int32)">
            <summary> See <see cref="M:Arterra.Core.Terrain.Map.Creator.CompressMap(System.Int32)"/> for info. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.CollectRealMap(Unity.Mathematics.int3,System.Int32)">
            <summary> Collects the map data for a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk">real chunk</see>. Retrieves the map data stored in a hashmap by <see cref="T:Arterra.Core.Storage.GPUMapManager"/> 
            and copies it into <see cref="F:UtilityBuffers.GenerationBuffer">working memory</see> where it can be accessed easier.
            Out-of-bound map information necessary for mesh generation is additionally copied; more accurately the first and last two
            entries of each axis of the map are retrieved from the stored map data submitted by neighboring chunks, discoverable through 
            the hashmap managed by <see cref="T:Arterra.Core.Storage.GPUMapManager"/>. To avoid gaps, a real chunk that invokes this function should avoid bordering 
            <see cref="T:Arterra.Core.Terrain.TerrainChunk.VisualChunk"><b>fake</b> visual</see> chunks that are not saved at all and hence not discoverable. </summary>
            <param name="CCoord">The coordinate in chunk space of the origin of the chunk.</param>
            <param name="chunkSize">The resolution of the mesh generated for the chunk. Equivalent to the amount of entries per axis within the map saved for this chunk.
            The amount of points in the map retrieved by this function is (<paramref name="chunkSize"/>+3)^3</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.CollectVisualMap(Unity.Mathematics.int3,System.Int32,System.Int32,System.Int32)">
            <summary> Collects the map data for a <see cref="T:Arterra.Core.Terrain.TerrainChunk.VisualChunk">normal visual chunk</see>. Retrieves the map data stored in a hashmap by <see cref="T:Arterra.Core.Storage.GPUMapManager"/> 
            and copies it into <see cref="F:UtilityBuffers.GenerationBuffer">working memory</see> where it can be accessed easier. Out-of-bound map information necessary for mesh 
            generation is additionally copied; more accurately the first and last two entries of each axis of the map are retrieved from the stored map data submitted by 
            neighboring chunks, discoverable through the hashmap managed by <see cref="T:Arterra.Core.Storage.GPUMapManager"/>. Because a normal visual chunk can border fake visual chunks which 
            are only capable of reflecting the readonly default map information, each normal visual chunk also contains neighboring default map information which it may copy when
            collecting if it cannot discover its neighbors. </summary>
            <param name="CCoord">The coordinate in chunk space of the origin of the chunk.</param>
            <param name="defaultAddress">The address within an <see cref="P:Arterra.Core.Storage.GPUMapManager.DirectAddress">indirect address buffer</see> 
            of the address of the base map information for the visual chunk. This includes dirty information belonging to the chunk
            as well as the default map for entries outside its own bounds. </param>
            <param name="chunkSize">The resolution of the mesh generated for the chunk. Equivalent to the amount of entries per axis within the map saved for this chunk.
            The amount of points in the map retrieved by this function is (<paramref name="chunkSize"/>+3)^3</param>
            <param name="depth">The distance of the chunk from a leaf node within the <see cref="T:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree">chunk octree</see>. Identifies
            the distance between samples in a map of the resolution defined by <i>depth</i>.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.GenerateMesh(System.Int32,System.Single)">
            <summary> Generates the visual mesh for a chunk based off the map data stored in the <see cref="F:UtilityBuffers.GenerationBuffer">working buffer</see>.
            The mesh is generated using the marching cubes algorithm and is stored in a distributed form within the buffer in a way that avoids
            duplicated vertex information. Two seperate meshes are created for every chunk, one for the base terrain and one for liquids. </summary>
            <remarks>See <see href="https://paulbourke.net/geometry/polygonise/">here</see> to learn about marching cubes. </remarks>
            <param name="chunkSize">The resolution of the mesh generated for the chunk; the amount of cubes marched per axis of the chunk.</param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="!:Quality.Terrain.IsoLevel"/> for more info.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.GenerateTransition(System.UInt32,System.Int32,System.Single)">
            <summary> Generates the transition mesh for a chunk based off the map data stored in the <see cref="F:UtilityBuffers.GenerationBuffer">working buffer</see>
            and the resolution of the neighboring chunks that the current chunk is to blend with. The transition mesh is generated using the <see href="https://transvoxel.org/">
            transvoxel algorithm </see> which allows for smooth transitions between chunks of exactly twice the resolution. This function layers multiple transition
            meshes to allow for transitions between chunks of any power of 2 difference in resolution, thus supporting any octree <see cref="!:Quality.Terrain.Balance">
            balance factor</see>. </summary>
            <remarks> The time complexity of this function is O(m*n^2) where n is the resolution of the chunk and 
            m the number of transition faces necessary to blend between a chunk and all of its neighbors. </remarks>
            <param name="neighborDepths">A bitmap describing the potential difference in depth between this chunk and its neighbors,
            used in generating transition information. See <see cref="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetNeighborDepths(System.UInt32)"/> and <see cref="M:Arterra.Core.Terrain.Map.Generator.GenerateTransition(System.UInt32,System.Int32,System.Single)"/>
            for more info.</param>
            <param name="chunkSize">The resolution of the mesh generated for the transition face; the amount of cubes marched per axis of the face.</param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="!:Quality.Terrain.IsoLevel"/> for more info.</param>
        </member>
        <member name="T:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets">
            <summary> Responsible for segmenting a fixed sized <see cref="F:UtilityBuffers.GenerationBuffer"> working memory </see> buffer
            into regions for different purposes within the map and mesh generation process. Only regions that can
            exist simultaneously need to occupy exclusive regions, otherwise the memory may be reused. See
            <see cref="T:BufferOffsets"/> for more info. </summary>
            <remarks>The locations specified within this structure is relative to the size of the objects that will be occupying
            them and not based off a universal atomic unit. </remarks>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.vertexCounter">
            <summary> The location storing the amount of vertices in the generated mesh. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.baseTriCounter">
            <summary> The location storing the amount of base terrain triangles in the generated mesh. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.waterTriCounter">
            <summary>The location storing the amount of liquid terrain triangles in the generated mesh. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.mapStart">
            <summary> The location storing the <see cref="M:Arterra.Core.Terrain.Map.Creator.CompressMap(System.Int32)">uncompressed</see> map data for the chunk.
            This is never used simultaneously with the compressed map data stored in at <see cref="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.rawMapStart"/> and thus
            can occupy the same region. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.rawMapStart">
            <summary> The location storing the compressed map data for the chunk. This is the map data recognized by most systems. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.biomeMapStart">
            <summary> The location storing the biome map data for the chunk when the biome map is <see cref="M:Arterra.Core.Terrain.Map.Creator.PopulateBiomes(Unity.Mathematics.float3,System.UInt32,System.Int32,System.Int32)">explicitly queried</see>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.dictStart">
            <summary> The location of the vertex dictionary used during mesh generation. The vertex dictionary is a perfect hash map that references
            where in the <see cref="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.vertStart">vertex buffer</see> the vertex data shared by multiple triangles is stored. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.vertStart">
            <summary> The location of the vertex buffer created during mesh generation. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.baseTriStart">
            <summary>The location of the base terrain triangles(index buffer) created during mesh generation.</summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.waterTriStart">
            <summary>The location of the liquid terrain triangles(index buffer) created during mesh generation.</summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.bufferStart">
            <summary> The start of the buffer region that is used by the Map and Mesh generator. 
            See <see cref="P:BufferOffsets.bufferStart"/> for more info. </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.bufferEnd">
            <summary> The end of the buffer region that is used by the Map and Mesh generator. 
            See <see cref="P:BufferOffsets.bufferEnd"/> for more info. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.#ctor(Unity.Mathematics.int3,System.Int32,System.Int32,System.Int32)">
            <summary> Creates a new division scheme of working memory based on the maximum size of the map and mesh
            that can be generated.  An increased resolution of the map and mesh, or an increased amount of vertex data, 
            will require more working memory allocated for the map generator. The caller should make sure this does not 
            exceed the capacity of the buffer. </summary>
            <param name="GridSize">The amount of samples per axis exclusively bounded by the map. The amount of 
            cubes marched along each dimension when generating a mesh. For a cubic chunk, all components of the vector 
            should be equivalent.</param>
            <param name="chunkBalance">The balance factor of the octree; indicates the maximum amount of transition 
            faces a chunk can request. See <see cref="!:Quality.Terrain.Balance"/> for more info. </param>
            <param name="bufferStart">The start of the region within working memory the structure generator may utilize. See 
            <see cref="P:BufferOffsets.bufferStart"/> for more info. </param>
            <param name="VertexStride">The size of the vertex data for one vertex, in units of 4-bytes.</param>
        </member>
        <member name="T:Arterra.Core.Terrain.Structure.Creator">
            <summary>
            A manager unique for every terrain chunk responsible for creating and holding onto
            intermediate structure information required by the chunk during the terrain
            generation process.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Creator.StructureDataIndex">
            <summary>
            The address of the generated structure information for this chunk. The location within 
            <see cref="F:Arterra.Configuration.Quality.MemoryOccupancyBalancer.addressBuffers"/> of the address within
            /// <see cref="P:Arterra.Configuration.Quality.MemoryOccupancyBalancer.Storage"/> 
            of the beginning of the structure information for this chunk.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Creator.ReleaseStructure">
            <summary>  Releases any intermediate structure information sheld by this instance. Call this to ensure
            that no memory is being held by a chunk being disposed. See <seealso cref="F:Arterra.Core.Terrain.Structure.Creator.StructureDataIndex"/>. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Creator.PlanStructuresGPU(Arterra.Core.Terrain.Readback.AsyncGenInfoReadback,Unity.Mathematics.int3,Unity.Mathematics.float3,System.Int32,System.Single,System.Int32)">
            <summary> Finds all structures that intersect with the current chunk's boundaries. Planned structures are represented
            through their <i>origin</i>, <i>structure index</i>, and <i>rotation</i> relative to the chunk's origin. 
            Planning structures encompasses the first two steps of structure generation, <see href="https://blackmagic919.github.io/AboutMe/2024/06/08/Structure%20Planning/">
            planning </see> and <see href="https://blackmagic919.github.io/AboutMe/2024/06/16/Structure-Pruning/">>pruning</see>, and is 
            necessary to ensure structures across chunk boundaries are recognized and generated correctly. </summary>
            <remarks>Structures are sampled in a deterministic manner meaning that the same structures 
            will be generated in the same location in the same world regardless of any other factors. </remarks>
            <param name="readback" >The <see cref="T:Arterra.Core.Terrain.Readback.AsyncGenInfoReadback"/> task responsible for batching intermediate generation
            information to be readback to the CPU.</param> 
            <param name="chunkCoord">The coordinate, in <see cref="F:Arterra.Core.Terrain.TerrainChunk.CCoord"/>Chunk Space, of the chunk whose structures
            are planned. If the chunk spans multiple <paramref name="chunkCoord">ChunkCoords</paramref>, this is the coordinate of the origin of
            the region. </param>
            <param name="offset">The offset in grid space of the origin of the chunk. This should be 
            equvalent to (<paramref name="chunkCoord"/> * <paramref name="chunkSize"/>)</param>
            <param name="chunkSize">The size of the chunk a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk">real chunk</see> in grid space. The atomic
            unit for guaranteed determinstic sampling of chunk structures. </param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/> for more info. </param>
            <param name="depth"> The distance of the chunk from a leaf node within the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.octree">chunk octree</see>. Identifies
            the size of the chunk relative to a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"> real chunk </see>. See <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/> for more info. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Creator.GenerateStrucutresGPU(System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
            <summary> Generates the planned structures for the current chunk. This involves actually transcribing the <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.map">
            map information </see> of each structure onto the chunk's map in <see cref="F:UtilityBuffers.GenerationBuffer">working memory</see> that will be used to create the visual and
            interactable features of the chunk. This must be called after the chunk's base map has been populated through
            <see cref="M:Arterra.Core.Terrain.Map.Generator.GenerateBaseData(UnityEngine.Vector3,System.UInt32,System.Int32,System.Int32,System.Single)"/>. </summary>
            <remarks>The time complexity of this operation is O(n) with respect to the size of the largest structure within the chunk.</remarks>
            <param name="chunkSize">The size of the chunk a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk">real chunk</see> in grid space.</param>
            <param name="skipInc">The distance in grid space between two adjacent samples in the chunk's terrain map. Used to convert
            a structure's coordinate from grid space to map space(the location within the chunk's terrain map). </param>
            <param name="mapStart">The start of the chunk's terrain map within the <see cref="F:UtilityBuffers.GenerationBuffer"/>. See <see cref="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.rawMapStart"/>
            for more info. </param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/> for more info.</param>
            <param name="wChunkSize">The axis size of the chunk's terrain map as it currently is in <see cref="F:UtilityBuffers.GenerationBuffer"> working memory </see>.</param>
            <param name="wOffset">The offset within the chunk's map generated structures will be transcribed to. If the chunk's map
            extends beyond what it exclusively contains, this should be used to indicate the axis offest relative to the chunk map's first
            entry of the first entry exclusively contained by the chunk. </param>
        </member>
        <member name="T:Arterra.Core.Terrain.Structure.Generator">
            <summary> A static manager responsible for managing loading and access
            of all compute-shaders used within the structure generation process
            of terrain generation. All instructions related to structure
            generation done by the GPU is streamlined from this module.  </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.offsets">
            <summary> The offsets within the <see cref="F:UtilityBuffers.GenerationBuffer"> working buffer </see> of different 
            logical regions used for different tasks during the terrain generation process. See <see cref="T:Arterra.Core.Terrain.Structure.Generator.StructureOffsets"/>
            for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.PresetData">
            <summary>
            Presets all compute-shaders used in the structure generator by acquiring them and
            binding any constant values(information derived from the world's settings that 
            won't change until the world is unloaded) to them. Referenced by
            <see cref="M:Arterra.Core.Terrain.SystemProtocol.Startup"/> </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.SampleStructureLoD(System.Int32,System.Int32,System.Int32,Unity.Mathematics.int3)">
            <summary> Samples the origins of all structures that intersect with the current chunk's boundaries. This is the <see href="https://blackmagic919.github.io/AboutMe/2024/06/08/Structure%20Planning/">
            first step </see> of structure generation and is necessary to ensure that the chunk is aware of all structures that overlap
            with its boundaries. </summary>
            <param name="maxLoD">The maximum LoD of structures generated. The LoD dictates the maximum side length of a structure
            that is guaranteed to be generated properly. See <see cref="F:Arterra.Configuration.Generation.Structure.Generation.maxLoD"/> for more info.</param>
            <param name="chunkSize">The size of a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/> in grid space. </param>
            <param name="depth">The distance of the chunk from a leaf node within the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.octree">chunk octree</see>. Identifies
            the size of the chunk relative to a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"> real chunk </see>. See <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/> for more info. </param>
            <param name="chunkCoord">The coordinate, in <see cref="F:Arterra.Core.Terrain.TerrainChunk.CCoord">Chunk Space</see>, of the chunk whose structures
            are planned. If the chunk spans multiple <paramref name="chunkCoord">ChunkCoords</paramref>, this is the coordinate of the origin of
            the region. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.IdentifyStructures(UnityEngine.Vector3,System.Single)">
            <summary> Assigns structures to each position given by <see cref="M:Arterra.Core.Terrain.Structure.Generator.SampleStructureLoD(System.Int32,System.Int32,System.Int32,Unity.Mathematics.int3)"/> based on 
            the biome and removes any invalid or trivial structures. This is the <see href="https://blackmagic919.github.io/AboutMe/2024/06/16/Structure-Pruning/">
            second step </see> of structure generation and allows for varied and localized structure generation. </summary>
            <param name="offset">The offset in grid space of the origin of the chunk</param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/> for more info.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.TranscribeStructures(UnityEngine.GraphicsBuffer,System.UInt32,System.Int32)">
            <summary>  Transcribes the generation information of structures instersecting with the chunk from <see cref="F:UtilityBuffers.GenerationBuffer"> working memory</see> to
            long term storage. This is the instance information of structures that <b>will</b> be generated
            in the chunk innevitably, following all pruning steps. </summary>
            <param name="addresses">The buffer containing the direct address within the associated long term buffer where the information will be stored. </param>
            <param name="addressIndex"> >The index within <paramref name="addresses"/> of the location that contains the direct address to the 
            region within the associated long term buffer where the information will be stored. </param>
            <param name="metaAddress"> The index withing <paramref name="addresses"/> of the location that contains the direct address to the 
            region within the associated long term buffer where enhanced structures will be stored. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.GetStructCount(UnityEngine.ComputeBuffer,UnityEngine.GraphicsBuffer,System.Int32,System.Int32)">
            <summary> Gets the number of structures saved in the memory block pointed to by a chunk's <paramref name="addressIndex">address handle</paramref> for its structures.
            This information is not explicitly stored but can be reconstructed by dividing the size of the allocated memory block by the size of a structure, factoring
            in meta data and padding. If the memory block is not represented in a known way or does not contain structure generation information, the result is undefined. </summary>
            <param name="memory">The GPU buffer containing the structure generation information that is to be counted.</param>
            <param name="address">The buffer containing the direct address within <paramref name="memory"/>where the information is stored. </param>
            <param name="addressIndex">The index within <paramref name="address"/> of the location that contains the direct address to the 
            region within <paramref name="memory"/> where the information is stored.</param>
            <param name="STRUCTURE_STRIDE_4BYTE">The size of the generation information of a single structure in units of 4-bytes. The amount of 
            unique structures can be obtained by dividing the total size of the chunk's structure generation information by this size.</param>
            <returns>A buffer containing the amount of structures in its first entry.</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.ApplyStructures(UnityEngine.ComputeBuffer,UnityEngine.GraphicsBuffer,UnityEngine.ComputeBuffer,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary> Applies the generation information of structures to the chunk's terrain map. This is the <see href="https://blackmagic919.github.io/AboutMe/2024/07/03/Structure-Placement/">
            final step</see> of structure generation and involves transcribing the <see cref="F:Arterra.Configuration.Generation.Structure.StructureData.map"/> information of each structure 
            over the chunk's terrain map. </summary>
            <remarks> The time complexity of this operation is O(n) with respect to the size of the largest structure within the chunk. </remarks>
            <param name="memory">The buffer containing the generation information for all structures generated by the chunk.</param>
            <param name="addresses">he buffer containing the direct address within <paramref name="memory"/>where the generation information is stored. </param>
            <param name="count">A single entry buffer dictating the amount of structures to place. </param>
            <param name="addressIndex">The index within <paramref name="addresses"/> of the location that contains the direct address to the 
            region within <paramref name="memory"/> where the generation information is stored.</param>
            <param name="mapStart">The location within <see cref="F:UtilityBuffers.GenerationBuffer">working memory</see> of the start of the
            chunk's terrain map. See <see cref="F:Arterra.Core.Terrain.Map.Generator.GeoGenOffsets.rawMapStart"/> for more info. </param>
            <param name="chunkSize">The size of a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"/> in grid space. </param>
            <param name="skipInc">The distance in grid space between two adjacent samples in the chunk's terrain map. Used to convert
            a structure's coordinate from grid space to map space(the location within the chunk's terrain map).</param>
            <param name="wOffset">The offset within the chunk's map generated structures will be transcribed to. If the chunk's map
            extends beyond what it exclusively contains, this should be used to indicate the axis offest relative to the chunk map's first
            entry of the first entry exclusively contained by the chunk.</param>
            <param name="wChunkSize">The axis size of the chunk's terrain map as it currently is in <see cref="F:UtilityBuffers.GenerationBuffer"> working memory </see>.</param>
            <param name="IsoLevel">The density of the surface of the terrain. See <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/> for more info.</param>
        </member>
        <member name="T:Arterra.Core.Terrain.Structure.Generator.StructureOffsets">
            <summary> Responsible for segmenting a fixed sized <see cref="F:UtilityBuffers.GenerationBuffer"> working memory </see> buffer
            into regions for different purposes within the structure generation process. Only regions that can
            exist simultaneously need to occupy exclusive regions, otherwise the memory may be reused. See
            <see cref="T:BufferOffsets"/> for more info. </summary>
            <remarks>The locations specified within this structure is relative to the size of the objects that will be occupying
            them and not based off a universal atomic unit. </remarks>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.sampleCounter">
            <summary> The location storing the amount of raw structure origins generated by <see cref="M:Arterra.Core.Terrain.Structure.Generator.SampleStructureLoD(System.Int32,System.Int32,System.Int32,Unity.Mathematics.int3)"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.structureCounter">
            <summary> The location storing the amount of concrete structures after pruning non-intersecting structures, provided by <see cref="M:Arterra.Core.Terrain.Structure.Generator.IdentifyStructures(UnityEngine.Vector3,System.Single)"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.checkCounter">
            <summary> The location storing the total amount of checks of all structures within the chunk, used in <see cref="M:Arterra.Core.Terrain.Structure.Generator.IdentifyStructures(UnityEngine.Vector3,System.Single)"/>.
            See <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckPoint"/> for more info. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.prunedCounter">
            <summary> The location storing the amount of structures after pruning all invalid checks, provided by <see cref="M:Arterra.Core.Terrain.Structure.Generator.IdentifyStructures(UnityEngine.Vector3,System.Single)"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.ehStctCounter">
            <summary> The location storing the amount of enhanced structures aftr pruning </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.mStructCounter">
            <summary> An auxiliary counter used when transcribing </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.tempCounter">
            <summary>The location of a temporary multipurpose counter.</summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.prunedStart">
            <summary> The location of the pruned structures, the structures that will actually be generated, provided by <see cref="M:Arterra.Core.Terrain.Structure.Generator.IdentifyStructures(UnityEngine.Vector3,System.Single)"/>.</summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.sampleStart">
            <summary> The location of the raw structure origins provided by <see cref="M:Arterra.Core.Terrain.Structure.Generator.SampleStructureLoD(System.Int32,System.Int32,System.Int32,Unity.Mathematics.int3)"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.structureStart">
            <summary> The location of the structure generation information provided by <see cref="M:Arterra.Core.Terrain.Structure.Generator.IdentifyStructures(UnityEngine.Vector3,System.Single)"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.checkStart">
            <summary> The location of the checks of all structures within the chunk, used in <see cref="M:Arterra.Core.Terrain.Structure.Generator.IdentifyStructures(UnityEngine.Vector3,System.Single)"/>. </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.bufferStart">
            <summary> The start of the buffer region that is used by the structure generator. 
            See <see cref="P:BufferOffsets.bufferStart"/> for more info. </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.bufferEnd">
            <summary> The end of the buffer region that is used by the structure generator. 
            See <see cref="P:BufferOffsets.bufferEnd"/> for more info. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.StructureOffsets.#ctor(System.Int32,System.Int32)">
            <summary> Creates a new division scheme of working memory based on the maximum amount of structure points
            a chunk may need to reference simultaneously. An increased number of points will require more working
            memory allocated for the structure generator. The caller should make sure this does not 
            exceed the capacity of the buffer. </summary>
            <param name="maxStructurePoints">The maximum amount of structures that a single chunk may reference at the same time.
            This is the maximum possible structures that can be provided by <see cref="M:Arterra.Core.Terrain.Structure.Generator.SampleStructureLoD(System.Int32,System.Int32,System.Int32,Unity.Mathematics.int3)"/> for
            the <see cref="F:Arterra.Configuration.Quality.Terrain.MaxStructureDepth">largest possible chunk requiring structures</see> under the given 
            world's configuration. A larger chunk will require more structure points as it encompasses a larger region. </param>
            <param name="bufferStart">The start of the region within working memory the structure generator may utilize. See 
            <see cref="P:BufferOffsets.bufferStart"/> for more info. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Structure.Generator.InitializeStructureMeta(Arterra.Core.Terrain.Readback.GenPoint,Unity.Mathematics.int3,System.Byte)">
            <summary> Creates entities and structures tied to a certain structure as indicated by
            the <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.EnhancedFeatures"/> of a certain structure. </summary>
            <param name="genInfo">The information describing a certain structure placement.</param>
            <param name="CCoord">The coordinate in chunk space of the chunk <paramref name="genInfo"/> belongs to</param>
            <param name="cxt"> Context on which structure meta to process and which to skip </param>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainChunk">
            <summary>
            The unit of terrain generation, a chunk is(usually) a leaf node on the octree which bounds
            an mutually exclusive region of space relative to all other terrain chunks. Terrain chunks
            can be of various sizes and are created by the <see cref="T:Arterra.Core.Terrain.OctreeTerrain"/> system to partition and 
            manage all information pertaining to that specific region of space. When a different terrain chunk
            is created in the same region, the old chunk is destroyed and the new chunk is created in its place.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.index">
            <summary> The index of the chunk's octree ndoe in the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.octree"/> </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.active">
            <summary> Whether or not the chunk is active. A chunk can exist and not be active if it's a zombie </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.Active">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.origin">
            <summary> The origin of the chunk in grid space. The origin is the bottom left corner of the chunk</summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.CCoord">
            <summary> The chunk's coordinate in chunk space of the smallest terrain chunk(real chunks). This is the coordinate space 
            such that each real chunk is assigned a unique integer coordinate. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.size">
            <summary> The size of the chunk in grid space. The size is the length of one side of the chunk in grid units. </summary>
            <remarks> This is equivalent to <see cref="!:Quality.Terrain.mapChunkSize"/> * (2^<see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/></remarks>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.depth">
            <summary>The depth of the chunk in the <see cref="T:Arterra.Core.Terrain.OctreeTerrain"/></summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.IsRealChunk">
            <summary>Whether or not the chunk is a real chunk. Real chunks are the smallest chunks in the octree. A chunk is a real chunk if it's depth is 0. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.meshObject">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.Generator">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.rSettings">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.meshRenderer">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.meshFilter">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.IsoLevel">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.mapChunkSize">
            <exclude />
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.mapSkipInc">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.GeoShaders">
            <summary> The manager for geo-shaded geometry generation </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.status">
            <summary> The status of the chunk which describes the type of generation that needs to be done. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.neighborDepth">
            <summary> The depth of the chunk's neighbors. This is used to blend the chunk's mesh with its neighbors. </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.MeshTransform">
            <summary> The transform of the mesh object as it is shown in the world </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainChunk.Status">
            <summary>
            A bitmap container describing the types of requested tasks for the chunk. To request the
            chunk perform a specific task, one can set the corresponding bit information in the data field
            and the chunk will automatically perform the task on the next update cycle or when it is possible to do so.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.Status.UpdateMap">
            <summary> Whether or not the chunk needs to update its map data. Do not set this directly, <see cref="P:Arterra.Core.Terrain.TerrainChunk.Status.CreateMap"/>, <see cref="P:Arterra.Core.Terrain.TerrainChunk.Status.ShrinkMap"/>, and <see cref="P:Arterra.Core.Terrain.TerrainChunk.Status.SetMap"/>
            automatically set this value when they are set. </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.Status.CreateMap">
            <summary> Whether or not the chunk needs to regenerate the map data. This is true by default when creating a new chunk </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.Status.ShrinkMap">
            <summary> If it is of higher resolution, whether or not it can be shrunk down to a lower resolution. This is not used
            currently with an Octree model, but for a flat grid model, this would be used to shrink the map down to a lower resolution. </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.Status.SetMap">
            <summary>
            Whether or not the chunk needs to copy its map information from the CPU to the GPU. 
            To visually update chunk, it must be copied to the GPU.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.Status.UpdateMesh">
            <summary>
            Whether or not the chunk can recreate its mesh information. This will eventually allow the mesh to be updated
            when it reaches the proper update cycle to recieve out-of-bound information from chunks outside itself. 
            This is true by default when creating a new chunk.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainChunk.Status.CanUpdateMesh">
            <summary>
            Whether or not the chunk can update its mesh data. Do not set this directly, <see cref="P:Arterra.Core.Terrain.TerrainChunk.Status.UpdateMesh"/> 
            automatically sets this value when the chunk is actually able to update its mesh data. 
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainChunk.Status.State">
            <summary> The enum describing the current 
            progress of any chunk update request.  </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.Status.State.Finished">
            <summary> Whether or not the requested update is finished.  </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.Status.State.Pending">
            <summary> Whether or not the requested update is pending and 
            waiting to be enqueued into the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.RequestQueue">generation queue</see>
            during the next update cycle. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.Status.State.InProgress">
            <summary> Whether or not the requested update is enqueued
            in the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.RequestQueue">generation queue</see> and 
            will be executed when it reaches the front of the queue</summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.Status.Initiate(Arterra.Core.Terrain.TerrainChunk.Status.State)">
            <summary> Progresses the given state to <see cref="F:Arterra.Core.Terrain.TerrainChunk.Status.State.Pending"/> only if it is currently <see cref="F:Arterra.Core.Terrain.TerrainChunk.Status.State.Finished"/> </summary>
            <param name="s">The state to progress</param>
            <returns>The current or pending state</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.Status.Complete(Arterra.Core.Terrain.TerrainChunk.Status.State)">
            <summary> Progresses the given state to <see cref="F:Arterra.Core.Terrain.TerrainChunk.Status.State.Finished"/> only if it is currently <see cref="F:Arterra.Core.Terrain.TerrainChunk.Status.State.InProgress"/> </summary>
            <param name="s">The state to progress</param>
            <returns>The current or pending state</returns>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainChunk.GeneratorInfo">
            <summary> 
            A container containing instances of systems pertinent to 
            different processes in terrain generation 
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.GeneratorInfo.MeshReadback">
            <summary> The manager in charge of performing GPU-forward mesh rendering while
            reading back mesh data from the GPU to a Unity mesh object</summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.GeneratorInfo.MetaReadback">
            <summary> The manager in charge of performing GPU-readbacks of other intermediate generated
            information that needs to be processed by the CPU. Mainly in charge of batching these requests
            to reduce excessive readback requests.  </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.GeneratorInfo.MeshCreator">
            <summary> The manager in charge of creating mesh data for the chunk </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.GeneratorInfo.StructCreator">
            <summary> The manager in charge of planning, pruning, and placing structure data for the chunk </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainChunk.GeneratorInfo.SurfCreator">
            <summary> The manager in charge of creating the surface data for the chunk.  </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.GeneratorInfo.#ctor(Arterra.Core.Terrain.TerrainChunk)">
            <summary> Creates instances of managers for the chunk given the chunk's information </summary>
            <param name="terrainChunk">The Terrain chunk whose information is used</param>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.#ctor(UnityEngine.Transform,Unity.Mathematics.int3,System.Int32,System.UInt32)">
            <summary>
            Creates a new terrain chunk with the the given origin and size. The newly created chunk
            will maintain a reference to its octree node, which it can use to make requests to update itself.
            In the game hierarchy, it will be a child of the given parent transform.
            </summary>
            <param name="parent">The parent in the gameobject heiharchy of the Terrain Chunk's gameobject</param>
            <param name="origin">The <see cref="F:Arterra.Core.Terrain.TerrainChunk.origin"/> of the terrain chunk in grid space</param>
            <param name="size"> The size of the terrain chunk in grid space</param>
            <param name="octreeIndex">The index of the chunk's octree node in the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.octree"/> </param>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.GetRelativeBoundsOS(Unity.Mathematics.float3,Unity.Mathematics.float3)">
            <summary> Transforms a childs bounds given in world space to the local 
            bounds and offset within the chunk. </summary>
            <param name="origin">The origin of the bounds</param>
            <param name="size">The size of the bounds</param>
            <returns>The Object Space Bounds</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VerifyChunk">
            <summary>
            Verifies whether the chunk's is still valid given the relative 
            position of the viewer and the octree's state. If it is not it may destroy the chunk and replace it
            to become valid. If the chunk is a zombie this function will do nothing.
            </summary> 
            <remarks>
            As this function is called whenever OctreeTerrain re-validates the terrain, it can
            be overrided to perform additional verification steps during this event.
            </remarks>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.Kill">
            <summary>
            If the chunk is <see cref="F:Arterra.Core.Terrain.TerrainChunk.active"/>, it will be deactivated, thus turning it into a zombie.
            Simultaneously, all dependencies(zombies) waiting on the chunk will be reaped, <seealso cref="M:Arterra.Core.Terrain.Octree`1.ReapChunk(System.UInt32)"/>
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.Destroy">
            <summary>
            Releases all information associated with the chunk in various systems
            and destroys the gameobject. Call this to permanently destroy a chunk, whose
            information should not be referenced after that point.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.ReleaseChunk">
            <summary>
            An overridable function that is called when the chunk is destroyed. If a terrain chunk variant contains
            additional information that needs to be released, it should override this function to release that information.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.ReflectChunk">
            <summary>
            Requests the chunk to reflect its CPU-side map data visually by setting status flags, 
            Specifically the flags to <see cref="P:Arterra.Core.Terrain.TerrainChunk.Status.SetMap"/> and <see cref="P:Arterra.Core.Terrain.TerrainChunk.Status.UpdateMesh"/>
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.ReflectChunkThread">
            <summary>
            Requests the chunk to reflect its CPU-side map data visually by setting status flags, 
            similar to <see cref="M:Arterra.Core.Terrain.TerrainChunk.ReflectChunk"/>, but is a thread safe operation.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.ClearFilter">
            <summary>Overridable event when deleting CPU-cached mesh information </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.Update">
            <summary> 
            Overridable event triggered within update-loop. Primarily used to queue generation tasks
            based on the chunk's status flags. Expensive operations should be queued in the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.RequestQueue"/>
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.GetSurface">
            <summary>
            The generation task which retrieves surface information necessary to generate the surface terrain of the world
            as well as conditions used in determining the surface biome. This information is stored in the <see cref="T:Arterra.Core.Terrain.Surface.Creator"/>
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.PlanStructures(System.Action)">
            <summary> The generation task which plans the structures for the chunk. This is the first step in generating the chunk's structure data. 
            Chunks are only capable of planning structures if their depth is less than or equal to <see cref="!:Quality.Terrain.MaxStructureDepth"/> </summary>
            <param name="callback">The callback function that's called once structure planning has been completed (or inserted into a GPU cmd buffer)</param>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.ReadMapData(System.Action)">
            <summary> The generation task which creates the map information for the chunk. This is the middle step in generating the chunk's information. 
            Chunks will also prune structures if they have cached structure information from <see cref="M:Arterra.Core.Terrain.TerrainChunk.PlanStructures(System.Action)"/>. </summary>
            <param name="callback">The callback function that's called once ReadMapData has been completed (or inserted into a GPU cmd buffer)</param>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.CreateMesh(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo})">
            <summary> The generation task which creates the mesh information for the chunk. This is the final step in generating the chunk's information. 
            Optionally chunks will place structures and generate geoshaded geometry if they have cached structure information from <see cref="M:Arterra.Core.Terrain.TerrainChunk.ReadMapData(System.Action)"/> 
            and their depth is less than or equal to <see cref="!:Quality.GeoShaderSettings.MaxGeoShaderDepth"/> respectively.
            </summary> <param name="UpdateCallback">The callback function that's returned the mesh constructor once the mesh has been readback</param>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.OnChunkCreated(Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo)">
            <exclude />
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainChunk.RealChunk">
            <summary>
            A real chunk is a chunk of the lowest <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/>, therefore the smallest size (equal to <see cref="!:Quality.Terrain.mapChunkSize"/>). 
            They are the chunks closest to the viewer and the only chunk that is capable of lossless sampling so it is the only chunk that maintains a copy of its map information 
            on the CPU. By extension, it is the only chunk that is capable of terrain interaction, collision, and entity pathfinding. With respect to the interactable game
            environment, it is all that exists.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.RealChunk.#ctor(UnityEngine.Transform,Unity.Mathematics.int3,System.Int32,System.UInt32)">
            <summary> Creates a new real chunk with the the given origin and size. <seealso cref="T:Arterra.Core.Terrain.TerrainChunk"/> </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.RealChunk.VerifyChunk">
            <summary> Verifies whether the chunk's is still valid given that a chunk is not valid if it was previously bording a chunk of a 
            larger size and is no longer or vice versa. If it is not valid, sets the <see cref="P:Arterra.Core.Terrain.TerrainChunk.Status.UpdateMesh"/> flag to true. </summary>
            <remarks> If a chunk is bordering a chunk of a certain size, some of its out-of-bound mesh information will be invalidated once the neighboring chunk changes size. </remarks>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.RealChunk.Update">
            <summary> Based upon the chunk's status, enqueues generation tasks to the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.RequestQueue"/>
            to reflect the flags. The status is updated accordingly after the tasks are enqueued/finished. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.RealChunk.GetSurface">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.RealChunk.PlanStructures(System.Action)">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.RealChunk.ReadMapData(System.Action)">
            <summary>Beyond what is described in <see cref="M:Arterra.Core.Terrain.TerrainChunk.ReadMapData(System.Action)"/>, real chunks also reads 
            chunk files from storage, create/deserialize entities, and copy map data to the CPU.
            </summary> <param name="callback"><see cref="M:Arterra.Core.Terrain.TerrainChunk.ReadMapData(System.Action)"/></param>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.RealChunk.CreateMesh(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo})">
            <summary> 
            To create the mesh, the information is gathered by sampling the GPU-side dictionary provided by the <see cref="T:Arterra.Core.Storage.GPUMapManager"/>,
            this allows the chunk to obtain information about the map data of neighboring chunks which is necessary for generating the mesh boundaries.
            <seealso cref="M:Arterra.Core.Terrain.TerrainChunk.CreateMesh(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo})"/>
            </summary>
            <param name="UpdateCallback"><see cref="M:Arterra.Core.Terrain.TerrainChunk.CreateMesh(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo})"/></param>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainChunk.VisualChunk">
            <summary>
            A visual chunk is a chunk of a <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/> greater than zero. These chunks are purely visual and
            are not copied back to the CPU. This is because accurate map sampling is impossible with missing information, 
            therefore, in terms of the interactable game-environment they do not exist.
            
            Visual chunks are divided into two logical types, normal and fake chunks. Normal visual chunks have cached map data on the GPU
            which allows them to contain atmospheric effects, and look in neighboring chunks to generate their mesh. Fake visual chunks are farther
            away from the viewer and do not have cached map data anywhere, their map data is generated on the fly to create a mesh and discarded immediately. 
            Fake chunks hence only reflect a chunk's default map data while normal chunks are capable of displaying dirty map information loaded from storage.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VisualChunk.#ctor(UnityEngine.Transform,Unity.Mathematics.int3,System.Int32,System.UInt32)">
            <summary> Creates a new visual chunk with the the given origin and size. <seealso cref="T:Arterra.Core.Terrain.TerrainChunk"/> </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VisualChunk.Update">
            <summary> Based upon the chunk's status, enqueues generation tasks to the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.RequestQueue"/>
            to reflect the flags. The status is updated accordingly after the tasks are enqueued/finished. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VisualChunk.ReleaseChunk">
            <summary> Normal visual chunks reference directly their GPU-side map information inside the <see cref="T:Arterra.Core.Storage.GPUMapManager"/>, and are subscribed so 
            that it isn't released while the chunk is holding it. On release, it's necessary to unsubscribe to allow the map to be released </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VisualChunk.GetSurface">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VisualChunk.PlanStructures(System.Action)">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VisualChunk.ReadMapData(System.Action)">
            <summary>
            A chunk is a normal visual chunk if it can be registered in the <see cref="T:Arterra.Core.Storage.GPUMapManager"/>. Otherwise, it is a fake visual chunk.
            For a fake visual chunk, ReadMapData does nothing because it will be lost immediately after generation as it is not cached anywhere.
            For a normal visual chunk, ReadMapData generates the default map information and registeres it into the <see cref="T:Arterra.Core.Storage.GPUMapManager"/>, 
            then it reads any dirty maps from storage and replaces the default map information within the <see cref="T:Arterra.Core.Storage.GPUMapManager"/>'s dictionary
            with the dirty map information.
            </summary> <param name="callback"><see cref="M:Arterra.Core.Terrain.TerrainChunk.ReadMapData(System.Action)"/></param>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainChunk.VisualChunk.CreateMesh(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo})">
            <summary>
            A visual chunk is fake if it does not have any cached information in the <see cref="T:Arterra.Core.Storage.GPUMapManager"/>.
            If it is a fake visual chunk, it will generate the default map information and create the mesh.
            If it is a normal visual chunk, it will create the mesh using the cached map information in the <see cref="T:Arterra.Core.Storage.GPUMapManager"/>.
            </summary> <param name="UpdateCallback"><see cref="M:Arterra.Core.Terrain.TerrainChunk.CreateMesh(System.Action{Arterra.Core.Terrain.Readback.ReadbackTask{Arterra.Core.Terrain.Readback.IVertFormat.TVert}.SharedMeshInfo})"/></param>
        </member>
        <member name="T:Arterra.Core.Terrain.IOctreeChunk">
            <summary>A generic interface all chunks managed by the <see cref="T:Arterra.Core.Terrain.Octree`1"/>
            system must fulfill. </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.IOctreeChunk.Active">
            <summary> Whether or not the chunk is active and recieving updates</summary>
        </member>
        <member name="M:Arterra.Core.Terrain.IOctreeChunk.Destroy">
            <summary>An absolute command to destroy the chunk and 
            release all associated resources. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.IOctreeChunk.Kill">
            <summary>An indication to the chunk that it is in the process
            of being replaced and should no longer recieve updates. </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.Octree`1">
            <summary>
            A struct defining an octree, a tree in which every internal node has exactly 8 children and
            each parent node contains, in 3D space, all of its children such that the root contains the 
            entire tree. The Octree is the primary structure used for LoD terrain generation and management.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.nodes">
            <summary> An array containing the octree. Each node may point to other nodes in a logical octree structure
            but it does not remember which nodes represent roots, branches, or terrain chunks. It is the job of the caller
            to remember what they added and removed. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.chunks">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.MaxDepth">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.MinChunkSize">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an octree with the specified settings--depth, balance factor, and chunk radius.
            </summary>
            <param name="depth">The maximum depth of the octree</param>
            <param name="minChunkSize"> The size in grid space of the smallest chunk(depth = 0) handled by the octree, see <see cref="!:Quality.Terrain.mapChunkSize"/> for more info. </param>
            <param name="numChunks"> The maximum amount of leaf chunks that can be held by the octree. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.IsBalanced(Arterra.Core.Terrain.Octree{`0}.Node@)">
            <summary>
            Determines whether an octree node is balanced based on its current size
            and distance from the viewer. A node is balanced if it obeys the balance factor
            of the tree; if it is  1:(<see cref="!:Quality.Terrain.Balance">Balance</see> + 1) balanced.
            </summary>
            <param name="node">The octree node whose current state is tested to be balanced</param>
            <returns>Whether or not the node is balanced</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.AddTerrainChunk(System.UInt32)">
            <summary>Creates a real instance of the chunk type managed by this octree,
            associated to the given octree node.</summary>
            <param name="octreeIndex">The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the node 
            associated with the newly created chunk</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.RemapRoot(System.UInt32)">
            <summary>A callback to address the situation when a root 
            node is no longer balanced(<see cref="M:Arterra.Core.Terrain.Octree`1.IsBalanced(Arterra.Core.Terrain.Octree{`0}.Node@)"/>) </summary>
            <param name="octreeNode">The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the
            root node no longer balanced</param>
            <returns>Whether or not to keep the current node.</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.Initialize(System.Int32,Unity.Mathematics.int3)">
            <summary> Populates the initial octree. </summary>
            <param name="numRtNodes">The number of root nodes
            to create. Multiple root nodes can enable seemless
            transitions around a target. </param>
            <param name="center">The center of the octree in grid space</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.Release">
            <summary> Calls release on all chunks managed by the octree
            and clears the tree structure. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ForEachChunk(System.Action{`0})">
            <summary> Executes a function for every real 
            leaf chunk in the octree. </summary>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ForEachActiveChunk(System.Action{`0})">
            <summary> Executes a function for all <see cref="P:Arterra.Core.Terrain.TerrainChunk.Active"/> 
            real leaf chunk in the octree. </summary>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.GetAllChunks">
            <summary> Retrieves all leaf chunks (including zombies)
            currently held by the octree </summary>
            <returns>An array containing all leaf chunks</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.GetAllActiveChunks">
            <summary> Retrieves all active leaf chunks
            currently held by the octree </summary>
            <returns>An array containing all leaf chunks</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.BuildTree(System.UInt32)">
            <summary>Subdivides the octree node to create a fully balanced subtree. </summary>
            <param name="root"></param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.SubdivideChunk(System.UInt32)">
            <summary>
            Subdivides a chunk if it can be subdivided, otherwise does nothing.
            A chunk can be subdivided if it is unbalanced and not of the minimal chunk size.
            Subdividing a chunk will recursively subdivide it until all its children are balanced.
            </summary>
            <remarks>
            Subdividing a chunk causes the chunk to become a zombie. If it is already a zombie
            than it reaps all zombies in its local subtree before subdividing.
            </remarks>
            <param name="leafIndex">
            The index of the octree node within the
            <see cref="F:Arterra.Core.Terrain.Octree`1.nodes">octree</see> structure. 
            </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.MergeSiblings(System.UInt32)">
            <summary>
            Merges a chunk with its siblings if it can be merged, otherwise does nothing.
            A chunk can be merged if its parent is balanced and all its siblings are leaf chunks.
            Recursively merges all siblings until it reaches a parent that is unbalanced.
            If it reaches the root, it will remap the root to wrap around the viewer.
            </summary>
            <remarks>
            Merging a chunk causes the chunk to become a zombie. If it is already a zombie
            than it reaps all zombies in its local subtree before merging.
            </remarks>
            <param name="leaf">
            The index of the octree node within the
            <see cref="F:Arterra.Core.Terrain.Octree`1.nodes">octree</see> structure.
            </param>
            <returns>
            Whether or not the requested chunk was <b>unable</b> to be
            merged. Used for internal recursion purposes.
            </returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ReapChunk(System.UInt32)">
            <summary>
            Reaps a chunk's dependencies(zombies) from the octree. Normally, terrain chunks are only defined on
            the leaf nodes of the octree. However when a new chunk is created but is not completed(does not possess a mesh), 
            the original chunk still lives as a zombie. In doing so, the old chunk may be on a branch node whereby the new 
            chunk is its child and exists on its subtree, or conversely the old chunk is a leaf node and the newly created
            chunk is its parent's branch. This old chunk is a dependency of the new chunk which calls this function to reap 
            the old chunk when it does complete.
            </summary>
            <remarks>
            Calling reap chunk on a chunk will reap(destroy) all nodes within its subtree. Logically, if a chunk is complete,
            it should reside on a leaf-node and can destroy its subtree to achieve this. If a parent chunk is a dependency, it will
            only be reaped when all of its children call reap chunk. 
            
            Additionally, if a chunk becomes a zombie, it should reap all its dependencies even if it is not complete. This may 
            cause a gap to appear in the terrain if regenerating very quickly, but is necessary to ensure the integrity of the octree. 
            </remarks>
            <param name="octreeIndex">
            The index of the octree node within the
            <see cref="F:Arterra.Core.Terrain.Octree`1.nodes">octree</see> structure whose
            dependencies will be reaped(destroyed). 
            </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.DestroySubtree(System.UInt32)">
            <summary>Destroys all chunks and associated resources in a
            specific subtree of the octree. </summary>
            <param name="octreeIndex">The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the
            node whose siblings, descendants, and siblings' descendants will be released. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.FloorCCoord(Unity.Mathematics.int3,System.Int32)">
            <summary>
            Converts a grid coordinates into the chunk coordinate relative to a specific chunk size. Conversion is done
            with explicitly only integer mathematics and thus is not subject to floating point errors.
            </summary>
            <remarks>
            One can obtain the chunk coordinate for a specific depth by setting <paramref name="chunkSize"/> to
            <see cref="!:Quality.Terrain.mapChunkSize"/> * (2^<see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/>)>:
            </remarks>
            <param name="GCoord">The position whose relative chunk coordinate is sampled</param>
            <param name="chunkSize">The size of chunk the outputted chunk coordinate is scaled to.</param>
            <returns>The chunk coordinate of the point relative to <paramref name="chunkSize"/></returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.GetDepthOfDistance(System.Single,System.Int32,System.UInt32)">
            <summary> Returns the depth of the chunk containing a position at a 
            given distance from the viewer. </summary>
            <param name="chunkDist">The distance in chunk space from the viewer</param>
            <param name="balanceF">The balance factor of the octree(<paramref name="balanceF"/> + 1 : 1))</param>
            <param name="chunksRadius">The chunk radius around the viewer of layer depth = 0</param>
            <returns>The depth of the chunk at this distance</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.AddNode(Arterra.Core.Terrain.Octree{`0}.Node)">
            <summary>
            Inserts a node into the octree. The node is placed into the first
            open entry within the octree. This does not connect it to its parent, children, siblings,
            or mark it as a leaf node. It is expected that <paramref name="octree"/> will already
            be initialized(connected) by the caller.
            </summary>
            <param name="octree">The new node that is placed within the octree</param>
            <returns>The index within the octree that the node is inserted into</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.RemoveNode(System.UInt32)">
            <summary>
            Removes a node from the octree, freeing space for new nodes to be inserted.
            The information is not cleared but should not be read from.
            </summary>
            <param name="index">
            The index within the octree of the node that should be removed. It is the caller's
            responsibility to only call this on allocated nodes. 
            </param>
        </member>
        <member name="T:Arterra.Core.Terrain.Octree`1.Node">
            <summary>
            An octree node that contains information on its orientation, hierarchical relation to 
            other chunks as well as the index of its terrain chunk if it has one.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.Node.origin">
            <summary>
            The origin in grid space of the chunk. This is the coordinate
            of the bottom-left corner of the bounds of the chunk.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.Node.size">
            <summary>
            The size of the chunk in grid space. This is equivalent to 
            <see cref="!:Quality.Terrain.mapChunkSize"/> * 
            (2^<see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/>).
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.Node.child">
            <summary>
            The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the first child of the node if it
            is not a leaf node. If it is a leaf node, this value is 0.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.Node.sibling">
            <summary>
            The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the sibling of the node. Its sibling
            will reference a different sibling forming a circular linked list of length 8.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.Node.parent">
            <summary>
            The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the parent of the node. If the node is a root
            of the octree, this value is 0.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Octree`1.Node.IsLeaf">
            <summary>
            Whether or not the node is a leaf node. A leaf node is a node that does not have any children,
            or when <see cref="F:Arterra.Core.Terrain.Octree`1.Node.child"/> is 0.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.Node.ClearChunk">
            <summary>
            Clears the chunk data of the node. The default state is that
            HasChunk is false and IsComplete is false.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Octree`1.Node.HasChunk">
            <summary>
            Whether or not the node has a chunk associated with it.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Octree`1.Node.IsComplete">
            <summary>
            If it has a chunk, whether or not the chunk is marked as 
            complete. A chunk is marked as complete if it has attempted to
            generate a mesh.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.Octree`1.Node.Chunk">
            <summary>
            The index of the chunk within the <see cref="T:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1">chunk list</see> of the octree.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.Node.GetMaxDist(Unity.Mathematics.int3)">
            <summary>
            Obtains the maximum component distance of <paramref name="GCoord"/> to the bounds of the chunk. The 
            max component distance is the maximum of the distances along each dimension. If the point
            is within the bounds of the chunk, the max distance is 0. 
            </summary>
            <param name="GCoord">The coordinate of the point whose max distance from the chunk is queried</param>
            <returns>The maximum component distance from the chunk's bounds to the point</returns>
        </member>
        <member name="T:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.nodes">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.length">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.capacity">
            <exclude />
        </member>
        <member name="P:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.head">
            <exclude />
        </member>
        <member name="P:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.free">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.#ctor(System.UInt32)">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Release">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Enqueue(`1)">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.RemoveNode(System.UInt32)">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Head">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Next(System.UInt32)">
            <exclude />
        </member>
        <member name="M:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.GetCoord(System.Func{`1,System.Boolean})">
            <exclude />
        </member>
        <member name="T:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Node">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Node.next">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Node.prev">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.Octree`1.ConstrainedLL`1.Node.Value">
            <exclude />
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainUpdate">
            <summary>
            Terrain Update is a static system that handles updates to map entries within <see cref="T:Arterra.Core.Storage.CPUMapManager"/>. Whenever a
            map entry is modified(e.g. by a player, through an update, etc.) it should be updated in case it has a specific behavior.
            Materials(map entries) must all define a <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.PropogateMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)"/> and
            <see cref="M:Arterra.Configuration.Generation.Material.MaterialData.RandomMaterialUpdate(Unity.Mathematics.int3,Unity.Mathematics.Random)"/> method that will be called when the map entry
            is updated.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainUpdate.Initialize">
            <summary>
            Initializes the Terrain Update System. Must be called before any updates are added.
            Allocates memory for the update system, which is fixed and cannot be resized.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainUpdate.AddUpdate(Unity.Mathematics.int3)">
            <summary>
            Adds a map entry to the update queue. The map entry will be updated in the next fixed update if there
            is enough space for it, otherwise it is discarded. If the map entry already exists in the queue, it is ignored.
            </summary> <param name="GCoord">The grid space coordinate of the map entry. The caller should only call this with coordinates present within <see cref="T:Arterra.Core.Storage.CPUMapManager"/></param>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainUpdate.Manager">
            <summary>
            Update Task that is tied with the <see cref="F:Arterra.Core.Terrain.OctreeTerrain.MainFixedUpdateTasks"/>. 
            It is responsible for updating the map entries within Unity's fixed update loop.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.TerrainUpdate.Manager.Active">
            <exclude />
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainUpdate.Manager.dispatched">
            <summary> Whether or not the job is currently running; whether the job
            currently has threads in the thread pool executing it. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainUpdate.Manager.#ctor">
            <summary>  Default constructor sets the manager to active. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainUpdate.Manager.Complete">
            <summary> Completes the asyncronous Job Operation. Blocks main thread
            until the job has completed. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainUpdate.Manager.Update(UnityEngine.MonoBehaviour)">
            <summary>
            Updates the map entries in the update queue. 
            The map entries are updated in the order they were added.
            </summary> <param name="mono"><see cref="M:IUpdateSubscriber.Update(UnityEngine.MonoBehaviour)"/> </param>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainUpdate.Manager.PropogatedUpdates">
            <summary> The Job that is responsible for processing in parallel
            all points whose updates have been propogated. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainUpdate.Manager.PropogatedUpdates.seed">
            <summary>
            Random values referencable by materials; Materials are processed in parallel,
            thus this isn't thread safe, but that adds to the randomness.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainUpdate.Manager.PropogatedUpdates.Execute(System.Int32)">
            <summary> Executes the point update in parallel. </summary>
            <param name="index">The index of the job-thread executing the task</param>
        </member>
        <member name="T:Arterra.Core.Terrain.TerrainUpdate.Manager.RandomUpdates">
            <summary> The Job responsible for processing random updates in parallel. 
            Random updates are performed on a per-chunk basis, and each chunk
            is processed in its own job thread. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainUpdate.Manager.RandomUpdates.seed">
            <summary> Random values referencable by materials; Materials are processed in parallel,
            thus this isn't thread safe, but that adds to the randomness. /// </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainUpdate.Manager.RandomUpdates.numUpdatesPerChunk">
            <summary> The number of random updates to perform per one chunk. See <see cref="F:Arterra.Configuration.Intrinsic.TerrainUpdation.RandomUpdatesPerChunk"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainUpdate.Manager.RandomUpdates.mapChunkSize">
            <summary> The size of a map chunk, the number of points per axis in a map chunk. </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.TerrainUpdate.Manager.RandomUpdates.numPointsChunk">
            <summary> The amount of points total in a map chunk, equivalent to <see cref="F:Arterra.Core.Terrain.TerrainUpdate.Manager.RandomUpdates.mapChunkSize"/>^3. </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.TerrainUpdate.Manager.RandomUpdates.Execute(System.Int32)">
            <summary> Executes the random update in parallel. Each job thread is responsible for
            processing a single chunk of the map. The chunk is identified by its index in the
            <see cref="F:Arterra.Core.Storage.CPUMapManager.AddressDict"/> dictionary. </summary>
            <param name="index"></param>
        </member>
        <member name="T:Arterra.Core.Terrain.OctreeTerrain">
            <summary>
            Octree Terrain is a singleton class that drives all generation and generation
            based events in the game. It is responsible for scheduling when generation 
            tasks are executed and identifying when the current generation needs to update.
            
            System tasks connected to the games frame-by-frame update loop should hook into either
            MainLoopUpdateTasks, MainLateUpdateTasks, or MainFixedUpdateTasks. This is so that
            these static systems can hook into the update loop without needing to be a MonoBehaviour.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.taskLoadTable">
            <summary>
            The load for each task as ordered in <see cref="F:Utils.priorities.planning"/>.
            Each task's load is cumilated until the frame's load is exceeded at which point generation stops.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.MainLoopUpdateTasks">
            <summary>
            A queue containing subscribed tasks that are executed
            once every update loop. The update loop occurs
            once every frame before the late update loop.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.MainLateUpdateTasks">
            <summary>
            A queue containing subscribed tasks that are executed
            once every late update loop. The late update loop
            occurs once every frame after the update loop.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.MainFixedUpdateTasks">
            <summary>
            A queue containing subscribed tasks that are executed
            once every fixed update loop. The fixed update loop is
            akin to a game-tick and is frame-independent. 
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.MainCoroutines">
            <summary>
            A queue containing coroutines which will be synchronized and updated
            by Unity's main update loop. Unity does not allow injection into its synchronization
            outside monobehavior, so OctreeTerrain has to manage this.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.RequestQueue">
            <summary>
            A queue of generation actions which are processed
            sequentially and discarded once they are called. All tasks 
            are channeled through this queue to manage the resource load
            and facilitate expensive operations. 
            </summary>
            <remarks>
            The concurrent queue may also be used to reinject tasks
            on different threads back into the main thread.
            </remarks>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.ActionReinjectionQueue">
            <summary> A queue to reinjects events into the main thread
            not directly tied to a specific chunk.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.octree">
            <summary> The root octree structure responsible for dividing the world into
            <see cref="T:Arterra.Core.Terrain.TerrainChunk"/>s in a manner according to the rules defined by
            <see cref="T:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree"/> </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.ViewPosCS">
            <summary>
            The last tracked position of the viewer in chunk space.
            This value is only updated when the viewer's position
            exceeds the viewDistUpdate threshold.
            </summary>
        </member>
        <member name="P:Arterra.Core.Terrain.OctreeTerrain.ViewPosGS">
            <summary>
            The last tracked position of the viewer in grid space.
            This value is only updated when the viewer's position
            exceeds the viewDistUpdate threshold.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.viewer">
            <summary> 
            The transform of the viewer around which
            generation(the octree) is centered.
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.OctreeTerrain.GenTask">
            <summary>
            A struct that defines a generation process. GenTasks
            are buffered into <see cref="F:Arterra.Core.Terrain.OctreeTerrain.RequestQueue"/> and processed sequentially.
            GenTasks are called from main thread and allow for reinjection of async tasks.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.GenTask.task">
            <summary> The action that is executed when the task is processed.</summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.GenTask.id">
            <summary> 
            The priority of the task as defined in <see cref="F:Utils.priorities.planning"/>. 
            Used to identify the load and loading message of the task.
            </summary>
        </member>
        <member name="F:Arterra.Core.Terrain.OctreeTerrain.GenTask.chunk">
            <summary>
            The chunk that the task is associated with. If the chunk is destroyed,
            deactivated, or null, the task will be ignored and discarded when answering.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.GenTask.#ctor(System.Action,System.Int32,Arterra.Core.Terrain.IOctreeChunk)">
            <summary>
            Constructs a new GenTask with the given action, id, and chunk.
            </summary>
        </member>
        <member name="T:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree">
            <summary>
            An <see cref="T:Arterra.Core.Terrain.Octree`1"/> that infinitely tiles <see cref="T:Arterra.Core.Terrain.TerrainChunk"/>s and is balanced using an 
            explicit balancing factor (e.g. 1:2, 1:3) to determine different depth regions.
            See <see cref="T:Arterra.Core.Terrain.Octree`1"/> for more information.
            </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Creates an octree with the specified settings--depth, balance factor, and chunk radius. </summary>
            <param name="depth">The maximum depth of the octree</param>
            <param name="balanceF">The balance factor of the octree. See <see cref="!:Quality.Terrain.Balance"/> for more info.</param>
            <param name="chunksRadius">The minimum radius of the smallest chunks within the octree. See <see cref="!:Quality.Terrain.MinChunkRadius"/> for more info.</param>
            <param name="minChunkSize"> The size in grid space of the smallest chunk(depth = 0) handled by the octree, see <see cref="!:Quality.Terrain.mapChunkSize"/> for more info. </param>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.Initialize">
            <summary> Populates the initial octree with root nodes (may not be 8) </summary>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetMaxNodes(System.Int32,System.Int32,System.Int32)">
            <summary> Gets the maximum amount of octree nodes in an octree of a given depth, balance factor, and chunk radius.
            This is calculated by summing the maximum amount of nodes in each layer from 0 to <paramref name="depth"/>.
            <seealso cref="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetAxisChunksDepth(System.Int32,System.Int32,System.UInt32)"/>. </summary>
            <param name="depth">The maximum depth of the octree</param>
            <param name="balanceF">The balance factor of the octree(<paramref name="balanceF"/> + 1 : 1))</param>
            <param name="chunksRadius">The chunk radius around the viewer of layer <paramref name="depth"/> = 0</param>
            <returns>The maximum number of nodes in the given octree settings</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetAxisChunksDepth(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the diameter of an octree defined by balanceFactor, and chunkRadius for nodes at a specified depth. 
            This is calculated by determining the maximum radius of chunks at the given depth which can be 
            balanced given any viewer position. 
            </summary>
            <remarks>
            Since the octree is centered around a viewer, nodes of a certain depth form a cubic shell around the viewer.
            The diameter thus is the side length of this cube. 
            </remarks>
            <param name="depth">The specific depth of the given octree whose maximum node diameter is queried</param>
            <param name="balanceF">The balance factor of the octree(<paramref name="balanceF"/> + 1 : 1)</param>
            <param name="chunksRadius">The chunk radius around the viewer of layer <paramref name="depth"/> = 0</param>
            <returns>
            The maximum diameter in terms of the amount of nodes of the specified <paramref name="depth"/> that can exist
            given the octree's settings.
            </returns>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.IsBalanced(Arterra.Core.Terrain.Octree{Arterra.Core.Terrain.TerrainChunk}.Node@)">
            <summary>
            Determines whether an octree node is balanced based on its current size
            and distance from the viewer. A node is balanced if it obeys the balance factor
            of the tree; if it is  1:(<see cref="!:Quality.Terrain.Balance">Balance</see> + 1) balanced.
            </summary>
            <param name="node">The octree node whose current state is tested to be balanced</param>
            <returns>Whether or not the node is balanced</returns>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.AddTerrainChunk(System.UInt32)">
            <summary> Associates a <see cref="T:Arterra.Core.Terrain.TerrainChunk"/> to the given octree node.
            See <see cref="M:Arterra.Core.Terrain.Octree`1.AddTerrainChunk(System.UInt32)"/> for more info. </summary>
            <param name="octreeIndex">The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the node whose chunk is being created.</param>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.RemapRoot(System.UInt32)">
            <summary> Remaps the root node of the <see cref="T:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree"/> to
            the closest exclusive(non-overlapping) position around the viewer.
            See <see cref="M:Arterra.Core.Terrain.Octree`1.RemapRoot(System.UInt32)"/> for more info. </summary>
            <param name="octreeNode">The index within <see cref="F:Arterra.Core.Terrain.Octree`1.nodes"/> of the 
            root node being remapped</param>
            <returns>Whether the chunk was remapped or not. A chunk is not remapped
            if it currently occupies the closest exclusive position. </returns>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetNeighborDepths(System.UInt32)">
            <summary>
            Determines the positive difference in <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth">depth</see> between a chunk and its 6 neighbors.
            If the parent is of a smaller depth(i.e. smaller) than the current chunk, 0 will be returned as there would be multiple nodes
            that border that side of the chunk. This information is not found through traversal of the octree, but mathematical
            evaluation off the current state of the game--the real neighbors may be at a different depth if not properly updated.
            </summary> <param name="index">The index of the octree node within the
            <see cref="F:Arterra.Core.Terrain.OctreeTerrain.octree">octree</see> structure. </param>
            <returns>A bitmask of 3 bytes describing the positive depth difference between the chunk and its neighbor in the
            <c>x, y, z</c> directions. The highest bit of every byte is set if describing the positive face</returns>
            <remarks>The difference in depth is found using progressive analysis of whether neighbor chunks of 
            larger and larger depths would be <see cref="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.IsBalanced(Arterra.Core.Terrain.Octree{Arterra.Core.Terrain.TerrainChunk}.Node@)">balanced</see>. There may be a way to find this 
            mathematically instead.</remarks>
        </member>
        <member name="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.IsBordering(System.Int32)">
            <summary>
            Determines whether an octree node is bordering a chunk of a larger size.
            This is determined by checking if its neighbor farthest from the viewer is
            balanced if it were of a larger size than the current chunk.
            </summary> <param name="index"> The index of the octree node within the
            <see cref="F:Arterra.Core.Terrain.OctreeTerrain.octree">octree</see> structure.  </param>
            <returns>Whether or not the node is bordering a larger chunk</returns>
        </member>
        <member name="T:Arterra.Core.Storage.GPUMapManager">
            <summary> A static centralized gateway for all CPU-side operations to access or attach resources capable of accessing
            map-related information stored on the GPU. Responsible for organizing managers which maintain the organization
            and integrity of structures facilitating map lookup on the GPU. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.GPUMapManager.numChunksRadius">
            <summary> How far from the user processes on the GPU can lookup information about the world. The radius 
            in chunk space of the perfect hash-map which enables random access lookups of map information on the GPU.  </summary>
        </member>
        <member name="F:Arterra.Core.Storage.GPUMapManager.initialized">
            <summary> Whether <see cref="T:Arterra.Core.Storage.GPUMapManager"/> has been initialized and calls to access GPU map information can be granted.
            Whether <see cref="M:Arterra.Core.Storage.GPUMapManager.Initialize"/> has been called since the start of the world instance. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.Initialize">
            <summary> Initializes <see cref="T:Arterra.Core.Storage.GPUMapManager"/> to manage storage and access of
            GPU-side map information based off the settings of the current world. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.Release">
            <summary> Releases all resources used by <see cref="T:Arterra.Core.Storage.GPUMapManager"/> to manage and track
            map information on the GPU. Call this once on cleanup when the world is unloaded  </summary>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkVisual(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)">
            <summary>
            Registers a visual chunk by copying its map information from working memory to long-term GPU memory,
            updating the lookup structure(s) and garbage collecting(permanently) any map information made unaccessible.
            The hashmap structure is scaled to the size of a real chunk (chunk space) and thus a visual chunk
            <see cref="T:Arterra.Core.Terrain.TerrainChunk.VisualChunk"/> overlaps multiple entries in the hasmap and will require writing
            to multiple entires. Thus this operation has a time complexity of O((2^depth)^3).
            </summary>
            <param name="oCCoord">The coordinate of the origin(lowest coordinate) of the visual chunk in chunk space. </param>
            <param name="depth">The <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth">depth</see> of the chunk; indicates the size of the chunk. </param>
            <param name="mapData">The working buffer currently containing the map information of the chunk.</param>
            <param name="rdOff">The offset within <i>mapData</i> where the map information of the chunk begins.</param>
            <returns>An integer representing a handle to the chunk given by the internal chunk reference manager  
            capable of being used to directly query the stored map information. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkReal(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)">
            <summary> Registers a real chunk by copying its map information from working memory to long-term GPU memory,
            updating the lookup structure(s) and garbage collecting(permanently) any map information made unaccessible.
            The hashmap structure is scaled to the size of a real chunk (chunk space) and thus this will only replace
            and garbage collect at most one previously tracked chunk. </summary>
            <param name="oCCoord">The coordinate of the real chunk in chunk space. </param>
            <param name="depth">The <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth">depth</see> of the chunk. This must be 0. </param>
            <param name="mapData">The working buffer currently containing the map information of the chunk.</param>
            <param name="rdOff">The offset within <i>mapData</i> where the map information of the chunk begins.</param>
            <returns>An integer representing a handle to the chunk given by the internal chunk reference manager  
            capable of being used to directly query the stored map information. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.GetHandle(System.Int32)">
            <summary> Obtains the reference information associated with this handle. </summary>
            <param name="handleAddress">The handle returned from <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkReal(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/> or <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkVisual(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/></param>
            <returns>Two integers: 1. the address within <see cref="P:Arterra.Core.Storage.GPUMapManager.DirectAddress">the direct unmanaged memory 
            address buffer</see> of the address within <see cref="P:Arterra.Core.Storage.GPUMapManager.Storage"/> of the stored chunk information, and
            2. the amount of references held by either the hasmap or <see cref="M:Arterra.Core.Storage.GPUMapManager.SubscribeHandle(System.UInt32)">manually</see>.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.SubscribeHandle(System.UInt32)">
            <summary>Prevents the stored map information from being garbage collected even if other chunks completely
            replace it in the hashmap making it unaccessible. Increments the amount of references held to the 
            map information pointed to by <i>handleAddress</i> by one. </summary>
            <param name="handleAddress">The handle returned from <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkReal(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/> or <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkVisual(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/></param>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.UnsubscribeHandle(System.Int32)">
            <summary> Returns one subscription allowing the stored map information to be garbage collected again if it is completely 
            replaced in the lookup hashmap and all subscriptions are returned. Do not call this function without first calling
            <see cref="M:Arterra.Core.Storage.GPUMapManager.SubscribeHandle(System.UInt32)"/> or severe undefined behavior may occur. This operation may trigger garbage collection
            of the map information if it is the last reference held. Specifically, decrements the amount of references held to the 
            map information pointed to by <i>handleAddress</i> by one. </summary>
            <param name="handleAddress">The handle returned from <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkReal(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/> or <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkVisual(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/></param>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.IsChunkRegisterable(Unity.Mathematics.int3,System.Int32)">
            <summary> Whether or not the chunk will be stored and tracked by <see cref="T:Arterra.Core.Storage.GPUMapManager"/> if 
            <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkVisual(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/> were to be called on it. Chunks that are too far away from the viewer
            will not be tracked. </summary>
            <param name="oCCoord">The coordinate of the origin(lowest coordinate) of the visual chunk in chunk space.</param>
            <param name="depth">The <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth">depth</see> of the chunk; indicates the size of the chunk.</param>
            <returns></returns>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.HashCoord(Unity.Mathematics.int3)">
            <summary> Gets the hashed index of the given chunk space coordinate within the GPU lookup hashmap.
            This method is a perfect has in that a unique index is given for all coordinates 
            within <see cref="F:Arterra.Core.Storage.GPUMapManager.numChunksRadius"/> distance of the coordinate. </summary>
            <param name="CCoord">A coordinate in chunk space</param>
            <returns>The associated hash index</returns>
        </member>
        <member name="P:Arterra.Core.Storage.GPUMapManager.Storage">
            <summary> The buffer containing all map information managed and tracked by <see cref="T:Arterra.Core.Storage.GPUMapManager"/>. </summary>
        </member>
        <member name="P:Arterra.Core.Storage.GPUMapManager.Address">
            <summary> The buffer containing the hashmap structure used to facilitate GPU-side map lookup </summary>
        </member>
        <member name="P:Arterra.Core.Storage.GPUMapManager.DirectAddress">
            <summary> The buffer containing the raw unstructured list of addresses to each chunk's map information. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.TranscribeMultiMap(UnityEngine.ComputeBuffer,Unity.Mathematics.int3,System.Int32,System.Int32)">
            <summary> Performs a selective replacing of a stored chunk's map information with sparse chunk information 
            sourced from a working buffer. A stored chunk's MapData will only be replaced if the information from the replacing
            entry in the working buffer <see cref="P:Arterra.Core.Storage.MapData.isDirty">is dirty </see>, otherwise it is ignored. 
            The caller should ensure that <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkVisual(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/> or <see cref="M:Arterra.Core.Storage.GPUMapManager.RegisterChunkReal(Unity.Mathematics.int3,System.Int32,UnityEngine.ComputeBuffer,System.Int32)"/> has been called 
            on the provide chunk coordinate(<i>CCoord</i>) beforehand such that there exists a stored chunk map. </summary>
            <param name="mapData">The working buffer currently containing the new replacing sparse map information.</param>
            <param name="CCoord">The coordinate of the origin(lowest coordinate) of the chunk in chunk space; determins which 
            stored chunk to replace.</param>
            <param name="depth">The <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth">depth</see> of the chunk; this must match the depth given when
            registering the chunk</param>
            <param name="rStart">The offset within <i>mapData</i> where the sparse map information of the chunk begins.</param>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.SimplifyChunk(Unity.Mathematics.int3,System.Int32)">
            <summary> Shrinks the size of a stored chunk's map by 
            selectively downsampling the existing stored chunk's map. </summary>
            <param name="CCoord">The coordinate of the origin(lowest coordinate) of the chunk in 
            chunk space; determins which stored chunk to replace.</param>
            <param name="depth">The <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth">depth</see> of the new chunk; determines
            the new downsampled size of the map. Caller must guarantee that this is no less than the previous size
            of the chunk. </param>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.SetDensitySampleData(UnityEngine.ComputeShader)">
            <summary> Attaches all resources necessary to sample map information through
            the <see cref="P:Arterra.Core.Storage.GPUMapManager.Address">lookup constructs</see> managed by 
            <see cref="T:Arterra.Core.Storage.GPUMapManager"/> to a compute shader. </summary>
            <param name="shader">The compute shader requesting map information. Caller 
            should ensure this shader is able to recieve the bindings attached here. </param>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.SetDensitySampleData(UnityEngine.Material)">
            <summary> Attaches all resources necessary to sample map information through
            the <see cref="P:Arterra.Core.Storage.GPUMapManager.Address">lookup constructs</see> managed by 
            <see cref="T:Arterra.Core.Storage.GPUMapManager"/> to a material. </summary>
            <param name="material">The material requesting map information. Caller 
            should ensure this material is able to recieve the bindings attached here. </param>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.SetCCoordHash(UnityEngine.ComputeShader)">
            <summary>Attaches metadata allowing a compute shader to utilize the <see cref="P:Arterra.Core.Storage.GPUMapManager.Address">lookup construct</see> to sample map information. </summary>
            <param name="shader">The compute shader requesting map information. Caller 
            should ensure this shader is able to recieve the bindings attached here.</param>
        </member>
        <member name="M:Arterra.Core.Storage.GPUMapManager.SetCCoordHash(UnityEngine.Material)">
            <summary>Attaches metadata allowing a compute shader to utilize the <see cref="P:Arterra.Core.Storage.GPUMapManager.Address">lookup construct</see> to sample map information. </summary>
            <param name="material">The compute shader requesting map information. Caller 
            should ensure this shader is able to recieve the bindings attached here.</param>
        </member>
        <member name="T:Arterra.Core.Storage.Chunk">
            <summary> Manages the access, loading and storage of world-specific data from an external file system location
            to in-game memory. Concurrently, it also defines the structure of the data that is stored in terms of both
            format, encoding, and file-structure within the file system.
            </summary>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.Initialize">
            <summary> Initializes the Chunk Storage Manager. This should be called once at the start of the game.
            Sets up information relavent to file formatting, and the <see cref="T:Arterra.Core.Storage.Chunk.ChunkFinder"/>. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.MinimalInitialze">
            <summary> Initializes the Chunk Storage Manager for minimal chunk I/O operations without complex
            lookup structures. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.SaveEntitiesToJsonAsync(System.Collections.Generic.List{Arterra.Configuration.Generation.Entity.Entity},Unity.Mathematics.int3)">
            <summary>Saves a list of entities associated with a chunk to the file system at the appropriate location.
            Entities associated with a chunk are saved in a compressed json format to the correct location for
            the chunk within the world's file system. See <see cref="F:Arterra.Core.Storage.Chunk.ChunkFinder.entityPath"/> for more information </summary>
            <remarks>The function saves the chunk data with background task to avoid blocking the main thread. </remarks>
            <param name="entities">A list containing all <see cref="T:Arterra.Configuration.Generation.Entity.Entity">Entities</see> associated with the chunk(typically within its bounds). </param>
            <param name="CCoord">The coordinate in chunk space of the Chunk associated with the entities. 
            This information used to identify the location to store the resulting file(s). </param>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.SaveChunkToBinAsync(Arterra.Core.Storage.CPUMapManager.ChunkPtr,Unity.Mathematics.int3)">
            <summary>Saves a chunk's map information to the file system at the appropriate location. 
            The chunk's map information is saved in a multi-resolution compressed binary format
            to the correct location for the chunk within the world's file system(<see cref="F:Arterra.Core.Storage.Chunk.ChunkFinder.chunkPath"/>).  
            See <see cref="T:Arterra.Core.Storage.Chunk.ChunkHeader"/> for information on this format. The function saves the chunk data
            with background task to avoid blocking the main thread. </summary>
            <param name="chunk">A <see cref="T:Arterra.Core.Storage.CPUMapManager.ChunkPtr"/> referencing a COPY of the chunk's map in memory</param>
            <param name="CCoord">The coordinate in chunk space of the Chunk associated with the map 
            information. Used to identify the location to store the resulting file(s). </param>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.ReadVisualChunkMap(Unity.Mathematics.int3,System.Int32)">
            <summary> Reads a virtual(<see cref="T:Arterra.Core.Terrain.TerrainChunk.VisualChunk"/>) chunk's map information from the file system
            and returns it as a linear encoded map. Involves reading multiple files associated with different chunks
            with the appropriate resolution and merging them into a single map for the chunk(which spans the collective region).
            If a chunk is not found, the map is skipped and a bit is set to indicate that the map information is not dirty and 
            should be replaced by any default information. </summary>
            <param name="CCoord">The coordinate of the origin of the chunk in chunk space. Used to determine locations
            of files containing overlapping chunks in the file system</param>
            <param name="depth">The <see cref="F:Arterra.Core.Terrain.TerrainChunk.depth"/> of the visual chunk. Used to determine the size of the chunk, 
            and equivalently how many chunks and which resolution levels to sample. A depth of 0 corresponds to a real chunk. </param>
            <returns>The linearly encoded map information associated with the chunk. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.ReadChunkInfo(Unity.Mathematics.int3)">
            <summary> Reads all information(entity and map) associated with a <see cref="T:Arterra.Core.Terrain.TerrainChunk.RealChunk"> Real Chunk</see> from the file system 
            and returns it as a <see cref="T:Arterra.Core.Storage.Chunk.ReadbackInfo"/>. This includes the map information and the entities associated with the chunk.
            This functionality is not available for visual chunks as entities for visual chunks is not supported. </summary>
            <param name="CCoord">The coordinate in chunk space of the real chunk to be read. Used to locate the
            chunk's information in the file system.</param>
            <returns>The aggregate information associated with the chunk as a <see cref="T:Arterra.Core.Storage.Chunk.ReadbackInfo"/>. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.ReadChunkMap(Unity.Mathematics.int3,System.Int32)">
            <summary>
            Reads just the map information associated with a chunk file at the specified chunk coordinate at a certain
            resolution. Automatically loads and deserializes the map information by recoupling it to the
            current game instance. The size of the read map information is dependant on the 
            sampled resolution controlled by <paramref name="depth"/>. 
            </summary>
            <param name="CCoord">The coordinate in chunk space of the real chunk to be read. </param>
            <param name="depth">The resolution within of the map to be sampled from the file. Chunk files contain multiple
            resolutions of their maps compressed seperately, see <see cref="T:Arterra.Core.Storage.Chunk.ChunkHeader"/> for more information. </param>
            <returns>The linearly encoded map data associated with the requested resolution of the chunk</returns>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.ReadChunkBin(System.String,System.Int32,Arterra.Core.Storage.Chunk.ChunkHeader@)">
            <summary>Reads the map data of a chunk at the given address with a certain depth. </summary>
            <param name="fileAdd">The address of the chunk</param>
            <param name="depth">The detail level of the chunk to read</param>
            <param name="header">The Chunk Header of the read chunk</param>
            <returns>An array of the map data at the given level within the chunk, or null if not found.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.ReadEntityJson(System.String)">
            <summary>
            Reads the entity information associated with a chunk file at the specified address.
            Loads and deserializes the entity information by recoupling it to the current 
            game instance.
            </summary>
            <param name="fileAdd">The path of the entity file in the file system to be read.  Caller should ensure a 
            properly formatted entity file exists at this location. </param>
            <returns>The list containing all entities associated with the chunk.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.TryFindSavedMapChunk(Unity.Mathematics.int3@)">
            <summary> If the world has a saved map chunk, finds any saved map chunk and returns
            the coordinate of the chunk. Otherwise returns false. </summary>
            <param name="CCoord">The coordinate of a saved map chunk</param>
            <returns>Whether or not a map chunk is saved for this world. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.TryFindSavedEntityChunk(Unity.Mathematics.int3@)">
            <summary> If the world has a saved entity chunk, finds any saved entity chunk and returns
            the coordinate of the chunk. Otherwise returns false. </summary>
            <param name="CCoord">The coordinate of a saved entity chunk</param>
            <returns>Whether or not a entity chunk is saved for this world. </returns>
        </member>
        <member name="T:Arterra.Core.Storage.Chunk.ChunkHeader">
            <summary> A struct representing the header of a chunk's map information file. 
            Map information is stored in a multi-resolution compressed binary format. This format is divided in the following way:
            - 4Byte-Int(Uncompressed): The exact size of the compressed header in bytes 
            - Header(Compressed): The current object 
            - Map Data(Compressed): The map data of the chunk, compressed seperately by resolution and stored sequentially starting with the lowest resolution.
            The header contains the following two types of information: RegisterNames and ResolutionOffsets </summary>
        </member>
        <member name="F:Arterra.Core.Storage.Chunk.ChunkHeader.RegisterNames">
            <summary>A list of the names of all unique materials used in the chunk. This is used to 
            decouple the chunk's materials from the current game-version, allowing the same material to be reloaded
            even if the exact index of the material changes.</summary>
        </member>
        <member name="F:Arterra.Core.Storage.Chunk.ChunkHeader.ResolutionOffsets">
            <summary> A list of offsets in bytes from the end of the compressed header to the start
            of each resolution's compressed map data. This can be used to selectively jump to a specific resolution's
            map information and only decompress/process it if other resolutions are not needed. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.Chunk.ChunkHeader.MapEntryMetaData">
            <summary> The map-entry specific meta data and the index identifying its location 
            flattened out in the same format it will be represented when stored. </summary>
        </member>
        <member name="T:Arterra.Core.Storage.Chunk.ReadbackInfo">
            <summary>
            A structure wrapping the maximum information a chunk may associate 
            on the file system. Not all chunks may have every member defined, but 
            every chunk must have at most only these fields populated. Structure
            may be partially filled depending on what information exists/can be found.
            </summary>
        </member>
        <member name="F:Arterra.Core.Storage.Chunk.ReadbackInfo.entities">
            <summary>
            A list of all deserialized <see cref="T:Arterra.Configuration.Generation.Entity.Entity">Entities</see> associated 
            with the chunk. See <see cref="T:Arterra.Configuration.Generation.Entity.Entity"/> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Core.Storage.Chunk.ReadbackInfo.map">
            <summary>
            A list of all deserialized <see cref="T:Arterra.Core.Storage.MapData">MapData</see> associated
            with the chunk. See <see cref="T:Arterra.Core.Storage.MapData"/> for more information.
            </summary>
        </member>
        <member name="F:Arterra.Core.Storage.Chunk.ReadbackInfo.mapMeta">
            <summary> An array of all the deserialized <see cref="F:Arterra.Core.Storage.Chunk.ChunkHeader.MapEntryMetaData"/> entries associated
            with the chunk. See <see cref="F:Arterra.Core.Storage.Chunk.ChunkHeader.MapEntryMetaData"/> for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.ReadbackInfo.#ctor(System.Boolean)">
            <summary>A constructor to initialize a default instance of
            <see cref="T:Arterra.Core.Storage.Chunk.ReadbackInfo"/> which zeroes all fields. </summary>
            <param name="_">A dummy paramater</param>
        </member>
        <member name="M:Arterra.Core.Storage.Chunk.ReadbackInfo.#ctor(Arterra.Core.Storage.MapData[],System.Collections.Generic.KeyValuePair{System.UInt32,System.Object}[],System.Collections.Generic.List{Arterra.Configuration.Generation.Entity.Entity})">
            <summary> Creates an instance of <see cref="T:Arterra.Core.Storage.Chunk.ReadbackInfo"/> to 
            wrap the specified information.</summary>
            <param name="map">The list of deserialized <see cref="F:Arterra.Core.Storage.Chunk.ReadbackInfo.map">MapData</see> to wrap.</param>
            <param name="mapMeta">The list of deserialized MapMetaData to wrap. </param>
            <param name="entities">The list of deserialized <see cref="F:Arterra.Core.Storage.Chunk.ReadbackInfo.entities">entities</see> to wrap.</param>
        </member>
        <member name="T:Arterra.Core.Storage.World">
            <summary>
            Manages the access, loading, and saving of world configuration data as well as
            account specific information shared between worlds. Modification of this architecture
            may invalidate all previous world data and alter access of different worlds.
            </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.META_LOCATION">
            <summary> The relative location in the user's file system of the file containing the "World Selection Meta Data"
            object responsible for identifying <b>all worlds</b> accessible in-game. See <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.BASE_LOCATION">
            <summary> The relative base location of all world-specific data in the user's file system. Each world should be able to source
            its non-meta, instance information completely within this directory, preferable in a sub-directory seperating itself 
            from other worlds. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.WORLD_SELECTION">
            <summary> The MetaData Linked List responsible for locating and identifying all worlds in the system. All worlds maintain an entry in
            this list which is stored in the file at <see cref="F:Arterra.Core.Storage.World.META_LOCATION"/>. The order of elements in this list follows the 
            order in which worlds were last selected by the user; and this is the precise order of worlds shown in World Selection. 
            Modification or deletion of this list from storage can/will result in the (reversible) loss of <b>all</b> world data even if
            the world itself is not deleted. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.DisplayChunkPath">
            <summary> The tail path name of the display chunk image for each world </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.Activate">
            <summary> The primary startup function for loading the user's game information. Loads the <see cref="P:Arterra.Configuration.Config.TEMPLATE"> template </see>
            world configuration(the default world configuration) as well as finding the user's world selection meta data from the file system
            to load the user's last selected world's configuration. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.LoadMeta">
            <summary> Asynchronously loads the world selection meta data object from the corresponding file located
            at <see cref="F:Arterra.Core.Storage.World.META_LOCATION"/> in the file system. If the file does not exist, a new world selection
            meta data object is created and saved to the file system. See <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/> for more information. </summary>
            <returns>A threaded task that is responsible for loading the meta data.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.World.SaveMeta">
            <summary> Asynchronously saves the world selection meta data object to the corresponding file located
            at <see cref="F:Arterra.Core.Storage.World.META_LOCATION"/> in the file system. See <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/> for more information. </summary>
            <returns> A threaded task that is responsible for saving the meta data. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.World.LoadOptions">
            <summary> Asynchronously loads the world configuration of the currently selected world from the file system and
            copies it to the <see cref="P:Arterra.Configuration.Config.CURRENT"> current world configuration </see>. This is the world that is the first 
            element in the <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/> list. This function assumes that the <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/> has already 
            been loaded and is non-empty. If the world does not exist, a new world configuration is created and saved to the file system. </summary>
            <returns> A threaded task that is responsible for loading the world configuration. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.World.SaveOptions">
            <summary> Asynchronously saves the world configuration of the currently selected world to the file system.
            This is the world configuration referenced by the <see cref="P:Arterra.Configuration.Config.CURRENT"> current world configuration </see> 
            and simultaneously should be the first element in the <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/> list. Hence, this function
            copies the <see cref="P:Arterra.Configuration.Config.CURRENT">object</see> to the location specified by the first element of <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/>. </summary>
            <returns>A threaded task that is responsible for saving the world configuration.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.World.LoadMetaSync">
            <summary> Same as <see cref="M:Arterra.Core.Storage.World.LoadMeta"/> but synchronous. See <see cref="M:Arterra.Core.Storage.World.LoadMeta"/> for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.SaveMetaSync">
            <summary> Same as <see cref="M:Arterra.Core.Storage.World.SaveMeta"/> but synchronous. See <see cref="M:Arterra.Core.Storage.World.SaveMeta"/> for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.LoadOptionsSync">
            <summary> Same as <see cref="M:Arterra.Core.Storage.World.LoadOptions"/> but synchronous. See <see cref="M:Arterra.Core.Storage.World.LoadOptions"/> for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.SaveOptionsSync">
            <summary> Same as <see cref="M:Arterra.Core.Storage.World.SaveOptions"/> but synchronous. See <see cref="M:Arterra.Core.Storage.World.SaveOptions"/> for more information. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.SelectWorld(Arterra.Core.Storage.World.WorldMeta)">
            <summary>
            Selects the world through the information specified in <paramref name="meta"/>. This involves
            moving the entry to the front of <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/>, since it now is the most recently
            selected world, and loading the world configuration from the file system to the 
            <see cref="P:Arterra.Configuration.Config.CURRENT"> current world configuration </see> static location. 
            </summary>
            <param name="meta">The meta data necessary to load the world. <paramref name="meta"/> should be
            an entry within <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/>, see <seealso cref="T:Arterra.Core.Storage.World.WorldMeta"/> for more info. </param>
        </member>
        <member name="M:Arterra.Core.Storage.World.CreateWorld">
            <summary> Creates a new world and selects it. This involves creating adding a first entry within <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/>
            since it is now the most recently selected world, and creating a new world configuration off the template
            configuration. The new world config is copied to the <see cref="P:Arterra.Configuration.Config.CURRENT"> current world configuration </see>
            static location. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.DeleteWorld">
            <summary> Deletes the currently selected world. This involves removing the first entry in <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/>
            and deleting the corresponding information associated with the world in the file system indicated by this entry. Note, 
            doing this is absolute and irreversible. A deleted world will have all of its information removed irretrievably.
            This function then loads then selects the next consecutive world in <see cref="F:Arterra.Core.Storage.World.WORLD_SELECTION"/> and loads its configuration,
            creating a new world if there are no worlds left. </summary>
        </member>
        <member name="T:Arterra.Core.Storage.World.WorldMeta">
            <summary>The meta data object responsible for identifying a world in the file system. Only 
            information necessary to identify the world and display it in the world selection
            screen is stored here; this is to avoid loading large world configuration files 
            when viewing the user's created worlds. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.WorldMeta.Id">
            <summary> The unique identifier of the world in the file system. Unlike the world's <see cref="F:Arterra.Core.Storage.World.WorldMeta.Name"/>,
            this is an absolute unique identifier for the world that should not be changed. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.WorldMeta.Path">
            <summary> The location of the directory containing the world-specific information in the file system. 
            This includes the world configuration, and any modified world data. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.WorldMeta.Name">
            <summary> The user-assigned name of the world. This is the name that will be displayed 
            in-game and to the user. This does not need to be unique and may be customized for user 
            comfort and readbility. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.WorldMeta.LastAccessTime">
            <summary> The last time this world was selected. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.World.WorldMeta.CreationTime">
            <summary> The timestamp of when the world was created. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.World.WorldMeta.#ctor(System.String)">
            <summary> Creates a new world meta data object with the specified id.
            This action creates a new unique location for the world's information
            and provides a default name for the world. </summary>
            <param name="id">The absolute unique identifier for the world</param>
        </member>
        <member name="T:Arterra.Core.Storage.CPUMapManager">
            <summary>A static centralized location for managing and storing all CPU-side map information,
            all operations accessing map information, and requesting the information from the GPU. </summary>
            <remark>Because the total amount of concurrent Real Chunks is known on game launch, the exact amount of memory
            necessary to store all mapdata at any given time may be preallocated and redistributed amongst chunks. This reduces
            strain on garbage handler and improves cache coherency of mapData lookups</remark>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager._ChunkManagers">
            <summary> The <see cref="T:Arterra.Core.Terrain.TerrainChunk"/>s associated with the Map Information for each chunk index. See
            <see cref="T:Arterra.Core.Terrain.TerrainChunk"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory">
            <summary>A sectioned memory array that contains all map data for all real chunks successfully created. The exact offset for
            each chunk can be calculated by multiplying the <see cref="M:Arterra.Core.Storage.CPUMapManager.HashCoord(Unity.Mathematics.int3)">chunk index</see> by <see cref="F:Arterra.Core.Storage.CPUMapManager.numPoints"/>. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.AddressDict">
            <summary> A dictionary that maps the chunk index to the <see cref="T:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo"/> for that chunk. 
            This dictionary should be consistent and readonly in multithreaded environments. 
            See <see cref="T:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo"/> for more information.  </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkFlags">
            <summary> Flags associated with the chunk. Unlike <see cref="F:Arterra.Core.Storage.CPUMapManager.AddressDict"/>. Primarily
            whether or not the chunk is dirty, meaning whether this chunk will be saved to disk 
            when unloaded from memory and whether any entry within its chunk's map 
            information has been modified. </summary>
            <remarks>This information is volatile and may be modified in a 
            multi-threaded environment and should not be expected to be consistent.</remarks>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.MapMetaData">
            <summary> Optional meta-data map points in a chunk may contain. Certain
            map entries which require special meta data(e.g. chests/containers) should store
            their specific information in this dictionary, accessible via the linearly encoded
            sub-chunk index(MIndex) of the entry they're accessing. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.numChunksAxis">
            <summary> The maximum number of real chunks along each axis that can be saved simultaneously with the game's 
            current settings. See <see cref="M:Arterra.Core.Terrain.OctreeTerrain.BalancedOctree.GetAxisChunksDepth(System.Int32,System.Int32,System.UInt32)"/> to see how this is calculated. </summary>
        </member>
        <member name="P:Arterra.Core.Storage.CPUMapManager.numChunks">
            <summary>The total number of real chunks that can be saved simultaneously 
            with the game's current settings. Equivalent to <see cref="F:Arterra.Core.Storage.CPUMapManager.numChunksAxis"/>^3. / </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.IsoValue">
            <summary> The Real Integer IsoValue used in all map operations. Equivalent to the 
            <see cref="F:Arterra.Configuration.Quality.Terrain.IsoLevel"/> * 0xFF (maximum density value). </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.Initialize">
            <summary> Initializes the CPU Map Manager with the current game settings. This will allocate all necessary memory
            and prepare the CPU Map Manager for use. If the CPU Map Manager has already been initialized,
            it will first release all previously allocated resources before reinitializing. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.Release">
            <summary> Releases all resources allocated by the CPU Map Manager. This operation can
            only be performed if the CPU Map Manager has been initialized. This operation will 
            save all unsaved chunks to disk, and can be slow resultingly. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.HashCoord(Unity.Mathematics.int3)">
            <summary> Calculates the hash for a given chunk coordinate. The hash is a unique integer
            identifier for a chunk that is minimally dense and can be used to access the
            corresponding chunk in the <see cref="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory"/> and <see cref="F:Arterra.Core.Storage.CPUMapManager.AddressDict"/>. </summary>
            <param name="CCoord">The Coordinate in Chunk Space of the chunk to be hashed</param>
            <returns>The unique minimally dense hash index.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.AllocateChunk(Arterra.Core.Terrain.TerrainChunk,System.Collections.Generic.KeyValuePair{System.UInt32,System.Object}[],Unity.Mathematics.int3)">
            <summary> Allocates a new chunk in the CPU Map Manager. This will setup handlers
            associating the <see cref="M:Arterra.Core.Storage.CPUMapManager.HashCoord(Unity.Mathematics.int3)">chunkIndex</see> and memory section within 
            <see cref="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory"/> with the specific <see cref="T:Arterra.Core.Terrain.TerrainChunk"/> and <see cref="T:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo"/> 
            for that chunk. Also releases the previous chunk if it exists and saves it to disk if it is dirty.  </summary>
            <remarks> The previous chunk with the same <paramref name="CCoord"/> is guaranteed to be exactly 
            <see cref="F:Arterra.Core.Storage.CPUMapManager.numChunksAxis"/>+1 chunks away from the new chunk, so it is implied
            that it should be safe to deallocate if this chunk is to be loaded. </remarks>
            <param name="chunk">The Real Terrain Chunk at <i>CCoord</i></param>
            <param name="chunkMeta"> The optional map-entry specific meta data in its flattened storage form</param>
            <param name="CCoord">The Coordinate in chunk space of the new chunk to be allocated.</param>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.RayTestSolid(Unity.Mathematics.int3)">
            <summary> Basic Function given to RayCastTerrain to test if it intersect solid ground </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.RayCastTerrain(Unity.Mathematics.float3,Unity.Mathematics.float3,System.Single,System.Func{Unity.Mathematics.int3,System.UInt32},Unity.Mathematics.float3@)">
            <summary> Performs a precise raycast on the IsoSurface represented through the underlying <i>density</i> information given by
            the callback with the specific <see cref="F:Arterra.Core.Storage.CPUMapManager.IsoValue"/> specified. A raycast determines whether a ray intersects with the IsoSurface
            and if-so at what point. This function does not use any generated lookup structures and operates on the raw <see cref="T:Arterra.Core.Storage.MapData"/>
            stored in <see cref="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory"/>. </summary>
            <remarks> This function uses a 3D voxel line drawing algorithm provided here http://www.cse.yorku.ca/~amana/research/grid.pdf and it
            is linear in complexity with respect to <i>rayLength</i>. </remarks>
            <param name="oGS">The origin of the ray in Grid Space</param>
            <param name="rayDir">The direction of the ray.</param>
            <param name="rayLength">The maximum length of the ray</param>
            <param name="callback">A callback that returns a density value given an integer Grid Space Location of a map entry. </param>
            <param name="hit">If the ray intersects the IsoSurface, the position in GridSpace of the first intersection. </param>
            <returns>Whether or not the ray intersects the IsoSurface in less than <i>rayLength</i> distance from the rayOrigin(<i>oGS</i>)</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.CylinderCastTerrain(Unity.Mathematics.float3,Unity.Mathematics.float3,System.Single,System.Single,System.Func{Unity.Mathematics.int3,System.UInt32},Unity.Mathematics.float3@)">
            <summary> Performs a precise cylinder cast IsoSurface represented through the underlying <i>density</i> information given by
            the callback with the specific <see cref="F:Arterra.Core.Storage.CPUMapManager.IsoValue"/> specified. The cylinder cast determines whether the cylinder 
            (actually rectangular prism) intersects with the IsoSurface and if-so, the first point it intersects. </summary>
            <remarks> This function uses a 3D voxel line drawing algorithm provided here http://www.cse.yorku.ca/~amana/research/grid.pdf and it
            is linear in complexity with respect to <i>rayLength</i>. </remarks>
            <param name="oGS">The origin of the cylinder in Grid Space</param>
            <param name="rayDir">The direction of the cylinder.</param>
            <param name="radius"> The radius of the cylinder in Grid Space</param>
            <param name="rayLength">The maximum length of the cylinder</param>
            <param name="callback">A callback that returns a density value given an integer Grid Space Location of a map entry. </param>
            <param name="hit">If the ray intersects the IsoSurface, the position in GridSpace of the first intersection. </param>
            <returns>Whether or not the ray intersects the IsoSurface in less than <i>rayLength</i> distance from the rayOrigin(<i>oGS</i>)</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.GetOrCreateMapMeta``1(Unity.Mathematics.int3,System.Func{``0},``0@)">
            <summary> Obtains the metadata of type <i>TMeta</i> at the location. If the metadata at this location
            does not exist or is not of type <i>TMeta</i>, this call will discard the previous information
            and return a new default <i>TMeta</i> object which is now stored at this location. </summary>
            <typeparam name="TMeta">The type of object to obtain; will delete any object not of 
            the requested type and replace it with a new default instance.</typeparam>
            <param name="GCoord">The coordinate in grid space of the map entry whose meta data is being queried</param>
            <param name="GetDefault">The callback to acquire a default instance of the object being stored if it does not
            currently exist at the requested location </param>
            <param name="ret">The meta data obtained at this location.</param>
            <returns>Whether or not the requested metaData could be obtained. If the metaData cannot be obtained
            it means the system is not capable of tracking it and the caller should not attempt to further use/create
             the meta data.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.TryGetExistingMapMeta``1(Unity.Mathematics.int3,``0@)">
            <summary>Obtains the metadata of type <i>TMeta</i> at the location only if there exists
            metadata of the requested type. Otherwise fails. Unlike <see cref="M:Arterra.Core.Storage.CPUMapManager.GetOrCreateMapMeta``1(Unity.Mathematics.int3,System.Func{``0},``0@)"/>,
            this operation will not create/modify existing metadata</summary>
            <typeparam name="TMeta">The type of object to obtain</typeparam>
            <param name="GCoord">The coordinate in grid space of the map entry whose meta data is being queried</param>
            <param name="ret">The meta data obtained at this location.</param>
            <returns>Whether or not there existed metaData of the requested type at the location.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.SetExistingMapMeta``1(Unity.Mathematics.int3,``0)">
            <summary>Sets the metadata for a certain location or clears it. </summary>
            <typeparam name="TMeta">The type of object to set</typeparam>
            <param name="GCoord">The coordinate in grid space of the map entry whose meta data is being set</param>
            <param name="value">The meta data to set to this location. If this value is null, any existing
            metadata at this location will be removed.</param>
            <returns>If setting, whether the value was successfully set. If removing, whether any value
            was successfully removed</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.ClearMapMetaData(Unity.Mathematics.int3)">
            <summary> Removes the meta data at the map entry at the specified 
            location if it exists. </summary>
            <param name="GCoord">The coordinate in grid space of the map entry whose 
            meta data is being removed.</param>
            <returns>Whether or not any object was removed. Regardless of the output, the caller is 
            guaranteed that there does not exist meta data  associated
            with this location anymore. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.Terraform(Unity.Mathematics.float3,System.Int32,System.Func{Unity.Mathematics.int3,System.Single,System.Boolean},System.Func{Unity.Mathematics.int3,System.Boolean})">
            <summary> Provides a method for smooth terrain modification in an area around a point. Provides a callback
            providing the mapData of a specific map entry to be modified and the amount to modify for a smooth
            terraform. Specifically, in a circular region around <i>tPointGS</i> this amount falls off proportionate
            to distance from the center. </summary>
            <param name="tPointGS">The center in grid space of the circle that is terraformed</param>
            <param name="terraformRadius">The radius in grid space of the circle that is terraformed</param>
            <param name="handleTerraform">The callback that is given the map coordinate, how much to modify it, and
            is responsible for modifying the terrian and returning whether or not it was modified </param>
            <param name="handlePreTerraform">The optional callback that will be called for every map coordinate before
            any calls to <i>handleTerraform</i> is ever made, returning whether or not to terminate the terraform operation. </param>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.FindTerraformable(Unity.Mathematics.float3,System.Int32,System.Func{Unity.Mathematics.int3,System.Boolean},Unity.Mathematics.int3@)">
            <summary> Finds a singular location that can be validly terraformed, as determined by the <paramref name="canTerraform"/> callback. 
            If found, the location returned will be the closest position to the center of the terraformed area (<paramref name="tPointGS"/>). </summary>
            <param name="tPointGS">The center in grid space of the circle that is terraformed</param>
            <param name="terraformRadius">The radius in grid space of the circle that is terraformed</param>
            <param name="canTerraform">The callback that will be called for every map coordinate to determine if the point 
            can be terraformed</param>
            <param name="terraformPoint">If a valid coordinate was successfully found, the coordinate
            which can be terraformed. </param>
            <returns> Whether or not a location was found </returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.BeginMapReadback(Unity.Mathematics.int3,System.Action)">
            <summary> Reads back the map information associated with the Chunk Coord(<i>CCoord</i>) from the GPU to the CPU.
            The map information should exist at the expected location in the GPU's map memory(<see cref="F:Arterra.Core.Storage.GPUMapManager._ChunkAddressDict"/>)
            and will be read to the location corresponding to the <see cref="M:Arterra.Core.Storage.CPUMapManager.HashCoord(Unity.Mathematics.int3)">chunk index</see> of this chunk coordinate within
            <see cref="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory"/>. One should first allocate this region through <see cref="M:Arterra.Core.Storage.CPUMapManager.AllocateChunk(Arterra.Core.Terrain.TerrainChunk,System.Collections.Generic.KeyValuePair{System.UInt32,System.Object}[],Unity.Mathematics.int3)"/> before calling this function. </summary>
            <param name="CCoord">The coordiante of the chunk in chunk space to be read back. Used in determining both where the information is read
            from in GPU memory and where it is written to in <see cref="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory"/>. </param>
            <param name="onReadback"> A callback that will be triggered when the map is fully readback </param>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.GSToHashes(Unity.Mathematics.int3)">
            <summary> Converts from grid space to chunk space hash and map space hash.
            See <see cref="M:Arterra.Core.Storage.CPUMapManager.GSToCS(Unity.Mathematics.int3)"/> for more information on chunk space.
            The map space hash is the offset of the map entry within the chunk. </summary>
            <param name="GCoord">The coordinate in grid space</param>
            <returns>Two integers, x: the chunk space has, y: the map space hash. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.GSToCS(Unity.Mathematics.int3)">
            <summary> Converts from grid space to chunk space using integer mathematics. Chunk Space is a coordinate
            system that reserves a unique minimally dense integer coordinate for each Real Chunk. Specifically, gets 
            the chunk coordinate of the chunk containing this grid coordinate. </summary>
            <remarks> Importantly, this is NOT the rounded coordinate but more akin to a floor. </remarks>
            <param name="GCoord">The coordinate in grid space</param>
            <returns>The associated coordiante in chunk space </returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.WSToGS(Unity.Mathematics.float3)">
            <summary> Converts from world space to grid space. Grid space is the global coordinate system that reserves a unique
            minimally dense integer coordinate for each map entry in a RealChunk. This is the inverse of <see cref="M:Arterra.Core.Storage.CPUMapManager.GSToWS(Unity.Mathematics.float3)"/>.
            Conversion depends primarily on <see cref="F:Arterra.Core.Storage.CPUMapManager.lerpScale"/>. </summary>
            <param name="WSPos">The position in world space</param>
            <returns>The associated exact position in grid space</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.GSToWS(Unity.Mathematics.float3)">
            <summary> Converts from grid space to world space. World space is the global coordinate system recognized
            by Unity's object and rendering system. This is the inverse of <see cref="M:Arterra.Core.Storage.CPUMapManager.WSToGS(Unity.Mathematics.float3)"/>.
            Conversion depends primarily on <see cref="F:Arterra.Core.Storage.CPUMapManager.lerpScale"/>.  </summary>
            <param name="GSPos">The position in grid space</param>
            <returns>The associated exact position in world space</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.WSToGSScale(Unity.Mathematics.float3)">
            <summary> Converts a world space distance to grid space distance. Does not apply shifting like <see cref="M:Arterra.Core.Storage.CPUMapManager.WSToGS(Unity.Mathematics.float3)"/> </summary>
            <param name="WSPos">The distance in world space</param>
            <returns>The associated distance in grid space</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.SetMap(Arterra.Core.Storage.MapData,Unity.Mathematics.int3,System.Boolean)">
            <summary> Assigns the mapData of a given GCoord if it is currently being managed by 
            <see cref="T:Arterra.Core.Storage.CPUMapManager"/>. Also notifies the corresponding chunk to reflect the 
            change visually and marks the chunk as dirty when storing to disk. </summary>
            <param name="data">The <see cref="T:Arterra.Core.Storage.MapData"/> that is written(assigned) </param>
            <param name="GCoord">The coordinate in grid space of the entry being assinged to</param>
            <param name="PropogateUpdates">Whether or not to notify entries in the map of updation. 
            This should always be true unless it can cause infinite cascading updates </param>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.SampleMap(Unity.Mathematics.int3)">
            <summary> Retrieves the <see cref="T:Arterra.Core.Storage.MapData"/> associated with a grid coordinate if
            it is currently being managed by <see cref="T:Arterra.Core.Storage.CPUMapManager"/>.  </summary>
            <param name="GCoord">The coordinate in grid space of the <see cref="T:Arterra.Core.Storage.MapData"/> which is returned</param>
            <returns>The <see cref="T:Arterra.Core.Storage.MapData"/> at the given grid coordinate if tracked by <see cref="T:Arterra.Core.Storage.CPUMapManager"/>, 
            otherwise returns a <see cref="T:Arterra.Core.Storage.MapData"/> instance with material = 0x7FFF. </returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.SampleMapFromHash(Unity.Mathematics.int2)">
            <summary> Retrieves the <see cref="T:Arterra.Core.Storage.MapData"/> associated with a map entry
            of the given hash coordinate if it is currently being managed by <see cref="T:Arterra.Core.Storage.CPUMapManager"/>.
            This is a faster and more direct method for sampling map information. </summary>
            <param name="hash">The hash indices as provided by <see cref="M:Arterra.Core.Storage.CPUMapManager.GSToHashes(Unity.Mathematics.int3)"/></param>
            <returns>The map data associated with this location.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.SampleTerrain(Unity.Mathematics.int3)">
            <summary> Retrieves the <see cref="P:Arterra.Core.Storage.MapData.viscosity"/>/<see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/> value of the 
            MapData associated with the given grid coordinate if it is currently being managed by <see cref="T:Arterra.Core.Storage.CPUMapManager"/>,
            otherwise returns 0xFF. </summary>
            <param name="GCoord">The coordinate in grid space of the MapData being queried. </param>
            <returns>The <see cref="P:Arterra.Core.Storage.MapData.viscosity"/>/<see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/> of the associated <see cref="T:Arterra.Core.Storage.MapData"/>.</returns>
        </member>
        <member name="T:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo">
            <summary> The meta-data coordinating map-metadata storage, access,
            saving and readback of a chunk's map information. Associated via
            the chunk index within <see cref="F:Arterra.Core.Storage.CPUMapManager.AddressDict"/> to a chunk's
            map data </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo.CCoord">
            <summary> The coordinate in chunk space of the chunk being stored.
            Undefined if <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo.valid"/> is false </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo.valid">
            <summary> Whether the data region within <see cref="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory"/> associated with 
            this object has contains real chunk data. This will be set as long as one chunk which 
            <see cref="M:Arterra.Core.Storage.CPUMapManager.HashCoord(Unity.Mathematics.int3)">hashes</see> to this object calls <see cref="M:Arterra.Core.Storage.CPUMapManager.BeginMapReadback(Unity.Mathematics.int3,System.Action)"/> </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo.#ctor(Unity.Mathematics.int3)">
            <summary> Initializes a new <see cref="T:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo"/> for the specific
            chunk coordinate of the chunk. </summary>
            <param name="CCoord">The coordinate in chunk space of the chunk being managed</param>
        </member>
        <member name="T:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo.Flags">
            <summary> Enum of volatile flags that can be applied to a chunk 
            indicating how it will be treated when unloaded from memory </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo.Flags.Clean">
            <summary>Default chunk state, marks it will not be saved to disk when unloaded</summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo.Flags.Dirty">
            <summary>Marks that this chunk will be saved to disk when unloaded from memory. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.DisposeChunk(System.Int32)">
            <summary> Invalidates the chunk map data indicating to 
            processes that it should no longer be modified </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.ActivateChunk(System.Int32)">
            <summary> Activates the chunk indicating to all processes
            that it can be referenced</summary>
        </member>
        <member name="T:Arterra.Core.Storage.CPUMapManager.ChunkPtr">
            <summary> A wrapper structure containing a specific chunk's map data 
            that will be stored to disk </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.data">
            <summary> A native array containing the chunk's map information at
            the offset specified by <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.offset"/> </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.mapMeta">
            <summary> The array containing all map entry meta-data and the index
            identifying them as it will be represented in storage.
            See <see cref="F:Arterra.Core.Storage.CPUMapManager.MapMetaData"/> for more information. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.offset">
            <summary> The offset within <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.data"/> where the map
            information of the chunk being stored starts. </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.ChunkPtr.#ctor(System.Collections.Concurrent.ConcurrentDictionary{System.UInt32,System.Object},Unity.Collections.NativeArray{Arterra.Core.Storage.MapData},System.Int32)">
            <summary> A simple constructor creating a ChunkPtr wrapper </summary>
            /// <param name="metaData">The optional map-entry meta data to be stored. See 
            <see cref="F:Arterra.Core.Storage.CPUMapManager.MapMetaData"/> for more information</param>
            <param name="data">An native array containing the chunk's map information at <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.offset"/></param>
            <param name="offset">The offset within <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.data"/> where the chunk's map information begins</param>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.ChunkPtr.Copy(System.Int32)">
            <summary>Copies the <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.data">MapData</see> pointed to by this chunk ptr
            to a new location and returns a ChunkPtr referencing it.</summary>
            <param name="Length">The amount of points that are to be copied from the position 
            <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.offset"/> in <see cref="F:Arterra.Core.Storage.CPUMapManager.ChunkPtr.data"/></param>
            <returns>A ChunkPtr containing the newly copied map information</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.ChunkPtr.Dispose">
            <summary>Releases the mapdata pointed to by this chunkptr; only call 
            this if the chunkptr has its own copy of the mapData </summary>
        </member>
        <member name="T:Arterra.Core.Storage.CPUMapManager.MapContext">
            <summary> A wrapper structure containing all the unamanged handlers necessary
            to perform map lookups and modifications in an unamanged context. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.MapContext.MapData">
            <summary> A pointer to the beginning of <see cref="F:Arterra.Core.Storage.CPUMapManager.SectionedMemory"/>, 
            which contains all map information actively tracked on the CPU and is interactive. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.MapContext.AddressDict">
            <summary> A pointer to the beginning of <see cref="F:Arterra.Core.Storage.CPUMapManager.MapContext.AddressDict"/> which maps from 
            a <see cref="M:Arterra.Core.Storage.CPUMapManager.HashCoord(Unity.Mathematics.int3)">chunk index</see> to <see cref="T:Arterra.Core.Storage.CPUMapManager.ChunkMapInfo"/> for that chunk. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.MapContext.mapChunkSize">
            <summary> See <see cref="F:Arterra.Configuration.Quality.Terrain.mapChunkSize"/> </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.MapContext.numChunksAxis">
            <summary> See <see cref="F:Arterra.Core.Storage.CPUMapManager.numChunksAxis"/> </summary>
        </member>
        <member name="F:Arterra.Core.Storage.CPUMapManager.MapContext.IsoValue">
            <summary> See <see cref="F:Arterra.Core.Storage.CPUMapManager.IsoValue"/> </summary>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.SampleMap(Unity.Mathematics.int3@,Arterra.Core.Storage.CPUMapManager.MapContext@)">
            <summary> Same as <see cref="M:Arterra.Core.Storage.CPUMapManager.SampleMap(Unity.Mathematics.int3)"/> except in an unmanaged context.
            The context information normally sourced by <see cref="T:Arterra.Core.Storage.CPUMapManager"/> must
            instead be passed in through a <see cref="T:Arterra.Core.Storage.CPUMapManager.MapContext"/>.  </summary>
            <param name="GCoord">The coordinate in grid space of the point being retrieved</param>
            <param name="context">The map context necessary to perform this operation. See <see cref="T:Arterra.Core.Storage.CPUMapManager.MapContext"/> for more info. </param>
            <returns>The <see cref="T:Arterra.Core.Storage.MapData"/> associated with the grid coordinate if it is currently tracked by <see cref="T:Arterra.Core.Storage.CPUMapManager"/>.</returns>
        </member>
        <member name="M:Arterra.Core.Storage.CPUMapManager.SampleTerrain(Unity.Mathematics.int3@,Arterra.Core.Storage.CPUMapManager.MapContext@)">
            <summary> Same as <see cref="M:Arterra.Core.Storage.CPUMapManager.SampleTerrain(Unity.Mathematics.int3)"/> except in an unmanaged context.
            The context information normally sourced by <see cref="T:Arterra.Core.Storage.CPUMapManager"/> must
            instead be passed in through a <see cref="T:Arterra.Core.Storage.CPUMapManager.MapContext"/>.  </summary>
            <param name="GCoord">The coordinate in grid space of the point whose SolidDensity is being retrieved</param>
            <param name="context">The map context necessary to perform this operation. See <see cref="T:Arterra.Core.Storage.CPUMapManager.MapContext"/> for more info. </param>
            <returns>The <see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/> associated with the grid coordinate if it is currently tracked by <see cref="T:Arterra.Core.Storage.CPUMapManager"/>.</returns>
        </member>
        <member name="T:Arterra.Core.Storage.MapData">
            <summary> Akin to a "voxel" or "block", The 'map information' of a single point in the world. 
            This is the minimal atmoic amount of information necessary to represent any information about
            the terrain/world in-game. In particular, describes the identity and terrain shape of a 
            unique integer coordinate in grid space. </summary>
        </member>
        <member name="F:Arterra.Core.Storage.MapData.data">
            <summary> The raw 4 byte bitmap containing the natural packed representation of a <see cref="T:Arterra.Core.Storage.MapData"/> entry. </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.IsNull">
            <summary>Whether the <see cref="T:Arterra.Core.Storage.MapData"/> refers to a special <i>Null</i> entry which is often
            returned when an invalid/no entry should be returned </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.isDirty">
            <summary> Whether the map entry has been modified while on the CPU. Whether the information
            cannot be recalculated by the generation pipeline and needs to be saved. </summary>
            <remarks> Represented by the highest bit in <see cref="F:Arterra.Core.Storage.MapData.data"/> </remarks>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.density">
            <summary> How much total material is contained in the location of 
            this <see cref="T:Arterra.Core.Storage.MapData"/>. Affects the shape of the terrain.  </summary>
            <remarks> Represented by the lowest byte in <see cref="F:Arterra.Core.Storage.MapData.data"/></remarks>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.viscosity">
            <summary> How much total solid material is contained in the location 
            of this <see cref="T:Arterra.Core.Storage.MapData"/>. Directly affects the shape of the solid terrain.  </summary>
            /// <remarks> Represented by the second lowest byte in <see cref="F:Arterra.Core.Storage.MapData.data"/></remarks>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.material">
            <summary> The identity of this <see cref="T:Arterra.Core.Storage.MapData"/>. The index within the <see cref="F:Arterra.Configuration.Config.GenerationSettings.Materials"/>
            registry of the <see cref="N:Arterra.Configuration.Generation.Material"/> responsible for controling the apperance 
            and behavior of this <see cref="T:Arterra.Core.Storage.MapData"/>  </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.SolidDensity">
            <summary> How much total solid material is contained in the location 
            of this <see cref="T:Arterra.Core.Storage.MapData"/>. A clearer alias for <see cref="P:Arterra.Core.Storage.MapData.viscosity"/> </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.LiquidDensity">
            <summary> How much liquid material is contained in the location of this <see cref="T:Arterra.Core.Storage.MapData"/>.
            Directly effects the shape of liquid surfaces. Equivalent to <i>(density - viscosity)</i> </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.IsSolid">
            <summary> Whether this <see cref="T:Arterra.Core.Storage.MapData"/> represents a point that is underground. Whether
            <see cref="P:Arterra.Core.Storage.MapData.SolidDensity"/> is greater than <see cref="F:Arterra.Core.Storage.CPUMapManager.IsoValue"/>. </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.IsLiquid">
            <summary> Whether this <see cref="T:Arterra.Core.Storage.MapData"/> represents a point that is underwater. Whether
            <see cref="P:Arterra.Core.Storage.MapData.LiquidDensity"/> is greater than <see cref="F:Arterra.Core.Storage.CPUMapManager.IsoValue"/>. </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.IsGaseous">
            <summary> Whether this <see cref="T:Arterra.Core.Storage.MapData"/> represents a point that is neither underwater nor underground.
            Whether both <see cref="P:Arterra.Core.Storage.MapData.IsSolid"/> and <see cref="P:Arterra.Core.Storage.MapData.IsLiquid"/> is false. </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData._material">
            <summary>A backdoor method to modify the material for serialization 
            without marking the entry as dirty(<see cref="P:Arterra.Core.Storage.MapData.isDirty"/>). </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.MaxDensity">
            <summary> The maximum value for <see cref="P:Arterra.Core.Storage.MapData.density"/> supported by the game </summary>
        </member>
        <member name="P:Arterra.Core.Storage.MapData.MaxViscosity">
            <summary> The maximum value for <see cref="P:Arterra.Core.Storage.MapData.viscosity"/> supported by the game </summary>
        </member>
        <member name="T:Arterra.Core.Events.EventContext`1">
            <summary> A generic event context wrapper </summary>
            <typeparam name="T"> The type of data contained in the context. 
            If there're multiple data in the context, first wrap them in a tuple or a custom struct. </typeparam>
        </member>
        <member name="M:Arterra.Core.Events.EventControl.AddContextlessEventHandler(Arterra.Core.Events.GameEvent,System.Action{System.Object,System.Object})">
            <summary>
            Adds an event handler for the specified GameEvent without context parameter.
            </summary>
            <param name="evt"></param>
            <param name="handler"></param>
        </member>
        <member name="F:SubChunkShaderGraph.FixedOctree.ViewerPosGS">
            <summary> The last tracked position of the viewer in 
            chunk space. This value is only updated when the viewer's
            position exceeds the viewDistUpdate threshold. </summary>
        </member>
        <member name="P:SubChunkShaderGraph.GeoShaderOffsets.bufferStart">
            <summary> The start of the buffer region that is used by the GeoShader generator. 
            See <see cref="P:BufferOffsets.bufferStart"/> for more info. </summary>
        </member>
        <member name="P:SubChunkShaderGraph.GeoShaderOffsets.bufferEnd">
            <summary> The end of the buffer region that is used by the GeoShader generator. 
            See <see cref="P:BufferOffsets.bufferEnd"/> for more info. </summary>
        </member>
        <member name="M:PathFinder.FindPathOrApproachTarget(Unity.Mathematics.int3@,Unity.Mathematics.int3@,System.Int32,Arterra.Configuration.Generation.Entity.EntitySetting.ProfileInfo@,EntityJob.Context@,System.Int32@)">
             <summary>
            An annoying challenge of pathfinding is that we must search all pathable nodes 
            to determine a path doesn't exist. However, if the destination is not a pathable point
            pathfinding will always have to search all nodes which is inefficient. Thus if the destination
            is not a pathable point, simply follow a ray to a certain length to approach the target, which is a
            much cheaper operation than failing to find an exact path.
             </summary>
             <param name="Origin"></param>
             <param name="iEnd"></param>
             <param name="PathDistance"></param>
             <param name="info"></param>
             <param name="context"></param>
             <param name="PathLength"></param>
        </member>
        <member name="T:StructCheckDrawer">
            <summary> A utility class to override serialization of <see cref="T:Arterra.Configuration.Generation.Structure.StructureData.CheckInfo"/> into a Unity Inspector format.
            It exposes the internal components of the bitmap so it can be more easily understood by the developer. </summary>
        </member>
        <member name="M:StructCheckDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to be rendered for the property. </summary>
        </member>
        <member name="M:StructCheckDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>  Callback for when the GUI needs to know the height of the Inspector element. </summary>
        </member>
        <member name="M:TerrainCollider.FixedUpdate(Arterra.Configuration.Generation.Entity.Entity)">
            <summary> Updates the collider on a Unity Fixed Update. </summary>
        </member>
        <member name="F:ToolTag.TerraformSpeed">
            <summary> The speed at which the user can terraform the terrain. As terraforming is a 
            continuous process, the speed is measured in terms of change in density per frame. </summary>
        </member>
        <member name="F:ToolTag.ToolDamage">
            <summary> Scales how much a tool is damaged when removing this material. Damaging
            a tool decreases its durability. If this is a material, this usually scales
            the amount of material used up instead </summary>
        </member>
        <member name="F:ToolTag.GivesItem">
            <summary> Whether or not the material removed by this tool will give 
            the player the corresponding item. </summary>
        </member>
        <member name="F:ConvertibleTag._neighborBounds">
            <summary> The <see cref="T:Arterra.Core.Storage.MapData"/> requirements of at least one neighbor of the material that the grass can spread onto.  </summary>
        </member>
        <member name="F:ConvertibleToolTag._neighborBounds">
            <summary> The <see cref="T:Arterra.Core.Storage.MapData"/> requirements of at least one neighbor of the material that the grass can spread onto.  </summary>
        </member>
        <member name="T:TooltipTag">
            <summary>
            Tooltip Tag defining the configurations for tooltips associated with an entity/item or other game elements.
            </summary>
        </member>
        <member name="M:Utils.SaveTextureToFileUtility.SaveTexture2DToFile(UnityEngine.Texture2D,System.String,Utils.SaveTextureToFileUtility.SaveTextureFileFormat,System.Int32)">
            <summary>
            Saves a Texture2D to disk with the specified filename and image format
            </summary>
            <param name="tex"></param>
            <param name="filePath"></param>
            <param name="fileFormat"></param>
            <param name="jpgQuality"></param>
        </member>
        <member name="M:Utils.SaveTextureToFileUtility.SaveRenderTextureToFile(UnityEngine.RenderTexture,System.String,Utils.SaveTextureToFileUtility.SaveTextureFileFormat,System.Int32)">
            <summary>
            Saves a RenderTexture to disk with the specified filename and image format
            </summary>
            <param name="renderTexture"></param>
            <param name="filePath"></param>
            <param name="fileFormat"></param>
            <param name="jpgQuality"></param>
        </member>
        <member name="M:Utils.SaveTextureToFileUtility.LoadImageToSprite(System.String,Utils.SaveTextureToFileUtility.SaveTextureFileFormat)">
            <summary> Reads an image at a given file path and converts it into a Sprite. </summary>
            <param name="filePath">The file path of the image file</param>
            <param name="fileFormat"></param>
            <returns>The sprite containing the read image or null if no file is found 
            or the file is formatted incorrectly. </returns>
        </member>
        <member name="T:Utils.EnumerableHelpers">
            <summary>
                Internal helper functions for working with enumerables.
            </summary>
        </member>
        <member name="M:Utils.EnumerableHelpers.ToArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary>Converts an enumerable to an array using the same logic as List{T}.</summary>
            <param name="source">The enumerable to convert.</param>
            <param name="length">The number of items stored in the resulting array, 0-indexed.</param>
            <returns>
                The resulting array.  The length of the array may be greater than <paramref name="length" />,
                which is the actual number of elements in the array.
            </returns>
        </member>
        <member name="T:Utils.PriorityQueue`2">
            <summary>
                Represents a min priority queue.
            </summary>
            <typeparam name="TElement">Specifies the type of elements in the queue.</typeparam>
            <typeparam name="TPriority">Specifies the type of priority associated with enqueued elements.</typeparam>
            <remarks>
                Implements an array-backed quaternary min-heap. Each element is enqueued with an associated priority
                that determines the dequeue order: elements with the lowest priority get dequeued first.
            </remarks>
        </member>
        <member name="F:Utils.PriorityQueue`2.Arity">
            <summary>
                Specifies the arity of the d-ary heap, which here is quaternary.
                It is assumed that this value is a power of 2.
            </summary>
        </member>
        <member name="F:Utils.PriorityQueue`2.Log2Arity">
            <summary>
                The binary logarithm of <see cref="F:Utils.PriorityQueue`2.Arity" />.
            </summary>
        </member>
        <member name="F:Utils.PriorityQueue`2._nodes">
            <summary>
                Represents an implicit heap-ordered complete d-ary tree, stored as an array.
            </summary>
        </member>
        <member name="F:Utils.PriorityQueue`2._comparer">
            <summary>
                Custom comparer used to order the heap.
            </summary>
        </member>
        <member name="F:Utils.PriorityQueue`2._unorderedItems">
            <summary>
                Lazily-initialized collection used to expose the contents of the queue.
            </summary>
        </member>
        <member name="F:Utils.PriorityQueue`2._size">
            <summary>
                The number of nodes in the heap.
            </summary>
        </member>
        <member name="F:Utils.PriorityQueue`2._version">
            <summary>
                Version updated on mutation to help validate enumerators operate on a consistent state.
            </summary>
        </member>
        <member name="P:Utils.PriorityQueue`2.Count">
            <summary>
                Gets the number of elements contained in the <see cref="T:Utils.PriorityQueue`2" />.
            </summary>
        </member>
        <member name="P:Utils.PriorityQueue`2.Comparer">
            <summary>
                Gets the priority comparer used by the <see cref="T:Utils.PriorityQueue`2" />.
            </summary>
        </member>
        <member name="P:Utils.PriorityQueue`2.UnorderedItems">
            <summary>
                Gets a collection that enumerates the elements of the queue in an unordered manner.
            </summary>
            <remarks>
                The enumeration does not order items by priority, since that would require N * log(N) time and N space.
                Items are instead enumerated following the internal array heap layout.
            </remarks>
        </member>
        <member name="M:Utils.PriorityQueue`2.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Utils.PriorityQueue`2" /> class.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Utils.PriorityQueue`2" /> class
                with the specified initial capacity.
            </summary>
            <param name="initialCapacity">Initial capacity to allocate in the underlying heap array.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The specified <paramref name="initialCapacity" /> was negative.
            </exception>
        </member>
        <member name="M:Utils.PriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`1})">
            <summary>
                Initializes a new instance of the <see cref="T:Utils.PriorityQueue`2" /> class
                with the specified custom priority comparer.
            </summary>
            <param name="comparer">
                Custom comparer dictating the ordering of elements.
                Uses <see cref="P:System.Collections.Generic.Comparer`1.Default" /> if the argument is <see langword="null" />.
            </param>
        </member>
        <member name="M:Utils.PriorityQueue`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`1})">
            <summary>
                Initializes a new instance of the <see cref="T:Utils.PriorityQueue`2" /> class
                with the specified initial capacity and custom priority comparer.
            </summary>
            <param name="initialCapacity">Initial capacity to allocate in the underlying heap array.</param>
            <param name="comparer">
                Custom comparer dictating the ordering of elements.
                Uses <see cref="P:System.Collections.Generic.Comparer`1.Default" /> if the argument is <see langword="null" />.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The specified <paramref name="initialCapacity" /> was negative.
            </exception>
        </member>
        <member name="M:Utils.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
                Initializes a new instance of the <see cref="T:Utils.PriorityQueue`2" /> class
                that is populated with the specified elements and priorities.
            </summary>
            <param name="items">The pairs of elements and priorities with which to populate the queue.</param>
            <exception cref="T:Utils.ArgumentNullException">
                The specified <paramref name="items" /> argument was <see langword="null" />.
            </exception>
            <remarks>
                Constructs the heap using a heapify operation,
                which is generally faster than enqueuing individual elements sequentially.
            </remarks>
        </member>
        <member name="M:Utils.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},System.Collections.Generic.IComparer{`1})">
            <summary>
                Initializes a new instance of the <see cref="T:Utils.PriorityQueue`2" /> class
                that is populated with the specified elements and priorities,
                and with the specified custom priority comparer.
            </summary>
            <param name="items">The pairs of elements and priorities with which to populate the queue.</param>
            <param name="comparer">
                Custom comparer dictating the ordering of elements.
                Uses <see cref="P:System.Collections.Generic.Comparer`1.Default" /> if the argument is <see langword="null" />.
            </param>
            <exception cref="T:Utils.ArgumentNullException">
                The specified <paramref name="items" /> argument was <see langword="null" />.
            </exception>
            <remarks>
                Constructs the heap using a heapify operation,
                which is generally faster than enqueuing individual elements sequentially.
            </remarks>
        </member>
        <member name="M:Utils.PriorityQueue`2.Enqueue(`0,`1)">
            <summary>
                Adds the specified element with associated priority to the <see cref="T:Utils.PriorityQueue`2" />.
            </summary>
            <param name="element">The element to add to the <see cref="T:Utils.PriorityQueue`2" />.</param>
            <param name="priority">The priority with which to associate the new element.</param>
        </member>
        <member name="M:Utils.PriorityQueue`2.Peek">
            <summary>
                Returns the minimal element from the <see cref="T:Utils.PriorityQueue`2" /> without removing it.
            </summary>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:Utils.PriorityQueue`2" /> is empty.</exception>
            <returns>The minimal element of the <see cref="T:Utils.PriorityQueue`2" />.</returns>
        </member>
        <member name="M:Utils.PriorityQueue`2.Dequeue">
            <summary>
                Removes and returns the minimal element from the <see cref="T:Utils.PriorityQueue`2" />.
            </summary>
            <exception cref="T:System.InvalidOperationException">The queue is empty.</exception>
            <returns>The minimal element of the <see cref="T:Utils.PriorityQueue`2" />.</returns>
        </member>
        <member name="M:Utils.PriorityQueue`2.TryDequeue(`0@,`1@)">
            <summary>
                Removes the minimal element from the <see cref="T:Utils.PriorityQueue`2" />,
                and copies it to the <paramref name="element" /> parameter,
                and its associated priority to the <paramref name="priority" /> parameter.
            </summary>
            <param name="element">The removed element.</param>
            <param name="priority">The priority associated with the removed element.</param>
            <returns>
                <see langword="true" /> if the element is successfully removed;
                <see langword="false" /> if the <see cref="T:Utils.PriorityQueue`2" /> is empty.
            </returns>
        </member>
        <member name="M:Utils.PriorityQueue`2.TryPeek(`0@,`1@)">
            <summary>
                Returns a value that indicates whether there is a minimal element in the
                <see cref="T:Utils.PriorityQueue`2" />,
                and if one is present, copies it to the <paramref name="element" /> parameter,
                and its associated priority to the <paramref name="priority" /> parameter.
                The element is not removed from the <see cref="T:Utils.PriorityQueue`2" />.
            </summary>
            <param name="element">The minimal element in the queue.</param>
            <param name="priority">The priority associated with the minimal element.</param>
            <returns>
                <see langword="true" /> if there is a minimal element;
                <see langword="false" /> if the <see cref="T:Utils.PriorityQueue`2" /> is empty.
            </returns>
        </member>
        <member name="M:Utils.PriorityQueue`2.EnqueueDequeue(`0,`1)">
            <summary>
                Adds the specified element with associated priority to the <see cref="T:Utils.PriorityQueue`2" />,
                and immediately removes the minimal element, returning the result.
            </summary>
            <param name="element">The element to add to the <see cref="T:Utils.PriorityQueue`2" />.</param>
            <param name="priority">The priority with which to associate the new element.</param>
            <returns>The minimal element removed after the enqueue operation.</returns>
            <remarks>
                Implements an insert-then-extract heap operation that is generally more efficient
                than sequencing Enqueue and Dequeue operations: in the worst case scenario only one
                shift-down operation is required.
            </remarks>
        </member>
        <member name="M:Utils.PriorityQueue`2.EnqueueRange(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
                Enqueues a sequence of element/priority pairs to the <see cref="T:Utils.PriorityQueue`2" />.
            </summary>
            <param name="items">The pairs of elements and priorities to add to the queue.</param>
            <exception cref="T:Utils.ArgumentNullException">
                The specified <paramref name="items" /> argument was <see langword="null" />.
            </exception>
        </member>
        <member name="M:Utils.PriorityQueue`2.EnqueueRange(System.Collections.Generic.IEnumerable{`0},`1)">
            <summary>
                Enqueues a sequence of elements pairs to the <see cref="T:Utils.PriorityQueue`2" />,
                all associated with the specified priority.
            </summary>
            <param name="elements">The elements to add to the queue.</param>
            <param name="priority">The priority to associate with the new elements.</param>
            <exception cref="T:Utils.ArgumentNullException">
                The specified <paramref name="elements" /> argument was <see langword="null" />.
            </exception>
        </member>
        <member name="M:Utils.PriorityQueue`2.Clear">
            <summary>
                Removes all items from the <see cref="T:Utils.PriorityQueue`2" />.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.EnsureCapacity(System.Int32)">
            <summary>
                Ensures that the <see cref="T:Utils.PriorityQueue`2" /> can hold up to
                <paramref name="capacity" /> items without further expansion of its backing storage.
            </summary>
            <param name="capacity">The minimum capacity to be used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                The specified <paramref name="capacity" /> is negative.
            </exception>
            <returns>The current capacity of the <see cref="T:Utils.PriorityQueue`2" />.</returns>
        </member>
        <member name="M:Utils.PriorityQueue`2.TrimExcess">
            <summary>
                Sets the capacity to the actual number of items in the <see cref="T:Utils.PriorityQueue`2" />,
                if that is less than 90 percent of current capacity.
            </summary>
            <remarks>
                This method can be used to minimize a collection's memory overhead
                if no new elements will be added to the collection.
            </remarks>
        </member>
        <member name="M:Utils.PriorityQueue`2.Grow(System.Int32)">
            <summary>
                Grows the priority queue to match the specified min capacity.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.RemoveRootNode">
            <summary>
                Removes the node from the root of the heap
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.GetParentIndex(System.Int32)">
            <summary>
                Gets the index of an element's parent.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.GetFirstChildIndex(System.Int32)">
            <summary>
                Gets the index of the first child of an element.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.Heapify">
            <summary>
                Converts an unordered list into a heap.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.MoveUpDefaultComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
                Moves a node up in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.MoveUpCustomComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
                Moves a node up in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.MoveDownDefaultComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
                Moves a node down in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.MoveDownCustomComparer(System.ValueTuple{`0,`1},System.Int32)">
            <summary>
                Moves a node down in the tree to restore heap order.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.InitializeComparer(System.Collections.Generic.IComparer{`1})">
            <summary>
                Initializes the custom comparer to be used internally by the heap.
            </summary>
        </member>
        <member name="T:Utils.PriorityQueue`2.UnorderedItemsCollection">
            <summary>
                Enumerates the contents of a <see cref="T:Utils.PriorityQueue`2" />, without any ordering guarantees.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.UnorderedItemsCollection.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the <see cref="P:Utils.PriorityQueue`2.UnorderedItems" />.
            </summary>
            <returns>An <see cref="T:Utils.PriorityQueue`2.UnorderedItemsCollection.Enumerator" /> for the <see cref="P:Utils.PriorityQueue`2.UnorderedItems" />.</returns>
        </member>
        <member name="T:Utils.PriorityQueue`2.UnorderedItemsCollection.Enumerator">
            <summary>
                Enumerates the element and priority pairs of a <see cref="T:Utils.PriorityQueue`2" />,
                without any ordering guarantees.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.UnorderedItemsCollection.Enumerator.Dispose">
            <summary>
                Releases all resources used by the <see cref="T:Utils.PriorityQueue`2.UnorderedItemsCollection.Enumerator" />.
            </summary>
        </member>
        <member name="M:Utils.PriorityQueue`2.UnorderedItemsCollection.Enumerator.MoveNext">
            <summary>
                Advances the enumerator to the next element of the <see cref="P:Utils.PriorityQueue`2.UnorderedItems" />.
            </summary>
            <returns>
                <see langword="true" /> if the enumerator was successfully advanced to the next element;
                <see langword="false" /> if the enumerator has passed the end of the collection.
            </returns>
        </member>
        <member name="P:Utils.PriorityQueue`2.UnorderedItemsCollection.Enumerator.Current">
            <summary>
                Gets the element at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:RegionReconstructor.RegionOffsets.bufferStart">
            <summary> The start of the buffer region that is used by the Regional Mesh generator. 
            See <see cref="P:BufferOffsets.bufferStart"/> for more info. </summary>
        </member>
        <member name="P:RegionReconstructor.RegionOffsets.bufferEnd">
            <summary> The end of the buffer region that is used by the Regional Mesh generator. 
            See <see cref="P:BufferOffsets.bufferEnd"/> for more info. </summary>
        </member>
        <member name="T:ISlot">
            <summary> An interface to abstractify the creation and 
            handling of UI 'slots' </summary>
        </member>
        <member name="M:ISlot.AttachDisplay(UnityEngine.Transform)">
            <summary> Attaches the UI panel to be displayed representing the Item to the UI object. </summary>
        </member>
        <member name="M:ISlot.ClearDisplay(UnityEngine.Transform)">
            <summary> This handle is called when the Display UI is to be cleared  </summary>
        </member>
        <member name="T:IAttackable">
            <summary> An interface for all object that can be attacked and take damage. It is up to the 
            implementer to decide how the request to take damage is handled. </summary>
        </member>
        <member name="P:ShaderSubchunk.Active">
            <exclude />
        </member>
        <member name="T:WorldDataHandler">
            <summary> Controls static information about the world
            that is not tied to the player. Currently just
            handles day night information. </summary>
        </member>
        <member name="F:ShellSetting.Names">
            <summary>The registry names of all entries referencing registries within <see cref="F:ShellSetting.info"/>. When an element such as
            a material, structure, or entry needs to reference an entry in an external registry, they can indicate the index
            within this list of the name of the entry within the registry that they are referencing. </summary>
        </member>
        <member name="F:QuadSetting.Names">
            <summary>The registry names of all entries referencing registries within <see cref="F:QuadSetting.info"/>. When an element such as
            a material, structure, or entry needs to reference an entry in an external registry, they can indicate the index
            within this list of the name of the entry within the registry that they are referencing. </summary>
        </member>
        <member name="F:LightBaker.BakeQueueOffsets.QueueCount">
            <summary> The index of the element tracking the amount of items in the queue. </summary>
        </member>
        <member name="F:LightBaker.BakeQueueOffsets.QueueStart">
            <summary> The index of the element tracking the start of the queue. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:LightBaker.BakeQueueOffsets.bufferStart" -->
        <!-- Badly formed XML comment ignored for member "P:LightBaker.BakeQueueOffsets.bufferEnd" -->
        <member name="F:LightBaker.UpdateQueueOffsets.ShadowCount">
            <summary> The index of the element tracking the amount of items in the queue. </summary>
        </member>
        <member name="F:LightBaker.UpdateQueueOffsets.ShadowStart">
            <summary> The index of the element tracking the start of the queue. </summary>
        </member>
        <member name="F:LightBaker.UpdateQueueOffsets.ObjectCount">
            <summary> The index of the element tracking the amount of object light subchunks in the queue. </summary>
        </member>
        <member name="F:LightBaker.UpdateQueueOffsets.ObjectStart">
            <summary> The index of the element tracking the start of the object light subchunk queue. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:LightBaker.UpdateQueueOffsets.bufferStart" -->
        <!-- Badly formed XML comment ignored for member "P:LightBaker.UpdateQueueOffsets.bufferEnd" -->
    </members>
</doc>
